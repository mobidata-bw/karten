var pf = Object.defineProperty;
var gf = (t, r, e) => r in t ? pf(t, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[r] = e;
var w = (t, r, e) => gf(t, typeof r != "symbol" ? r + "" : r, e);
import io from "maplibre-gl";
const jl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mLYpUHOwgopChOtlFRRxrFYpQIdQKrTqYXPoHTRqSFBdHwbXg4M9i1cHFWVcHV0EQ/AFxdnBSdJESv0sKLWK847iH97735e47QGhWmWaFEoCm22YmlRRz+VWx5xUhmmGMIi4zy5iTpDR8x9c9Any/i/Ms/7o/R79asBgQEIkTzDBt4g3imU3b4LxPHGVlWSU+J54w6YLEj1xXPH7jXHJZ4JlRM5uZJ44Si6UuVrqYlU2NeJo4pmo65Qs5j1XOW5y1ap2178lfGCnoK8tcpzWCFBaxBAkiFNRRQRU24rTrpFjI0HnSxz/s+iVyKeSqgJFjATVokF0/+B/87q1VnJr0kiJJIPziOB9jQM8u0Go4zvex47ROgOAzcKV3/LUmMPtJeqOjxY6AgW3g4rqjKXvA5Q4w9GTIpuxKQVpCsQi8n9E35YHBW6Bvzetb+xynD0CWepW+AQ4OgfESZa/7vLu3u2//1rT79wN2rHKoBaSKHQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB+gEBAUlKJesuC4AABWbSURBVHja7Z3fcxTHEce/t1ohYekA2QaBDBgocGLHNmW7Kg4pV9l5SeUleci/4b9H/0aeU3mJXXEF5yEmEOw4hgKFH7JBtpEQwhLS3eVhunV9w+7tHWh3e2Z7q64OyZJ18+Mz3+7pme4W7Bn6tBdXWwD4lYj3FMA0gCkAswCOAJihrw8AOAfgdwDOAmgDmKDf3YunB6ADYB3AdQB/BnANwEMAWwA2ANwH8Ii+3gSwA6BLv8vvvfWPD/VslPOflnVBLhQQYKQCiEl6zQCYB/AigGMA3gBwGMB+guQQgFfpfZKg2sunC2AbwCqA/9H7FoCfAKwA+ArAtwB+BHCPoNmmFwOzw6AAgMFigIyrFhMChgMERJu+PkJQHCNI5un7qfi9F+i9VUJf88TeBvCY3js06TcIih8Jkq9IUTZIde6R2myI3zNVMUBGAiOlST1NrwMAjgM4BeAtAUKbIJklxZim35WAJSXB4UPSlROcINkkRXlEcKwLcP4NYAnAHQJlk17bUlUMlIYDkgHGPpr8BwEcJWVYAPA2AXKcwGAza0ooRiL6s1Vx//Yy3rtCUbaEebVOYCwBuAJgmZTmOwBrBNETA6XBgAwBYw7ACYLhbYLjRYLlIP3MpOest2oAYhxgep5zvk0QrBEUPxIkVwia2wAeGCgNBGQEME4DeIcAOUHm1bRwztMaVWIv1WVHOOubZGbdJkAuAbhpoDQIELErlRSAcZq+nhNqMeEpReh91vOUpSNU5QGBcbMAlG5Tdr1aDYGjRROdYxZFYOzzHO4Y+8o3w3YIgCJQOLbSaYKatBoAR0JKsB/Ay2Q+nRkRjKaYoL0RQblBZtj3cPGWbQDdmCFpRQyGVI0DcFuybwL4FVx0+6SBMRYot+Ci9p8DuAq3dfwwdjVpRQxHCheoO0xKcY7geJNgaRsYY4GyTlBcJUiukbKswAUqd2KEpBUhHBM06WfgotznAVwgQE6TmbWffiYxMEYCpUsA/ETm1U0C5CKAy3DR+g36mU5MkLQiAsM3qeYJjg/pfZ6+P4X+wUEDYzxQOmRSPYSLyF8G8Cm934vR5GpFBEeWSXWB4DiGwXNSMDieCRJg8LzXtwTHxVhNrlZEcMzCRb59k+owgZOaauypmuwQCCsZJtcy3HZw8JCkEcHxCoB3AXxkJlUli2oqVHmGFqIZsRDdZUjai6vBBhXTwOHgo+gMx2/ofcEzqQyMvYfEP7YzhcGjOCBINgBshwpJGigciYBjwYPjFQFHYnCUDgovQKzi/rMsIAkuqJgGCscU+kfSz5NZxXDMmr9ROSS8YPmQsLrwUfqt0CBpBQrHS+SE/xzArwmSBYNDjfP+iJTjMoC/A/ianPgf4LaBg4GkFRAcLbjI9xyA1wH8Fu6G31m4yLjtVOmC5DFc5P063A3GvwD4D9yxlScIZHcrCQgO9jmOknK8Re9Hvd0Tg6N+5z0tGKtJAC1xDcEAeU44UuGQnyez6iz6x0ZsG1cfJBPon6A+65nCuwuadkiSQODIinMcMTiCgeTIsM0UzZCkyjvZh0PGOV4wOILwbydorBbQP67Cz24wMeO/GSAF6iE71o9z2G5VWJDIhc536u8A2Ggvrqp02lPFcEzBHV+wOEeckPBu1xYrSHtxVd1R+UQhHGxaHYA7bHghy7kzOIL0SfzNlgs0xge0+iOpwo7kTpyHCwaew2BaT4MjfCXxx3eFlKSrzR9RoyCe33EsZ4Wxs1XhQ5LkWAjHeONFk4okiuBIPL+DbwIexuCRdXvCh2SiYKwTLZAkSuDgSHnuqmJwRAlJnrWgJtKuxcSSAaU8v8Oe+CDJ8kdkALjZCuKZVi+jn7dqYGcDcWY19EsX5L3kz8YGiL9jyWmZXtZiaqVKVpFZuIyHfgfFYlrllSfojdFPdZZXqMIf4QVyDS5Dyjr6JRt6jQMk4wj7GfSPrquR2D2Cwi9BwAEyruxUpPI8ieROntbSC89rYp+luXAHlGurvbjaqiuAmNa8erANegIuV+5JuIyHIZtWWdnT/SI2G/DS4xT0Eacz4qPiecV7QuwzGR9p0xx4By5TCt8dqU1FagEkQz1O02uOvhdivMNP18n1N7LKoN2HuzwkA2S9HLOKt0NfR7+Sblb5t0mEm0aV2+rPh9t1q0haY4f46nEi0F2rvITPsoJTViHNFfTTdfZG6KcryC8gKitghZpvOGtO1K4ilQMygnqEMqhFJQOWMFgD0C/FvAWvDPOQnZ4HBJQsQX0VT9dQDLmUQ968qFVFUiUrRWjqIZ3tvFoaS/S1rCK74znrow42A8WmyAO4JNJchfc6ATKs5kkSCCSqVKRSQCJQDz+J8yMUly3z65Dv7nCNuhpSv3VF32yLv79GCnWL/nZW1Sz2VbRfMFOnIqmCFSIU9cjKSbsEV3WpsPDlOED4j/i9ngcM1xfMUjEG5Qypi8xRDOWQqFGRyjpJRM33w12a+RDAH+HO4cyhX15Zs0nVwWDOp4tk3txCTRVhCyr3noSLK8g7NbN4uq67tofLVT+gfv4TXJmFu3A1SirLq1W1giRkNx8lxzIE9fDriy8D+ALAJzR4XIqsllLJ9Hd6BMq25xc9FDtn/Nn44tmkYkh8FXkbwH8hEs/FaGLxsYJpsfuye3JT6UCxv8G1xLlozCcEyTKZW9vsY9QV8c0AhQOUm56pt4N+5vtp6DzO45/wXqA5M00K3qnKzKoEkIwj7bLBE8rh4AyBN5BdA6MDRak0BShyQ+GugGMD7tTsGfQzUmqFJGtBXYNLhF2Js55W2FiWzOMkmUep8YlSOLq0+t4H8E8AnwH4BoFUUVr/+FCvvbjKO2eP4M42bdFnfw3ABwDeo3HYr9Tc8k3ya7RjV5mzXvrkzEjEcIpeB5WaV9LneEjK8RmAfwD4EoMFK1Xnl2U1wWDJtC+pLZ9R2x5KE1GpmXVQzJtKEzykFa8E83B5Wo8rdc6lWbJBPsc1Uo5lAKu0CgdTyTXD5OLP/Q21ja+5tqHvZLBvebwFd4btB1KRbhUTt8qVoE2QtBWrh5++/yKZVWuhwZEBCgc416hNmTUFlapILXOnKvtfVoSSW4xanXJ/K3clZDhyIFlB9o5cB/puL9Y2f0r9IxnZ2Y8oVQ/2O4ZOnBjqfgtIhi0EmvwRX0WOoMLs8GlFELL/8QY1cEqZgkjTaikA02OvTcmsBWxS0QLG92L4mP9VuMOapQcNkwro5+uiL8LdX9CWW5cd1ydwRxtuwB0fuS9NjhjUI2N3S8Z5rlPbdytAKVkU/DIYfAemkpwFpQGSUd+j0oY9w2q6AXfQ7xLc2ard7c+Y4PAgkdvZt6jtuydnlZlZuQttmWZW2QriS+M8dAUHffW4icGTo1HCkQFJXvs1pRuqxVSvwsRi+/Yw9CWgzlIPjSto0/ugVTCXggSEG8WX8aehKzBYpB69mNUjwx8JQUUYkmkMJvcI1sSqvEGmHtGrSKULbimAZMQ/KpPEMdVjGy6qvESvRqnHEBXh/lhD/1CgFkgy51RZjnpSMnwyp9Nh6Ip/8Gnd7+CyjzRVPfJU5Ar1zSYqvKCkbU6V7YNwinttDro8cvEjXLCMt3UbpR4ZKsLbvpyuiFOk1t0nWVZJ6XdZkhIbw///FP00mZrMK44kf0sTYRM6zyHVsXBsop/wTp4k0GRmyVzFKGtuVXWaV5NzzubVFlwE+Su4Y+2aTAkNpuc99LNBbinqmxaeznYflpM+RFG0rJJsSqzDS2rQRPMqw8xiX4TzCWty1CudU0lD54LMUsLJ3Uw9rH8aD0hIK6RKhW1aHzVRQeS9D78EgT3WR40HRB7zXjH/o9AP4Qwujdzha6KJxSskV31qamBwlL6SfdT1+tAAacAE6JrvUeiLdJvcP4lNAnusjwwQe+wxQOyxxwCxp+qnZYDY4NuT3TeVnXkyQHROAG2HKLX1T2WnZg0QXYqh8Ri+iifnNqjWGiIGSEmQZF7kqiKdfkDzQvNtUAPEBl+FeaU1XVN0gGhLhKw9mbYW51xjuqZK51RSUUO0HekIoRyDBgXRmq6psiMwScl0azwUWGs6/QAddG2VwCo9RJmU3JDMY+UKQNGeM7juvtFYrqKWY/hlNlrrpZu8rPOaS1JX2Tey9LK2chWVz6lSAMm5dKMtjaVMp881uCebamYNqWWvqVxF7pwq67JbUlGDNtGvSqrFWfdrcJ+Azsq7VTvmM9QX2mrZS+f8Cc2p0hfcJLYGPYOjLmtwz9GuTaNURKjHPuoD7g9ttewrX3CrUpANhY66v2K+02AV0d4XtZnsZQOiOTuGv2qeplejVCRDPZ7qByWLRS1zqTRAAsnSZyoSRh/Ulg0zqYh8rVn6ilbPJGYVobYlAahHbfMoqZN8xSpyEv1t3yghEXDwtu5J5epRiyVSlYJoztLnq8gZAGfhIsi79yBigkT4HXzs/wi1+Yxi9ahlDpUKSEDZwmVk/RSACwDOwwXLZiP0R2R7F6itF6jt2tpbazb+pMIVQHO2cDY3+J7IeQAfAXiXJtALACZiUBFqAyvHArXxI2qzvBujqa21zZ+0xhVgjuzfnpLB8CeOVL/d08jtxdVOqDl8BRxDFwKF6lGbBVKlgoRQ0SnP9DgNF1WeClVJPDgOUptCMCVrrXhVuoKsf3yo115czasJOKtsxeLPMUE7OfMAzgF4Da48MuBKI2+1F1c7CCAjvOeQMxwL1KZz1MYZMQ7aqoHl1kysou+TihuaWVUW+kp7ye3PMwA+APA+gF/AHQEP4oJVxgWoY9SG96lNZyC2s6G3VF5tVXerPKXp1yW/A711yRmSabgt0PcA/B7AHwD8EsBxYZKojJOIOAebjMfps/+B2vIetW0aOpPDSd/jDmqq216Fky7NrG0yUZbo9aqYaD1lgySd9qPIrve+DHerbbu9uNrVYHIJ1WAVzNqtmifl0HpJTKqHnC9rqLiWfVrzivAzAC9Bb9odhmQ/nk40x6bLfTIBngDYoYWgclAEGPy59hEERzJ2q2aUmlXqLI7KAPFURNqUGp31PJ+kDeAVz66/DuAWOfEbVYOSA8YM3Db6SbgIub9bNaEcDt85H/BZq1x80pobzrsSh6ArJpIHSUvY85z04QaASwBuAridBwovEnsIBYaAcQJuG/cdcsRPoZ9CVHsCuDznfBM11ElMa+gAua/9Je2qvAz92Q1bos/YD2kTLKcJkCxQtmlguwQLxgXGA0ICO4F+fi8fjNP09RxBLe+Wa47jqHDOawEksJhIHiS+E+xPTgZliUB5SO3jK8d8TVQCM46C8c7UNL0O0N8+lQHGDClLijDKGKhxzutUkDz78qByMyvPL8kzb5Zo9WMT4Z5QlG0MJtPrFQDJGwSTAsp59DOyvE2AZIHRQlhpVVWFA1IlnXCWBnsf+kkCEAAkLRq0LFBepV069rX4mMQG3HmiUe5V+1kO2+jnFH4D/ZxeR2mBCRkMVc55bYAMiYmcFLZ9L6CBzQNlFm4Le4vMybcIDD50599r6OWolMxEz2lSOWUq+xbT4m+HCIY657xuBZGO2G2y2eVVz8kABzgLlCka3IO0EcHm1QaZRY9HVBAZpGQzi2Mycss25Az1/pyo1TmvFRChIk9ot+cmvU4EqiJ5oMidpin084TN0YTvjDD4/P+Y8pxtP+N6yHdVWD14PtTunNetILGqiA8KPFh4kCUw4+5iIRIoiubCbSg4q1db3EFcx/VV5AF9T9sp371QlUS8UmGKDXtNCuVIEF/h0cJ5UOf5tlThyhGTihSpC2BVrdSqR60K0kAVsScw9agdkBBWEHuaPfa1A2IqYuqhVT20KIipiKmH2jFXAYipiKmHRvXQpCCmIqYeKsdaDSCmIqYe2tRDm4KYiph6qBtjVYCMoCJdgyR4OLqhqIdGBclbYW7BHRXXVFfEnmczrXZoLG+FYCGoAyRDRW7AZQ65D+AnuBOw9oT5dGgM79OY3tCsHkD9Z7GKVOQR3LHnz9G/Mcf5nEK4Y23PoGm1BeB7AFdpTJcgcu1q/OAqs4jQShJkh9oz8oJ3lcZ2C0BXaxLwRHnHDpNkc9jDdMyDMpnVAuKVb5NOnTns4TvmA2OouYSEagURppY57HE65l3t9VXSADrYHHZzzE1BnsFhvwm9RXjsCdgxDwqQHKm+Ri8ztcwxN0CEw85JxW5mrUimIuaYN1ZBLDZijrkBsgedb5DUrh6dmBaxoAApiI2Yw67HtMo1g0NSjyAVpCA2UpTr1p5yAeFT2Pdi2UhJAx8M3kK8iH5cZIL+HVP2wVBMq8dwpR4u05gMbMWHph6h+iC+w75CA/IpvQ8rKWBPOXAUjkWIcAQLiICkcNUySCrxO+T2+0Uai29pbDqhwhE0IDHbvYE9WQFcLjcXvD8YNCDerpYFEOszrbKOAAUVEIxVQaSpZWe16jWt/IWpEzocUQBSIPVmall/GyAjntWqrRBkhOpRqNgxqEdUCjLCsXi7gbh3plVU0fJhTxrhIGZJ/2G4moBc+swCiM8OSKN2DWPyQfJMraf25U1Fnsu0ii5a3hhAMkytvMiuQfLsfkd00fJGASIgGbbamT/yfH5HVNHypvkgRfay+SN704/RRMsbpyCeP7Jj/khpfkcU0fJGAuKZWuaPlON3dGKGI3pAzB8xv8N8EPNHzO8wBTF/xPwOA8T8EfM7DJAA/JGm3h/hAGvj/Y7GAjKifd1poNPeE+rReL+j0YAU+CPLaGaWRpklZrnpfkfTFSTPH/kEwBc0QZrktEuzc5n64JMm+x3ySdHQZ/3jQ7324qqcGJxHK4Xb+uVt3wnEu/070kLRVDgaDUiOaZHCJZ07TO8MSYwFeoY55U01Nc3EyvFHRnFOe5HBMdJmRZPVo/GACEiGraSxQeLDkeeUd5sOhwEymtN+NzJzQ5qVd80pNx/keZx2floAjiP8pNhZO1Z/NafcAHnW1ZXhiGFnq0kqaSZWyU57oX0e2EQa2c8y9TBAxoUk9J2tkdtjcBgg40ASw86W7VgZIKVCMqrN3lMOh+1YmZNeDiRDdrYA4BUAs6IfW8rhsB0rA6SUyebvbOVB0lL6mSUctmNlgOy5imAIJNpiJMNiHQNwmHoYIGVDoi1GMrLfZHCYk16G0645RmKxDgNEHSRaYiQW6zBAVEGiKUZisQ4DRCUkGmIkFuswJ121415njMRiHQaI+mecGMleQlIEh8U6DBA1KoKKIRkLDlMPA6RJkBgcBohBYnAYIAbJeJAYHAaIQWJwGCAGyXiQGBwGiEGSA4nBYYAYJDmQGBwGiEGSAwkMDgPEIBkOicFhgBgkGZDM0L83DA4DxCDpP1xi4Sh9/R2ASwaHAdJkSPjuRgJgEv167QBwFcDfAPwLdhuw1sfug9QAiXDCH8Pd+Psa7v7GHXpdpu/do58xOGp6/g9eQPkxBqxc0wAAAABJRU5ErkJggg==", Zl = {
  draw: {
    marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "marker",
      settings: {
        exclusive: !0
      }
    },
    circle_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle_marker",
      settings: {
        exclusive: !0
      }
    },
    text_marker: {
      type: "draw",
      eventType: "toggle",
      targetMode: "text_marker",
      settings: {
        exclusive: !0
      }
    },
    circle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "circle",
      settings: {
        exclusive: !0
      }
    },
    line: {
      type: "draw",
      eventType: "toggle",
      targetMode: "line",
      settings: {
        exclusive: !0
      }
    },
    rectangle: {
      type: "draw",
      eventType: "toggle",
      targetMode: "rectangle",
      settings: {
        exclusive: !0
      }
    },
    polygon: {
      type: "draw",
      eventType: "toggle",
      targetMode: "polygon",
      settings: {
        exclusive: !0
      }
    },
    freehand: {
      type: "draw",
      eventType: "toggle",
      targetMode: "freehand",
      settings: {
        exclusive: !0
      }
    },
    custom_shape: {
      type: "draw",
      eventType: "toggle",
      targetMode: "custom_shape",
      settings: {
        exclusive: !0
      }
    }
  },
  edit: {
    drag: {
      type: "edit",
      eventType: "toggle",
      targetMode: "drag",
      settings: {
        exclusive: !0
      }
    },
    change: {
      type: "edit",
      eventType: "toggle",
      targetMode: "change",
      settings: {
        exclusive: !0
      }
    },
    rotate: {
      type: "edit",
      eventType: "toggle",
      targetMode: "rotate",
      settings: {
        exclusive: !0
      }
    },
    scale: {
      type: "edit",
      eventType: "toggle",
      targetMode: "scale",
      settings: {
        exclusive: !0
      }
    },
    copy: {
      type: "edit",
      eventType: "toggle",
      targetMode: "copy",
      settings: {
        exclusive: !0
      }
    },
    cut: {
      type: "edit",
      eventType: "toggle",
      targetMode: "cut",
      settings: {
        exclusive: !0
      }
    },
    split: {
      type: "edit",
      eventType: "toggle",
      targetMode: "split",
      settings: {
        exclusive: !0
      }
    },
    union: {
      type: "edit",
      eventType: "toggle",
      targetMode: "union",
      settings: {
        exclusive: !0
      }
    },
    difference: {
      type: "edit",
      eventType: "toggle",
      targetMode: "difference",
      settings: {
        exclusive: !0
      }
    },
    line_simplification: {
      type: "edit",
      eventType: "toggle",
      targetMode: "line_simplification",
      settings: {
        exclusive: !0
      }
    },
    lasso: {
      type: "edit",
      eventType: "toggle",
      targetMode: "lasso",
      settings: {
        exclusive: !0
      }
    },
    delete: {
      type: "edit",
      eventType: "toggle",
      targetMode: "delete",
      settings: {
        exclusive: !0
      }
    }
  },
  helper: {
    shape_markers: {
      type: "helper",
      eventType: "toggle",
      targetMode: "shape_markers",
      settings: {
        exclusive: !1,
        enabledBy: [
          "drag",
          "change",
          "rotate",
          "scale",
          "line_simplification"
        ]
      }
    },
    snapping: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snapping",
      settings: {
        exclusive: !1
      }
    },
    pin: {
      type: "helper",
      eventType: "toggle",
      targetMode: "pin",
      settings: {
        exclusive: !1
      }
    },
    snap_guides: {
      type: "helper",
      eventType: "toggle",
      targetMode: "snap_guides",
      settings: {
        exclusive: !1
      }
    },
    measurements: {
      type: "helper",
      eventType: "toggle",
      targetMode: "measurements",
      settings: {
        exclusive: !1
      }
    },
    auto_trace: {
      type: "helper",
      eventType: "toggle",
      targetMode: "auto_trace",
      settings: {
        exclusive: !1
      }
    },
    geofencing: {
      type: "helper",
      eventType: "toggle",
      targetMode: "geofencing",
      settings: {
        exclusive: !1
      }
    },
    zoom_to_features: {
      type: "helper",
      eventType: "click",
      targetMode: "zoom_to_features",
      settings: {
        exclusive: !1
      }
    },
    click_to_edit: {
      type: "helper",
      eventType: "toggle",
      targetMode: "click_to_edit",
      settings: {
        exclusive: !1
      }
    }
  }
}, mf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path d="m22.775 29.562 6.75-6.75-5.625-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.626-5.55-6.75 6.75zm25.95 26.101 6.75-6.825-5.624-5.625-3.6 3.6-3.15-3.15 3.6-3.6-5.55-5.55-6.75 6.75zm.6-46.126 5.25 5.25ZM16.7 59.039H5v-11.7l14.55-14.551L2 15.237l13.05-13.2L32.75 19.661 46.1 6.312q.676-.676 1.5-.976.826-.3 1.65-.3.826 0 1.65.3.826.3 1.5.976l5.326 5.325q.675.675.975 1.5.3.825.3 1.65t-.3 1.65q-.3.825-.975 1.5l-13.35 13.35L62 48.913l-13.125 13.05-17.551-17.55Zm-7.2-4.5h5.25l29.476-29.552-5.25-5.25L9.5 49.288ZM41.6 22.361l-2.625-2.625 5.25 5.25Z"
          fill="currentColor"
          style="stroke-width:.0750028"/>
</svg>
`, Xl = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor"
            style="stroke-width:7"/>
    <circle cx="32" cy="32" r="5" fill="currentColor"/>
</svg>
`, vf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <circle cx="32" cy="32" r="26" fill="currentColor" fill-opacity=".15" stroke="currentColor" style="stroke-width:7"/>
    <line x1="6" y1="32" x2="58" y2="32" stroke="currentColor" stroke-width="4" stroke-dasharray="3"/>
    <line x1="32" y1="6" x2="32" y2="58" stroke="currentColor" stroke-width="4" stroke-dasharray="3"/>
</svg>
`, yf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path
            fill="currentColor"
            d="M32 61.4 19.85 49.42l3.28-3.235 6.634 6.542V34.205H10.98l6.26 6.174-3.279 3.234L2.185 32l11.852-11.686 3.28 3.234-6.336 6.247h18.783V11.273l-6.261 6.174-3.28-3.234L32 2.6l11.777 11.613-3.28 3.234-6.26-6.174v18.522h18.782l-6.26-6.174 3.279-3.234L61.815 32 50.038 43.613l-3.28-3.234 6.261-6.174H34.236v18.522l6.634-6.542 3.28 3.234z"
    />
</svg>
`, wf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <line x1="8" y1="50" x2="24" y2="20" stroke="currentColor" stroke-width="8"/>
    <line x1="24" y1="20" x2="40" y2="54" stroke="currentColor" stroke-width="8"/>
    <line x1="40" y1="54" x2="54" y2="10" stroke="currentColor" stroke-width="8"/>
    <circle cx="8" cy="50" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="24" cy="20" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, Ef = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M32 62.81s23.107-21.898 23.107-38.512a23.107 23.107 0 0 0-46.214 0C8.893 40.912 32 62.809 32 62.809m0-26.958a11.554 11.554 0 1 1 0-23.107 11.554 11.554 0 0 1 0 23.107"/>
</svg>
`, Mf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Polygon -->
    <polygon points="8,28 40,6 55,35 51,55 18,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="9" cy="28" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="40" cy="8" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="55" cy="35" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="50" cy="55" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="18" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, bf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <!-- Rectangle -->
    <polygon points="10,10 54,10 54,54 10,54" fill="none" stroke="currentColor" stroke-width="8"/>

    <!-- Vertex Circles -->
    <circle cx="10" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="10" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="54" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
    <circle cx="10" cy="54" r="6" fill="white" stroke="currentColor" stroke-width="4.5"/>
</svg>
`, xf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M39.063 42.14 22.288 28.12 7.96 44.603l11.338 9.854h9.059zm-3.498 12.317h25.941v5.465h-44.25L4.377 48.726a5.465 5.465 0 0 1-.542-7.711L34.311 5.958a5.465 5.465 0 0 1 7.712-.538l16.496 14.343a5.465 5.465 0 0 1 .541 7.709z"
          style="stroke-width:2.73262"/>
</svg>
`, _f = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M58.709 17.724c-.3-.6-.601-.901-.902-1.502l-.3-.601c-.301-.601-.602-.902-.902-1.503l-.3-.601c-.301-.601-.602-.902-1.203-1.503l-.6-.901 8.414-9.317-13.825.3-13.824.301 1.502 13.524 1.503 13.524 9.617-10.819v.3l.3.602c.301.3.301.6.602.6l.3.602c0 .6 0 .901.3 1.202.903 2.104 1.804 4.208 2.105 6.311.6 4.208 0 8.716-1.804 12.623l-.6 1.202-.301.3-.902 1.503-.3.601c-.601.601-1.202 1.503-1.804 2.104-1.502 1.503-3.305 3.005-5.109 3.907-1.803 1.202-3.907 1.803-6.311 2.404-2.104.301-4.508.601-6.612.301-2.404-.3-4.508-.902-6.612-1.503-2.103-.901-3.907-2.104-5.71-3.606l-1.202-1.202-.601-.902-.601-.601c-.3-.3-.601-.601-.601-.902l-.902-1.202-.3-.3-.602-1.203c0-.3-.3-.3-.3-.6l-.902-1.503-.3-.601-.902-2.705q-.901-3.607-.901-7.213V27.04c0-.601 0-.901.3-1.202l.3-1.803.602-1.803c.901-2.405 2.103-4.509 3.606-6.612q2.254-3.156 5.41-5.41c.6-.3.901-1.202.3-1.803-.3-.3-.6-.601-.901-.601h-.601l-.3.3c-2.706 1.202-4.81 3.006-6.913 4.809-2.104 2.104-3.607 4.508-5.11 7.213-2.704 5.41-3.606 11.42-2.404 17.431.3 1.503.601 2.705.902 4.207l.902 2.405c.3.3.6.6.6 1.202l.602 1.202c0 .3.3.601.3.601l.902 1.503c.3.601.6.901.901 1.503l.301.6c.3.301.601.902.902 1.203l2.103 1.803c2.104 2.104 4.809 3.907 7.514 5.41q4.057 2.254 9.016 2.705c1.503.3 3.005.3 4.508.3 1.803 0 3.306 0 4.809-.3 3.005-.602 6.311-1.503 9.016-3.006l.6-.3c.602-.3.903-.601 1.504-.902l2.103-1.202c.601-.3.902-.601 1.203-.902l.6-.6a3.622 3.622 0 0 0 1.503-1.504l.3-.3c.902-.902 2.105-2.104 2.706-3.005l1.803-2.705 1.202-1.804c3.005-5.71 4.208-12.322 3.306-18.633-.601-3.306-1.503-6.612-3.005-9.317z"/>
</svg>
`, Sf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path stroke="currentColor"
          stroke-width="3.8"
          d="m2.155 32.345 42.35-29.82M18.963 60.919l42.35-29.82M31.443 2.332l29.82 42.35M2.207 19.515l29.82 42.35"/>
</svg>
`, Af = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="none" d="M0 0h24v24H0Z"/>
    <path fill="currentColor"
          d="M6.962 3.385h50.076a3.577 3.577 0 0 1 3.577 3.577v50.076a3.577 3.577 0 0 1-3.577 3.577H6.962a3.577 3.577 0 0 1-3.577-3.577V6.962a3.577 3.577 0 0 1 3.577-3.577Zm3.577 7.154v42.922h42.922V10.539Zm7.154 7.154h28.614v7.153H17.693Zm0 14.307h28.614v7.154H17.693Z"
          style="stroke-width:4"/>
</svg>
`, Lf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M16.862 2.13 7.297 21.17a2.091 2.091 0 0 0-.193 1.288l4.107 24.166-7.618 13.15 3.619 2.096 7.997-13.804a2.091 2.091 0 0 0 .252-1.397l-4.119-24.235 9.256-18.428Zm40.876.255-1.25 2.49 2.668 1.341 1.25-2.49zm-2.593 5.16-2.68 5.337 2.668 1.341 2.682-5.338zm-4.022 8.007-2.682 5.338 2.67 1.34 2.681-5.337zm-18.67 5.83.055 6.984-11.118.087.056 7.242 11.12-.088.054 6.985 10.521-10.688zm18.927 2.817-2.945.5 1.001 5.89 2.945-.5zm1.502 8.835-2.945.5 1.001 5.89 2.945-.5zm1.502 8.834-2.945.5.74 4.355-.24.413 2.585 1.499.51-.881a1.494 1.494 0 0 0 .18-1zm-3.943 7.854-2.994 5.17 2.584 1.496 2.994-5.169zm-4.492 7.754-1.497 2.584 2.584 1.497 1.498-2.584z"/>
</svg>
`, Cf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M41.687.926a2.173 2.173 0 0 0-.433.045c-4.075.232-7.358 3.618-7.358 7.747 0 .084.01.164.012.246l-12.987 4.261a7.842 7.842 0 0 0-6.126-3.563 2.173 2.173 0 0 0-.424-.043 2.173 2.173 0 0 0-.435.044c-4.073.232-7.358 3.618-7.358 7.747 0 3.143 1.901 5.869 4.604 7.097L8.377 35.11a2.173 2.173 0 0 0-.028.007C4.274 35.35.99 38.736.99 42.865c0 4.277 3.514 7.791 7.791 7.791 2.497 0 4.727-1.201 6.157-3.048l12.887 6.235a7.67 7.67 0 0 0-.139 1.44c0 4.277 3.515 7.791 7.792 7.791 4.278 0 7.793-3.514 7.793-7.792a7.67 7.67 0 0 0-1.885-5.027l.508-1.05-3.263-1.579 4.505-29.969.888-.29-.368-1.122a7.78 7.78 0 0 0 2.28-1.018l.447 1.364 4.72-1.547-.774-2.359-2.522.826a7.73 7.73 0 0 0 1.672-4.793c0-4.132-3.288-7.52-7.368-7.748a2.173 2.173 0 0 0-.424-.044zm0 4.346a3.414 3.414 0 0 1 3.447 3.446 3.415 3.415 0 0 1-3.446 3.447 3.414 3.414 0 0 1-3.446-3.447 3.414 3.414 0 0 1 3.445-3.446zm20.076 3.725a1.242 1.242 0 0 0-.382.062l-1.612.528.578 1.76-.293 1.94 2.456.37.486-3.234a1.242 1.242 0 0 0-1.233-1.426Zm-4.354 1.364-4.72 1.548.775 2.36 4.719-1.548-.774-2.36zm-22.153 2.732a7.877 7.877 0 0 0 3.735 2.922l-.062.408-.397.13.26.793-4.255 28.298-3.818-1.847-1.082 2.235 3.718 1.798a7.841 7.841 0 0 0-3.543 2.147l-13.272-6.42c.02-.23.035-.458.035-.692 0-2.888-1.609-5.408-3.969-6.745l2.912-11.012c3.74-.562 6.645-3.81 6.645-7.698l-.001-.02 13.094-4.297zm-20.885.87a3.414 3.414 0 0 1 3.445 3.447 3.414 3.414 0 0 1-3.445 3.447 3.414 3.414 0 0 1-3.447-3.447 3.414 3.414 0 0 1 3.446-3.446zm45.314 1.78-.738 4.912 2.456.37.738-4.912zM36.172 17.33l-1.793.588a1.242 1.242 0 0 0-.813.862l-.788 2.978 2.401.634.615-2.325 1.15-.377-.773-2.36zm22.405 5.781-.737 4.913 2.455.368.739-4.91zm-26.432 1.048-1.27 4.802 2.401.634 1.27-4.802zm25.325 6.32-.739 4.913 2.457.368.738-4.911-2.456-.37zm-27.23.882-1.27 4.802 2.402.634 1.27-4.801zm26.124 6.486-.739 4.91 2.455.37.74-4.912-2.457-.368zm-28.027.717-1.27 4.803 2.4.634 1.27-4.802-2.401-.634zm-19.555.856a3.414 3.414 0 0 1 3.446 3.446 3.414 3.414 0 0 1-3.446 3.447 3.414 3.414 0 0 1-3.445-3.447 3.414 3.414 0 0 1 3.445-3.446zm46.473 5.795-.739 4.91 2.456.37.74-4.911zm-11.124 5.072-1.082 2.236 4.47 2.164 1.083-2.237zm-8.651 1.55a3.414 3.414 0 0 1 3.445 3.446 3.414 3.414 0 0 1-3.445 3.447 3.414 3.414 0 0 1-3.447-3.447 3.414 3.414 0 0 1 3.446-3.446zm18.669.745-.358 2.378-2.953-1.428-1.083 2.236 4.472 2.163.541-1.117 1.228.183.608-4.046-2.455-.37z"/>
</svg>
`, kf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <circle cx="49.754" cy="50.219" r="10.098" fill="none" stroke="currentColor" stroke-width="5.1"/>
    <path fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="4.491"
          d="M44.516 26.657H17.842l6.669-11.55 6.668-11.55 6.669 11.55Z"/>
    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="6"
          stroke-width="4.683" d="M4.481 40.605h20.761v19.093H4.481z"/>
</svg>
`, Tf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path stroke="currentColor" fill="currentColor" stroke-width="2"
          d="M44.095 2.247a2.285 2.285 0 0 0-.135.04L12.025 12.762a2.285 2.285 0 0 0-1.497 1.588l-7.772 29.4a2.285 2.285 0 0 0 1.213 2.641L35.397 61.6a2.285 2.285 0 0 0 2.873-.754l22.64-32.582a2.285 2.285 0 0 0 .05-2.534L46.6 3.23a2.285 2.285 0 0 0-2.504-.982ZM43.7 7.182l12.203 19.12-5.167 1.76 1.052 3.09 2.031-.693L38.07 53.122l.01-1.375-3.262-.023-.034 4.5-27.13-13.127 6.975-26.38Zm3.946 21.932-6.18 2.105 1.052 3.09 6.18-2.105zm-9.27 3.157-2.329.793a1.632 1.632 0 0 0-1.105 1.534l-.03 4.068 3.265.024.02-2.91 1.232-.419zm-3.488 9.66-.047 6.529 3.264.023.048-6.528z"/>
</svg>
`, Pf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="m41.478 7.967-.033 3.069c1.887.02 3.772.337 5.561.933l.97-2.913a21.337 21.337 0 0 0-6.498-1.09Zm-3.294.215a21.567 21.567 0 0 0-6.298 1.915l1.332 2.766a18.518 18.518 0 0 1 5.401-1.641zm12.836 2.155-1.402 2.73a18.497 18.497 0 0 1 4.572 3.312l2.16-2.179a21.548 21.548 0 0 0-5.331-3.863ZM22.783 13.06c-11.848 0-21.486 9.638-21.486 21.486 0 11.849 9.638 21.486 21.486 21.486a21.37 21.37 0 0 0 14.288-5.466c.003 0 .006 0 .009.002.04-.036.078-.075.117-.11l.077-.072a21.285 21.285 0 0 0 1.51-1.532 22.128 22.128 0 0 0 .867-1.025 19.557 19.557 0 0 1-.88-.095c-.196-.025-.389-.058-.582-.09-.097-.015-.194-.028-.29-.045a18.378 18.378 0 0 1-1.576-.359l-.118-.03c-7.753-2.172-13.422-9.271-13.422-17.728a18.34 18.34 0 0 1 5.867-13.478c.1-.093.199-.185.3-.276.153-.136.31-.268.467-.4.097-.08.193-.163.291-.242.255-.203.514-.402.78-.592a21.534 21.534 0 0 0-1.76-.592l-.018-.005c-.176-.05-.355-.095-.533-.141-.132-.035-.263-.073-.397-.105-.213-.051-.43-.095-.646-.14-.077-.016-.153-.035-.231-.05H26.9a21.37 21.37 0 0 0-4.118-.4Zm35.728 3.64-2.472 1.82a18.424 18.424 0 0 1 2.61 5.004l2.907-.986a21.474 21.474 0 0 0-3.045-5.839Zm3.864 9.034-3.022.534c.328 1.86.37 3.772.118 5.642l3.042.409a21.448 21.448 0 0 0-.138-6.585zm-3.496 8.943a18.539 18.539 0 0 1-2.416 5.104l2.543 1.72a21.586 21.586 0 0 0 2.815-5.952zM54.703 42a18.288 18.288 0 0 1-4.428 3.492l1.505 2.675a21.348 21.348 0 0 0 5.173-4.08zm-6.995 4.69a18.512 18.512 0 0 1-5.526 1.158l.163 3.065a21.56 21.56 0 0 0 6.444-1.35z"/>
</svg>
`, If = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M44.698 2.661a1.644 1.644 0 0 1 2.328 0l9.866 9.866a1.644 1.644 0 0 1 0 2.329L24.004 47.744a1.644 1.644 0 0 1-.552.362L7.008 54.683a1.644 1.644 0 0 1-2.138-2.138l6.578-16.444a1.644 1.644 0 0 1 .362-.552zm-3.089 7.742 7.542 7.541 4.252-4.252-7.541-7.541zm5.216 9.866-7.54-7.54-21.378 21.376v.964h1.644a1.644 1.644 0 0 1 1.645 1.644v1.645h1.644a1.644 1.644 0 0 1 1.645 1.644v1.644h.963zM14.724 37.29l-.35.348L9.35 50.204l12.566-5.025.349-.35a1.644 1.644 0 0 1-1.07-1.538v-1.645h-1.644a1.644 1.644 0 0 1-1.644-1.644v-1.644h-1.644a1.644 1.644 0 0 1-1.54-1.07"/>
    <path stroke="currentColor" stroke-width="5.107"
          d="M6.298 59.53c3.44-1.692 6.88-3.384 10.558-4.319s7.594-1.111 11.719-.298c4.125.814 8.459 2.617 13.483 2.655 5.023.038 10.737-1.689 16.45-3.415"/>
</svg>
`, Ff = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M31.226 17.87c-4.69 0-8.532 3.832-8.532 8.508 0 1.812.58 3.495 1.558 4.88l5.932 10.255c.831 1.085 1.383.879 2.074-.058l6.543-11.135c.132-.24.236-.493.327-.753a8.396 8.396 0 0 0 .628-3.19c0-4.675-3.841-8.506-8.53-8.506zm0 3.987a4.5 4.5 0 0 1 4.532 4.52 4.5 4.5 0 0 1-4.532 4.521 4.5 4.5 0 0 1-4.534-4.52 4.5 4.5 0 0 1 4.533-4.52z"/>
    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="6"
          stroke-width="5" d="M8.97 53.509 4.423 19.145 35.698 4.199l23.88 25.127L43.06 59.801Z"/>
</svg>
`, Df = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <ellipse cx="4.907" cy="-32.051" fill="none" stroke="currentColor" stroke-dasharray="13.7543, 6.87718"
             stroke-width="5.489" rx="20.4" ry="13.713" transform="matrix(-.71127 .70292 -.86047 -.5095 0 0)"/>
    <path fill="currentColor"
          d="M34.597 25.275a1.934 1.934 0 0 0-2.04 2.165l2.922 31.37c.188 1.523 1.989 2.235 3.165 1.249l6.169-5.004 2.765 4.79c1.59 2.756 4.115 3.431 6.87 1.841 2.756-1.59 3.433-4.114 1.841-6.87l-2.755-4.773 7.31-2.803c1.443-.525 1.728-2.44.503-3.365L35.64 25.66a1.93 1.93 0 0 0-1.042-.383z"/>
</svg>
`, Of = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.947 25.554c-2.176 3.77-.867 8.656 2.903 10.832 2.126 1.229 4.607 1.346 6.757.539l8.252 12.152a7.79 7.79 0 0 0-.701 1.005c-2.176 3.77-.867 8.656 2.903 10.833 3.77 2.177 8.655.867 10.832-2.903 2.1-3.64.93-8.294-2.543-10.572a2.211 2.211 0 0 0-.36-.26 2.211 2.211 0 0 0-.404-.181 7.955 7.955 0 0 0-6.086-.432l-8.348-12.292c.19-.252.369-.512.53-.79 1.457-2.526 1.339-5.537-.03-7.907l8.202-8.256c3.494 1.335 7.562.025 9.575-3.229l13.899 2.913c.266 2.435 1.634 4.721 3.899 6.03 3.77 2.176 8.655.866 10.832-2.904 2.101-3.64.93-8.294-2.543-10.572a2.211 2.211 0 0 0-.36-.26 2.211 2.211 0 0 0-.403-.181c-3.71-1.87-8.328-.556-10.429 3.083-.084.147-.155.297-.228.446l-13.5-2.83c-.053-2.55-1.329-5.023-3.58-6.499a2.211 2.211 0 0 0-.358-.259 2.211 2.211 0 0 0-.405-.181c-3.708-1.87-8.326-.556-10.428 3.083-1.61 2.79-1.307 6.19.486 8.652l-7.84 7.892a2.211 2.211 0 0 0-.094-.036c-3.71-1.87-8.328-.556-10.429 3.084zm3.83 2.211a3.473 3.473 0 0 1 4.79-1.282 3.472 3.472 0 0 1 1.284 4.789 3.473 3.473 0 0 1-4.79 1.284 3.475 3.475 0 0 1-1.283-4.79ZM23.656 8.173a3.474 3.474 0 0 1 4.79-1.283 3.472 3.472 0 0 1 1.283 4.79 3.473 3.473 0 0 1-4.789 1.284 3.475 3.475 0 0 1-1.284-4.791zm-.666 44.12a3.474 3.474 0 0 1 4.79-1.283 3.472 3.472 0 0 1 1.283 4.79 3.473 3.473 0 0 1-4.79 1.284 3.475 3.475 0 0 1-1.283-4.791zm29.166-37.88a3.474 3.474 0 0 1 4.79-1.283 3.472 3.472 0 0 1 1.283 4.79 3.473 3.473 0 0 1-4.79 1.284 3.475 3.475 0 0 1-1.283-4.791z"/>
    <path fill="currentColor"
          d="M12.9 13.516c-.63.177-.685.37-.88.95l-1.069 3.18 2.995 1.006.844-2.506 2.074-.882-1.236-2.908zm19.209 5.25 4.378 4.554 2.277-2.19-4.379-4.554zm8.132 3.106 1.441 2.812 5.623-2.882-1.441-2.812zM5.448 46.082l3.144.304.608-6.29-3.145-.303zm4.623 3.728 5.762 2.592 1.297-2.88-5.762-2.593z"/>
</svg>
`, Gf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.717 38.645a2.675 2.668 79.7 0 0-.307 3.769L16.754 60.55a2.675 2.668 79.7 0 0 3.76.312l41.769-35.508a2.675 2.668 79.7 0 0 .307-3.769L47.246 3.45a2.675 2.668 79.7 0 0-3.76-.312zm5.486 2.352 37.702-32.05 11.892 14.056-2.717 2.31-4.458-5.269-2.033 1.729 4.457 5.269-3.11 2.643-4.457-5.268-2.034 1.728 4.458 5.27-3.106 2.64-4.458-5.27-2.033 1.73 4.457 5.268-3.11 2.644-6.194-7.32-2.033 1.728 6.193 7.32-3.11 2.645-4.457-5.269-2.034 1.729 4.458 5.268-3.106 2.64-4.458-5.268-2.033 1.73 4.457 5.268-3.11 2.643-4.457-5.268-2.034 1.729 4.458 5.268-2.098 1.783z"/>
</svg>
`, Rf = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 64 64">
    <path d="M7.839 34.833c-7.104-9.763-5.332-23.33 4.2-30.266C21.572-2.369 35.03.123 42.13 9.882L56.166 29.17c7.098 9.755 5.329 23.325-4.204 30.262-9.533 6.936-22.989 4.444-30.09-5.315L7.841 34.836Zm5.063-25.476c-6.079 5.766-7.006 15.598-1.634 22.98l.778 1.07 12.002-8.732zm3.43-2.495L27.476 22.18l12.002-8.733-.781-1.073c-5.37-7.38-15.01-9.522-22.367-5.512m25.643 10.014L14.54 36.836l10.762 14.79c5.818 7.997 16.653 9.842 24.163 4.378 7.51-5.465 9.088-16.342 3.267-24.342z"/>
</svg>
`, Bf = `\uFEFF<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M42.012 2.106a4.092 4.092 0 0 0-5.741.735 4.092 4.092 0 0 0 .572 5.607L23.964 23.45a8.185 8.185 0 0 0-10.458 2.142l5.18 4.005 5.454 4.218L7.87 59.22a1.124 7.304 37.712 0 0 1.54 1.19l20.494-22.138 5.454 4.217 5.18 4.005a8.185 8.185 0 0 0-.558-10.66l11.277-16.24a4.092 4.092 0 0 0 5.572-.858 4.092 4.092 0 0 0-.735-5.74z"/>
</svg>
`, Nf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <g fill="currentColor" stroke="currentColor">
        <path d="m37.62 5.028-.337.284-4.039 4.068 3.547 3.523L39.875 9.8l2.846.596 1.025-4.893-4.176-.877Zm9.995 6.393 9.787 2.053 1.026-4.895-9.787-2.05zm14.68 3.078 9.787 2.05 1.025-4.892-9.787-2.053zm-39.623 5.522 3.547 3.523 7.049-7.094-3.547-3.523zm-10.57 10.642 3.546 3.524 7.047-7.094-3.547-3.524zM1.529 41.306l3.55 3.523 7.046-7.096-3.547-3.523Zm70.977 4.027 3.91 3.115 3.44-4.387-1.118-6.55zM.947 48.319l5.617 8.274 4.137-2.809-5.617-8.273Zm62.211 8.744 3.91 3.116 6.233-7.82-3.91-3.116zM9.373 60.73l5.62 8.272 4.134-2.809-5.617-8.271zm44.438 8.067 3.91 3.115 6.232-7.82-3.91-3.117zM17.8 73.138l5.617 8.273 4.137-2.808-5.617-8.274zm26.662 7.388 3.91 3.116 6.232-7.82-3.91-3.116zm-18.236 5.022 5.617 8.273 4.136-2.81-5.617-8.272zm8.888 6.709 3.91 3.117 6.233-7.822-3.91-3.115z"
              stroke-width="3"
              transform="translate(2.517 1.586) scale(.60827)"/>
        <path d="M22.672 20.02a3.5 3.5 0 0 0-2.506 1.034L-.514 41.872a3.5 3.5 0 0 0-.412 4.434L18 74.176a3.5 3.5 0 0 0 5.633.216l33.494-42.038a3.5 3.5 0 0 0-2.018-5.605l-31.742-6.654a3.5 3.5 0 0 0-.695-.074zm1.121 7.317 24.32 5.098-26.992 33.877L6.484 44.759Z"
              stroke-width="3"
              transform="translate(2.517 1.586) scale(.60827)"/>
        <path d="m78.734 7.668 2.61 11.396-18.145 4.154 2.705 11.816L84.05 30.88l2.609 11.396L100 21.011Z"
              stroke-width="3"
              transform="translate(1.586 1.586) scale(.60827)"/>
    </g>
</svg>
`, Uf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor" fill-rule="evenodd"
          d="M19.435 3.417c-4.478 0-8.96 1.693-12.343 5.076-6.766 6.766-6.766 17.913 0 24.679h.006c2.754 2.749 5.563 5.561 8.357 8.357 1.857 1.859 3.696 3.696 5.553 5.553l.949.949 1.892 1.898 9.496-9.49-1.898-1.898-6.502-6.502c-2.796-2.797-5.6-5.606-8.363-8.362-1.65-1.653-1.652-4.042 0-5.694 1.653-1.653 4.047-1.653 5.7 0l8.357 8.362 6.502 6.502 1.898 1.893 9.49-9.49-1.893-1.893-6.507-6.502-8.357-8.362c-3.384-3.383-7.86-5.076-12.337-5.076Zm0 2.68c3.789 0 7.577 1.432 10.439 4.294l8.357 8.362-5.694 5.694-8.357-8.362a6.7 6.7 0 0 0-9.496 0 6.697 6.697 0 0 0 0 9.49c2.76 2.755 5.566 5.564 8.363 8.362l-5.694 5.694c-2.795-2.796-5.601-5.607-8.357-8.357H8.99c-5.724-5.724-5.724-15.16 0-20.883 2.861-2.862 6.655-4.294 10.444-4.294ZM57.709 29.03a4.266 4.266 0 0 0-4.268 4.268c0 1.594.881 2.973 2.176 3.707-.714 4.997-1.424 10.107-2.176 15.037-.934 0-1.792.309-2.495.818l-7.115-5.07a4.25 4.25 0 0 0 .115-.965 4.27 4.27 0 1 0-4.268 4.268 4.23 4.23 0 0 0 2.732-1.012l6.973 4.965a4.22 4.22 0 0 0-.215 1.269 4.27 4.27 0 0 0 4.273 4.268 4.266 4.266 0 0 0 4.268-4.268 4.247 4.247 0 0 0-1.657-3.356l2.208-15.446c2.095-.273 3.722-2.045 3.722-4.215a4.27 4.27 0 0 0-4.273-4.268z"
    />
</svg>
`, Hf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <g fill="currentColor">
        <path d="m4.879 2.684-2.832 2.8L7.65 11.15l2.832-2.801Zm8.403 8.495-2.832 2.802 5.603 5.662 2.831-2.802zm8.404 8.494-2.832 2.8 5.602 5.664 2.832-2.802z"
        />
        <path d="M27.814 7.408a3.576 3.576 0 0 0-1.161-.176 3.2 3.2 0 0 0-.878.138l7.963 26.068L7.18 27.3c-.543 2.352 1.67 6.055 4.962 6.816l23.054 5.297 2.326 6.42c-2.27-.175-4.279 1.912-4.908 3.805-.535 1.698-.512 3.656.085 5.61.597 1.954 1.671 3.59 3.064 4.7 1.393 1.11 3.238 1.71 5.023 1.164 8.064-3.039 2.135-15.793.467-20.58 5.917 1.023 18.77 5.88 20.578-1.979.42-1.819-.306-3.616-1.509-4.929-1.203-1.313-2.909-2.27-4.9-2.73-1.99-.46-3.866-.547-5.602.303-1.737.849-3.768 2.642-3.468 4.73a6.17 6.17 0 0 0 .012.43l-6.563-1.794-6.88-22.632c-.702-2.297-3.445-3.99-5.108-4.523Zm26.824 26.88c1.36.315 2.472.99 3.116 1.692.644.703.795 1.307.684 1.79-.112.482-.511.956-1.399 1.305-.887.348-2.182.467-3.542.152-1.361-.314-2.472-.99-3.116-1.693-.644-.703-.797-1.304-.686-1.787.112-.482.513-.956 1.4-1.305a5.198 5.198 0 0 1 1.594-.327 6.98 6.98 0 0 1 1.949.173zM37.846 49.174c.333.069.71.25 1.13.585.746.594 1.497 1.654 1.905 2.99.408 1.335.379 2.635.092 3.545-.287.91-.731 1.34-1.205 1.484-.473.145-1.085.036-1.831-.558-.746-.594-1.496-1.655-1.904-2.99-.407-1.336-.378-2.637-.092-3.546.287-.91.732-1.342 1.206-1.486.118-.036.245-.057.38-.058.102 0 .207.011.319.034z"
        />
    </g>
</svg>
`, zf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M41.233 7.917c-5.5 0-10.519 2.077-14.328 5.482a21.443 21.443 0 0 0-4.138-.404c-11.88 0-21.544 9.664-21.544 21.544s9.664 21.544 21.544 21.544c5.5 0 10.519-2.077 14.328-5.482 1.34.263 2.722.404 4.138.404 11.88 0 21.544-9.664 21.544-21.544S53.113 7.917 41.233 7.917zm-9.969 6.791a21.61 21.61 0 0 1 5.598 3.499l-2.01 2.33a18.557 18.557 0 0 0-4.8-2.999Zm-7.927 2.765 2.557 1.714a18.558 18.558 0 0 0-2.396 5.128l-2.955-.86a21.614 21.614 0 0 1 2.794-5.982zm15.86 3.08a21.413 21.413 0 0 1 3.46 5.628l-2.839 1.188a18.357 18.357 0 0 0-2.963-4.817zm-19.334 6.142 3.053.399a18.348 18.348 0 0 0 .144 5.654l-3.027.552a21.407 21.407 0 0 1-.17-6.605Zm23.834 2.63a21.81 21.81 0 0 1 .548 3.263c.1 1.1.115 2.207.044 3.31l-3.07-.195c.12-1.888-.056-3.8-.511-5.64zm-19.918 6.172a18.37 18.37 0 0 0 2.64 5.003l-2.466 1.84a21.427 21.427 0 0 1-3.083-5.84Zm17.042 3.016 3.004.666a21.486 21.486 0 0 1-2.404 6.15l-2.66-1.547a18.434 18.434 0 0 0 2.06-5.27zm-12.535 4.124a18.554 18.554 0 0 0 4.6 3.302l-1.392 2.744a21.611 21.611 0 0 1-5.363-3.85Z"/>
</svg>
`, Jf = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
    <path fill="currentColor"
          d="M1.585 1.585V13.75h5.17v1.52H8.58v-1.52h5.17V1.585Zm3.041 3.041h6.083v6.083H4.626Zm9.429 2.13V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0V8.58h3.65V6.755Zm5.475 0v1.597a1.521 1.521 0 0 0-.325.152l-15.686 9.758a1.52 1.52 0 0 0-.199 2.437l23.512 20.553a1.52 1.52 0 0 0 2.477-.78l4.212-17.037v.352h1.825v-3.65H55.42v1.524a1.52 1.52 0 0 0-.222-.296L43.002 8.741a1.521 1.521 0 0 0-.182-.16h2.259V6.754Zm5.475 0V8.58h3.65V6.755Zm5.474 0V8.58h3.65V6.755Zm3.042 2.432v3.65h1.825v-3.65Zm-13.752 2.549 10.757 11.137-3.57 14.446-20.087-17.559Zm13.752 2.926v3.65h1.825v-3.65ZM6.755 17.096v3.65H8.58v-3.65zm0 5.475v3.65h1.628a1.52 1.52 0 0 0 1.02.909l12.683 3.406 7.905 12.694c.168.27.417.481.712.602l13.39 4.576a1.52 1.52 0 0 0 1.157-2.814l-12.936-4.389L24.35 28.42a1.52 1.52 0 0 0-.896-.664L10.19 24.193a1.52 1.52 0 0 0-1.61.557v-2.178zm48.665 3.042v3.65h1.825v-3.65ZM6.755 28.046v3.65H8.58v-3.65zm48.665 3.042v3.65h1.825v-3.65ZM6.755 33.52v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65ZM6.755 38.996v3.65H8.58v-3.65zm48.665 3.041v3.65h1.825v-3.65zm-35.382.913c-3.454 0-6.287 2.833-6.287 6.287 0 3.076 2.248 5.654 5.179 6.183h-1.225v1.825h3.65V55.42h-.206c2.712-.5 4.777-2.796 5.055-5.59l.002-.002a1.52 1.52 0 0 0 0-1.18c-.314-3.168-2.922-5.698-6.168-5.698zM6.755 44.47v3.65H8.58v-3.65zm13.283 1.521a3.223 3.223 0 0 1 3.246 3.246 3.223 3.223 0 0 1-3.246 3.246 3.223 3.223 0 0 1-3.246-3.246 3.223 3.223 0 0 1 3.246-3.246zm35.382 1.52v2.738h-5.17v12.166h12.165V50.25h-5.17v-2.737ZM6.755 49.946v3.65H8.58v-3.65zm46.536 3.346h6.083v6.083H53.29ZM6.755 55.42v1.825h3.65V55.42H7.668Zm5.475 0v1.825h3.65V55.42zm10.95 0v1.825h3.65V55.42zm5.474 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42zm5.475 0v1.825h3.65V55.42z"/>
</svg>
`, te = {
  marker: Ef,
  circle: vf,
  circle_marker: Xl,
  text_marker: Af,
  line: wf,
  rectangle: bf,
  polygon: Mf,
  freehand: If,
  custom_shape: kf,
  drag: yf,
  change: mf,
  rotate: _f,
  scale: Nf,
  copy: Cf,
  cut: Tf,
  split: Hf,
  delete: xf,
  union: zf,
  difference: Pf,
  line_simplification: Of,
  lasso: Df,
  snapping: Uf,
  pin: Bf,
  snap_guides: Sf,
  measurements: Gf,
  auto_trace: Lf,
  geofencing: Ff,
  zoom_to_features: Jf,
  click_to_edit: Rf
}, qf = [
  "mode_start",
  "mode_started",
  "mode_end",
  "mode_ended"
], Re = (t) => Object.keys(t), Xr = (t) => Object.values(t), Kt = (t, r) => r.includes(t);
function Vf(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var $n = { exports: {} }, Yf = $n.exports, ca;
function Wf() {
  return ca || (ca = 1, function(t) {
    (function(r, e) {
      t.exports ? t.exports = e() : r.log = e();
    })(Yf, function() {
      var r = function() {
      }, e = "undefined", n = typeof window !== e && typeof window.navigator !== e && /Trident\/|MSIE /.test(window.navigator.userAgent), i = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], s = {}, o = null;
      function a(A, P) {
        var C = A[P];
        if (typeof C.bind == "function")
          return C.bind(A);
        try {
          return Function.prototype.bind.call(C, A);
        } catch {
          return function() {
            return Function.prototype.apply.apply(C, [A, arguments]);
          };
        }
      }
      function u() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function l(A) {
        return A === "debug" && (A = "log"), typeof console === e ? !1 : A === "trace" && n ? u : console[A] !== void 0 ? a(console, A) : console.log !== void 0 ? a(console, "log") : r;
      }
      function c() {
        for (var A = this.getLevel(), P = 0; P < i.length; P++) {
          var C = i[P];
          this[C] = P < A ? r : this.methodFactory(C, A, this.name);
        }
        if (this.log = this.debug, typeof console === e && A < this.levels.SILENT)
          return "No console available for logging";
      }
      function h(A) {
        return function() {
          typeof console !== e && (c.call(this), this[A].apply(this, arguments));
        };
      }
      function d(A, P, C) {
        return l(A) || h.apply(this, arguments);
      }
      function v(A, P) {
        var C = this, g, D, F, G = "loglevel";
        typeof A == "string" ? G += ":" + A : typeof A == "symbol" && (G = void 0);
        function B(y) {
          var E = (i[y] || "silent").toUpperCase();
          if (!(typeof window === e || !G)) {
            try {
              window.localStorage[G] = E;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(G) + "=" + E + ";";
            } catch {
            }
          }
        }
        function H() {
          var y;
          if (!(typeof window === e || !G)) {
            try {
              y = window.localStorage[G];
            } catch {
            }
            if (typeof y === e)
              try {
                var E = window.document.cookie, S = encodeURIComponent(G), k = E.indexOf(S + "=");
                k !== -1 && (y = /^([^;]+)/.exec(
                  E.slice(k + S.length + 1)
                )[1]);
              } catch {
              }
            return C.levels[y] === void 0 && (y = void 0), y;
          }
        }
        function f() {
          if (!(typeof window === e || !G)) {
            try {
              window.localStorage.removeItem(G);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(G) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function p(y) {
          var E = y;
          if (typeof E == "string" && C.levels[E.toUpperCase()] !== void 0 && (E = C.levels[E.toUpperCase()]), typeof E == "number" && E >= 0 && E <= C.levels.SILENT)
            return E;
          throw new TypeError("log.setLevel() called with invalid level: " + y);
        }
        C.name = A, C.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, C.methodFactory = P || d, C.getLevel = function() {
          return F ?? D ?? g;
        }, C.setLevel = function(y, E) {
          return F = p(y), E !== !1 && B(F), c.call(C);
        }, C.setDefaultLevel = function(y) {
          D = p(y), H() || C.setLevel(y, !1);
        }, C.resetLevel = function() {
          F = null, f(), c.call(C);
        }, C.enableAll = function(y) {
          C.setLevel(C.levels.TRACE, y);
        }, C.disableAll = function(y) {
          C.setLevel(C.levels.SILENT, y);
        }, C.rebuild = function() {
          if (o !== C && (g = p(o.getLevel())), c.call(C), o === C)
            for (var y in s)
              s[y].rebuild();
        }, g = p(
          o ? o.getLevel() : "WARN"
        );
        var m = H();
        m != null && (F = p(m)), c.call(C);
      }
      o = new v(), o.getLogger = function(P) {
        if (typeof P != "symbol" && typeof P != "string" || P === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var C = s[P];
        return C || (C = s[P] = new v(
          P,
          o.methodFactory
        )), C;
      };
      var M = typeof window !== e ? window.log : void 0;
      return o.noConflict = function() {
        return typeof window !== e && window.log === o && (window.log = M), o;
      }, o.getLoggers = function() {
        return s;
      }, o.default = o, o;
    });
  }($n)), $n.exports;
}
var $f = Wf();
const N = /* @__PURE__ */ Vf($f);
class so {
  isMarkerInstanceAvailable() {
    return this.markerInstance ? !0 : (N.error("Marker instance is not available"), !1);
  }
}
var we = 63710088e-1, Kl = {
  centimeters: we * 100,
  centimetres: we * 100,
  degrees: 360 / (2 * Math.PI),
  feet: we * 3.28084,
  inches: we * 39.37,
  kilometers: we / 1e3,
  kilometres: we / 1e3,
  meters: we,
  metres: we,
  miles: we / 1609.344,
  millimeters: we * 1e3,
  millimetres: we * 1e3,
  nauticalmiles: we / 1852,
  radians: 1,
  yards: we * 1.0936
};
function dt(t, r, e = {}) {
  const n = { type: "Feature" };
  return (e.id === 0 || e.id) && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.properties = r || {}, n.geometry = t, n;
}
function Rt(t, r, e = {}) {
  if (!t)
    throw new Error("coordinates is required");
  if (!Array.isArray(t))
    throw new Error("coordinates must be an Array");
  if (t.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!fa(t[0]) || !fa(t[1]))
    throw new Error("coordinates must contain numbers");
  return dt({
    type: "Point",
    coordinates: t
  }, r, e);
}
function er(t, r, e = {}) {
  for (const i of t) {
    if (i.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (i[i.length - 1].length !== i[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let s = 0; s < i[i.length - 1].length; s++)
      if (i[i.length - 1][s] !== i[0][s])
        throw new Error("First and last Position are not equivalent.");
  }
  return dt({
    type: "Polygon",
    coordinates: t
  }, r, e);
}
function un(t, r, e = {}) {
  if (t.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return dt({
    type: "LineString",
    coordinates: t
  }, r, e);
}
function Me(t, r = {}) {
  const e = { type: "FeatureCollection" };
  return r.id && (e.id = r.id), r.bbox && (e.bbox = r.bbox), e.features = t, e;
}
function jf(t, r, e = {}) {
  return dt({
    type: "MultiLineString",
    coordinates: t
  }, r, e);
}
function Ql(t, r, e = {}) {
  return dt({
    type: "MultiPolygon",
    coordinates: t
  }, r, e);
}
function eu(t, r = "kilometers") {
  const e = Kl[r];
  if (!e)
    throw new Error(r + " units is invalid");
  return t * e;
}
function tu(t, r = "kilometers") {
  const e = Kl[r];
  if (!e)
    throw new Error(r + " units is invalid");
  return t / e;
}
function Ar(t) {
  return t % (2 * Math.PI) * 180 / Math.PI;
}
function me(t) {
  return t % 360 * Math.PI / 180;
}
function ru(t, r = "kilometers", e = "kilometers") {
  if (!(t >= 0))
    throw new Error("length must be a positive number");
  return eu(tu(t, r), e);
}
function fa(t) {
  return !isNaN(t) && t !== null && !Array.isArray(t);
}
function oo(t) {
  return t !== null && typeof t == "object" && !Array.isArray(t);
}
function Yt(t, r, e) {
  if (t !== null)
    for (var n, i, s, o, a, u, l, c = 0, h = 0, d, v = t.type, M = v === "FeatureCollection", A = v === "Feature", P = M ? t.features.length : 1, C = 0; C < P; C++) {
      l = M ? t.features[C].geometry : A ? t.geometry : t, d = l ? l.type === "GeometryCollection" : !1, a = d ? l.geometries.length : 1;
      for (var g = 0; g < a; g++) {
        var D = 0, F = 0;
        if (o = d ? l.geometries[g] : l, o !== null) {
          u = o.coordinates;
          var G = o.type;
          switch (c = e && (G === "Polygon" || G === "MultiPolygon") ? 1 : 0, G) {
            case null:
              break;
            case "Point":
              if (r(
                u,
                h,
                C,
                D,
                F
              ) === !1)
                return !1;
              h++, D++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (r(
                  u[n],
                  h,
                  C,
                  D,
                  F
                ) === !1)
                  return !1;
                h++, G === "MultiPoint" && D++;
              }
              G === "LineString" && D++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - c; i++) {
                  if (r(
                    u[n][i],
                    h,
                    C,
                    D,
                    F
                  ) === !1)
                    return !1;
                  h++;
                }
                G === "MultiLineString" && D++, G === "Polygon" && F++;
              }
              G === "Polygon" && D++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (F = 0, i = 0; i < u[n].length; i++) {
                  for (s = 0; s < u[n][i].length - c; s++) {
                    if (r(
                      u[n][i][s],
                      h,
                      C,
                      D,
                      F
                    ) === !1)
                      return !1;
                    h++;
                  }
                  F++;
                }
                D++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (Yt(o.geometries[n], r, e) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Ut(t, r) {
  if (t.type === "Feature")
    r(t, 0);
  else if (t.type === "FeatureCollection")
    for (var e = 0; e < t.features.length && r(t.features[e], e) !== !1; e++)
      ;
}
function Zf(t, r, e) {
  var n = e;
  return Ut(t, function(i, s) {
    s === 0 && e === void 0 ? n = i : n = r(n, i, s);
  }), n;
}
function yn(t, r) {
  var e, n, i, s, o, a, u, l, c, h, d = 0, v = t.type === "FeatureCollection", M = t.type === "Feature", A = v ? t.features.length : 1;
  for (e = 0; e < A; e++) {
    for (a = v ? t.features[e].geometry : M ? t.geometry : t, l = v ? t.features[e].properties : M ? t.properties : {}, c = v ? t.features[e].bbox : M ? t.bbox : void 0, h = v ? t.features[e].id : M ? t.id : void 0, u = a ? a.type === "GeometryCollection" : !1, o = u ? a.geometries.length : 1, i = 0; i < o; i++) {
      if (s = u ? a.geometries[i] : a, s === null) {
        if (r(
          null,
          d,
          l,
          c,
          h
        ) === !1)
          return !1;
        continue;
      }
      switch (s.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (r(
            s,
            d,
            l,
            c,
            h
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < s.geometries.length; n++)
            if (r(
              s.geometries[n],
              d,
              l,
              c,
              h
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    d++;
  }
}
function Xf(t, r, e) {
  var n = e;
  return yn(
    t,
    function(i, s, o, a, u) {
      n = r(
        n,
        i,
        s,
        o,
        a,
        u
      );
    }
  ), n;
}
function Ht(t, r) {
  yn(t, function(e, n, i, s, o) {
    var a = e === null ? null : e.type;
    switch (a) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return r(
          dt(e, i, { bbox: s, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (a) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var l = 0; l < e.coordinates.length; l++) {
      var c = e.coordinates[l], h = {
        type: u,
        coordinates: c
      };
      if (r(dt(h, i), n, l) === !1)
        return !1;
    }
  });
}
function bt(t, r = {}) {
  if (t.bbox != null && r.recompute !== !0)
    return t.bbox;
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return Yt(t, (n) => {
    e[0] > n[0] && (e[0] = n[0]), e[1] > n[1] && (e[1] = n[1]), e[2] < n[0] && (e[2] = n[0]), e[3] < n[1] && (e[3] = n[1]);
  }), e;
}
var nu = bt;
function he(t) {
  if (!t)
    throw new Error("coord is required");
  if (!Array.isArray(t)) {
    if (t.type === "Feature" && t.geometry !== null && t.geometry.type === "Point")
      return [...t.geometry.coordinates];
    if (t.type === "Point")
      return [...t.coordinates];
  }
  if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1]))
    return [...t];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function He(t) {
  if (Array.isArray(t))
    return t;
  if (t.type === "Feature") {
    if (t.geometry !== null)
      return t.geometry.coordinates;
  } else if (t.coordinates)
    return t.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function wn(t) {
  return t.type === "Feature" ? t.geometry : t;
}
function ha(t, r) {
  return t.type === "FeatureCollection" ? "FeatureCollection" : t.type === "GeometryCollection" ? "GeometryCollection" : t.type === "Feature" && t.geometry !== null ? t.geometry.type : t.type;
}
function Kf(t, r, e, n = {}) {
  const i = he(t), s = me(i[0]), o = me(i[1]), a = me(e), u = tu(r, n.units), l = Math.asin(
    Math.sin(o) * Math.cos(u) + Math.cos(o) * Math.sin(u) * Math.cos(a)
  ), c = s + Math.atan2(
    Math.sin(a) * Math.sin(u) * Math.cos(o),
    Math.cos(u) - Math.sin(o) * Math.sin(l)
  ), h = Ar(c), d = Ar(l);
  return Rt([h, d], n.properties);
}
function Qf(t, r, e = {}) {
  const n = e.steps || 64, i = e.properties ? e.properties : !Array.isArray(t) && t.type === "Feature" && t.properties ? t.properties : {}, s = [];
  for (let o = 0; o < n; o++)
    s.push(
      Kf(t, r, o * -360 / n, e).geometry.coordinates
    );
  return s.push(s[0]), er([s], i);
}
var eh = Qf;
function lt(t, r, e = {}) {
  var n = he(t), i = he(r), s = me(i[1] - n[1]), o = me(i[0] - n[0]), a = me(n[1]), u = me(i[1]), l = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(a) * Math.cos(u);
  return eu(
    2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)),
    e.units
  );
}
var th = lt;
function _s(t, r = {}) {
  const e = wn(t);
  switch (!r.properties && t.type === "Feature" && (r.properties = t.properties), e.type) {
    case "Polygon":
      return rh(e, r);
    case "MultiPolygon":
      return nh(e, r);
    default:
      throw new Error("invalid poly");
  }
}
function rh(t, r = {}) {
  const n = wn(t).coordinates, i = r.properties ? r.properties : t.type === "Feature" ? t.properties : {};
  return iu(n, i);
}
function nh(t, r = {}) {
  const n = wn(t).coordinates, i = r.properties ? r.properties : t.type === "Feature" ? t.properties : {}, s = [];
  return n.forEach((o) => {
    s.push(iu(o, i));
  }), Me(s);
}
function iu(t, r) {
  return t.length > 1 ? jf(t, r) : un(t[0], r);
}
var su = typeof global == "object" && global && global.Object === Object && global, ih = typeof self == "object" && self && self.Object === Object && self, nt = su || ih || Function("return this")(), $e = nt.Symbol, ou = Object.prototype, sh = ou.hasOwnProperty, oh = ou.toString, zr = $e ? $e.toStringTag : void 0;
function ah(t) {
  var r = sh.call(t, zr), e = t[zr];
  try {
    t[zr] = void 0;
    var n = !0;
  } catch {
  }
  var i = oh.call(t);
  return n && (r ? t[zr] = e : delete t[zr]), i;
}
var lh = Object.prototype, uh = lh.toString;
function ch(t) {
  return uh.call(t);
}
var fh = "[object Null]", hh = "[object Undefined]", da = $e ? $e.toStringTag : void 0;
function ir(t) {
  return t == null ? t === void 0 ? hh : fh : da && da in Object(t) ? ah(t) : ch(t);
}
function pt(t) {
  return t != null && typeof t == "object";
}
var dh = "[object Symbol]";
function Lr(t) {
  return typeof t == "symbol" || pt(t) && ir(t) == dh;
}
function Mr(t, r) {
  for (var e = -1, n = t == null ? 0 : t.length, i = Array(n); ++e < n; )
    i[e] = r(t[e], e, t);
  return i;
}
var ke = Array.isArray, pa = $e ? $e.prototype : void 0, ga = pa ? pa.toString : void 0;
function au(t) {
  if (typeof t == "string")
    return t;
  if (ke(t))
    return Mr(t, au) + "";
  if (Lr(t))
    return ga ? ga.call(t) : "";
  var r = t + "";
  return r == "0" && 1 / t == -1 / 0 ? "-0" : r;
}
var ph = /\s/;
function gh(t) {
  for (var r = t.length; r-- && ph.test(t.charAt(r)); )
    ;
  return r;
}
var mh = /^\s+/;
function vh(t) {
  return t && t.slice(0, gh(t) + 1).replace(mh, "");
}
function ze(t) {
  var r = typeof t;
  return t != null && (r == "object" || r == "function");
}
var ma = NaN, yh = /^[-+]0x[0-9a-f]+$/i, wh = /^0b[01]+$/i, Eh = /^0o[0-7]+$/i, Mh = parseInt;
function va(t) {
  if (typeof t == "number")
    return t;
  if (Lr(t))
    return ma;
  if (ze(t)) {
    var r = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = ze(r) ? r + "" : r;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = vh(t);
  var e = wh.test(t);
  return e || Eh.test(t) ? Mh(t.slice(2), e ? 2 : 8) : yh.test(t) ? ma : +t;
}
function _i(t) {
  return t;
}
var bh = "[object AsyncFunction]", xh = "[object Function]", _h = "[object GeneratorFunction]", Sh = "[object Proxy]";
function ao(t) {
  if (!ze(t))
    return !1;
  var r = ir(t);
  return r == xh || r == _h || r == bh || r == Sh;
}
var Ki = nt["__core-js_shared__"], ya = function() {
  var t = /[^.]+$/.exec(Ki && Ki.keys && Ki.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function Ah(t) {
  return !!ya && ya in t;
}
var Lh = Function.prototype, Ch = Lh.toString;
function sr(t) {
  if (t != null) {
    try {
      return Ch.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var kh = /[\\^$.*+?()[\]{}|]/g, Th = /^\[object .+?Constructor\]$/, Ph = Function.prototype, Ih = Object.prototype, Fh = Ph.toString, Dh = Ih.hasOwnProperty, Oh = RegExp(
  "^" + Fh.call(Dh).replace(kh, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Gh(t) {
  if (!ze(t) || Ah(t))
    return !1;
  var r = ao(t) ? Oh : Th;
  return r.test(sr(t));
}
function Rh(t, r) {
  return t == null ? void 0 : t[r];
}
function or(t, r) {
  var e = Rh(t, r);
  return Gh(e) ? e : void 0;
}
var Ss = or(nt, "WeakMap"), wa = Object.create, Bh = /* @__PURE__ */ function() {
  function t() {
  }
  return function(r) {
    if (!ze(r))
      return {};
    if (wa)
      return wa(r);
    t.prototype = r;
    var e = new t();
    return t.prototype = void 0, e;
  };
}();
function Nh(t, r, e) {
  switch (e.length) {
    case 0:
      return t.call(r);
    case 1:
      return t.call(r, e[0]);
    case 2:
      return t.call(r, e[0], e[1]);
    case 3:
      return t.call(r, e[0], e[1], e[2]);
  }
  return t.apply(r, e);
}
function Uh() {
}
function Hh(t, r) {
  var e = -1, n = t.length;
  for (r || (r = Array(n)); ++e < n; )
    r[e] = t[e];
  return r;
}
var zh = 800, Jh = 16, qh = Date.now;
function Vh(t) {
  var r = 0, e = 0;
  return function() {
    var n = qh(), i = Jh - (n - e);
    if (e = n, i > 0) {
      if (++r >= zh)
        return arguments[0];
    } else
      r = 0;
    return t.apply(void 0, arguments);
  };
}
function Yh(t) {
  return function() {
    return t;
  };
}
var si = function() {
  try {
    var t = or(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), Wh = si ? function(t, r) {
  return si(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Yh(r),
    writable: !0
  });
} : _i, $h = Vh(Wh);
function jh(t, r) {
  for (var e = -1, n = t == null ? 0 : t.length; ++e < n && r(t[e], e, t) !== !1; )
    ;
  return t;
}
function Zh(t, r, e, n) {
  for (var i = t.length, s = e + -1; ++s < i; )
    if (r(t[s], s, t))
      return s;
  return -1;
}
function Xh(t) {
  return t !== t;
}
function Kh(t, r, e) {
  for (var n = e - 1, i = t.length; ++n < i; )
    if (t[n] === r)
      return n;
  return -1;
}
function Qh(t, r, e) {
  return r === r ? Kh(t, r, e) : Zh(t, Xh, e);
}
function lu(t, r) {
  var e = t == null ? 0 : t.length;
  return !!e && Qh(t, r, 0) > -1;
}
var ed = 9007199254740991, td = /^(?:0|[1-9]\d*)$/;
function lo(t, r) {
  var e = typeof t;
  return r = r ?? ed, !!r && (e == "number" || e != "symbol" && td.test(t)) && t > -1 && t % 1 == 0 && t < r;
}
function Si(t, r, e) {
  r == "__proto__" && si ? si(t, r, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : t[r] = e;
}
function En(t, r) {
  return t === r || t !== t && r !== r;
}
var rd = Object.prototype, nd = rd.hasOwnProperty;
function uu(t, r, e) {
  var n = t[r];
  (!(nd.call(t, r) && En(n, e)) || e === void 0 && !(r in t)) && Si(t, r, e);
}
function id(t, r, e, n) {
  var i = !e;
  e || (e = {});
  for (var s = -1, o = r.length; ++s < o; ) {
    var a = r[s], u = void 0;
    u === void 0 && (u = t[a]), i ? Si(e, a, u) : uu(e, a, u);
  }
  return e;
}
var Ea = Math.max;
function sd(t, r, e) {
  return r = Ea(r === void 0 ? t.length - 1 : r, 0), function() {
    for (var n = arguments, i = -1, s = Ea(n.length - r, 0), o = Array(s); ++i < s; )
      o[i] = n[r + i];
    i = -1;
    for (var a = Array(r + 1); ++i < r; )
      a[i] = n[i];
    return a[r] = e(o), Nh(t, this, a);
  };
}
function uo(t, r) {
  return $h(sd(t, r, _i), t + "");
}
var od = 9007199254740991;
function co(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= od;
}
function Ir(t) {
  return t != null && co(t.length) && !ao(t);
}
function As(t, r, e) {
  if (!ze(e))
    return !1;
  var n = typeof r;
  return (n == "number" ? Ir(e) && lo(r, e.length) : n == "string" && r in e) ? En(e[r], t) : !1;
}
function cu(t) {
  return uo(function(r, e) {
    var n = -1, i = e.length, s = i > 1 ? e[i - 1] : void 0, o = i > 2 ? e[2] : void 0;
    for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && As(e[0], e[1], o) && (s = i < 3 ? void 0 : s, i = 1), r = Object(r); ++n < i; ) {
      var a = e[n];
      a && t(r, a, n, s);
    }
    return r;
  });
}
var ad = Object.prototype;
function fo(t) {
  var r = t && t.constructor, e = typeof r == "function" && r.prototype || ad;
  return t === e;
}
function ld(t, r) {
  for (var e = -1, n = Array(t); ++e < t; )
    n[e] = r(e);
  return n;
}
var ud = "[object Arguments]";
function Ma(t) {
  return pt(t) && ir(t) == ud;
}
var fu = Object.prototype, cd = fu.hasOwnProperty, fd = fu.propertyIsEnumerable, cn = Ma(/* @__PURE__ */ function() {
  return arguments;
}()) ? Ma : function(t) {
  return pt(t) && cd.call(t, "callee") && !fd.call(t, "callee");
};
function hd() {
  return !1;
}
var hu = typeof exports == "object" && exports && !exports.nodeType && exports, ba = hu && typeof module == "object" && module && !module.nodeType && module, dd = ba && ba.exports === hu, xa = dd ? nt.Buffer : void 0, pd = xa ? xa.isBuffer : void 0, fn = pd || hd, gd = "[object Arguments]", md = "[object Array]", vd = "[object Boolean]", yd = "[object Date]", wd = "[object Error]", Ed = "[object Function]", Md = "[object Map]", bd = "[object Number]", xd = "[object Object]", _d = "[object RegExp]", Sd = "[object Set]", Ad = "[object String]", Ld = "[object WeakMap]", Cd = "[object ArrayBuffer]", kd = "[object DataView]", Td = "[object Float32Array]", Pd = "[object Float64Array]", Id = "[object Int8Array]", Fd = "[object Int16Array]", Dd = "[object Int32Array]", Od = "[object Uint8Array]", Gd = "[object Uint8ClampedArray]", Rd = "[object Uint16Array]", Bd = "[object Uint32Array]", le = {};
le[Td] = le[Pd] = le[Id] = le[Fd] = le[Dd] = le[Od] = le[Gd] = le[Rd] = le[Bd] = !0;
le[gd] = le[md] = le[Cd] = le[vd] = le[kd] = le[yd] = le[wd] = le[Ed] = le[Md] = le[bd] = le[xd] = le[_d] = le[Sd] = le[Ad] = le[Ld] = !1;
function Nd(t) {
  return pt(t) && co(t.length) && !!le[ir(t)];
}
function Ai(t) {
  return function(r) {
    return t(r);
  };
}
var du = typeof exports == "object" && exports && !exports.nodeType && exports, sn = du && typeof module == "object" && module && !module.nodeType && module, Ud = sn && sn.exports === du, Qi = Ud && su.process, Cr = function() {
  try {
    var t = sn && sn.require && sn.require("util").types;
    return t || Qi && Qi.binding && Qi.binding("util");
  } catch {
  }
}(), _a = Cr && Cr.isTypedArray, ho = _a ? Ai(_a) : Nd, Hd = Object.prototype, zd = Hd.hasOwnProperty;
function pu(t, r) {
  var e = ke(t), n = !e && cn(t), i = !e && !n && fn(t), s = !e && !n && !i && ho(t), o = e || n || i || s, a = o ? ld(t.length, String) : [], u = a.length;
  for (var l in t)
    (r || zd.call(t, l)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (l == "offset" || l == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (l == "buffer" || l == "byteLength" || l == "byteOffset") || // Skip index properties.
    lo(l, u))) && a.push(l);
  return a;
}
function gu(t, r) {
  return function(e) {
    return t(r(e));
  };
}
var Jd = gu(Object.keys, Object), qd = Object.prototype, Vd = qd.hasOwnProperty;
function Yd(t) {
  if (!fo(t))
    return Jd(t);
  var r = [];
  for (var e in Object(t))
    Vd.call(t, e) && e != "constructor" && r.push(e);
  return r;
}
function Li(t) {
  return Ir(t) ? pu(t) : Yd(t);
}
function Wd(t) {
  var r = [];
  if (t != null)
    for (var e in Object(t))
      r.push(e);
  return r;
}
var $d = Object.prototype, jd = $d.hasOwnProperty;
function Zd(t) {
  if (!ze(t))
    return Wd(t);
  var r = fo(t), e = [];
  for (var n in t)
    n == "constructor" && (r || !jd.call(t, n)) || e.push(n);
  return e;
}
function mu(t) {
  return Ir(t) ? pu(t, !0) : Zd(t);
}
var Xd = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Kd = /^\w*$/;
function po(t, r) {
  if (ke(t))
    return !1;
  var e = typeof t;
  return e == "number" || e == "symbol" || e == "boolean" || t == null || Lr(t) ? !0 : Kd.test(t) || !Xd.test(t) || r != null && t in Object(r);
}
var hn = or(Object, "create");
function Qd() {
  this.__data__ = hn ? hn(null) : {}, this.size = 0;
}
function ep(t) {
  var r = this.has(t) && delete this.__data__[t];
  return this.size -= r ? 1 : 0, r;
}
var tp = "__lodash_hash_undefined__", rp = Object.prototype, np = rp.hasOwnProperty;
function ip(t) {
  var r = this.__data__;
  if (hn) {
    var e = r[t];
    return e === tp ? void 0 : e;
  }
  return np.call(r, t) ? r[t] : void 0;
}
var sp = Object.prototype, op = sp.hasOwnProperty;
function ap(t) {
  var r = this.__data__;
  return hn ? r[t] !== void 0 : op.call(r, t);
}
var lp = "__lodash_hash_undefined__";
function up(t, r) {
  var e = this.__data__;
  return this.size += this.has(t) ? 0 : 1, e[t] = hn && r === void 0 ? lp : r, this;
}
function tr(t) {
  var r = -1, e = t == null ? 0 : t.length;
  for (this.clear(); ++r < e; ) {
    var n = t[r];
    this.set(n[0], n[1]);
  }
}
tr.prototype.clear = Qd;
tr.prototype.delete = ep;
tr.prototype.get = ip;
tr.prototype.has = ap;
tr.prototype.set = up;
function cp() {
  this.__data__ = [], this.size = 0;
}
function Ci(t, r) {
  for (var e = t.length; e--; )
    if (En(t[e][0], r))
      return e;
  return -1;
}
var fp = Array.prototype, hp = fp.splice;
function dp(t) {
  var r = this.__data__, e = Ci(r, t);
  if (e < 0)
    return !1;
  var n = r.length - 1;
  return e == n ? r.pop() : hp.call(r, e, 1), --this.size, !0;
}
function pp(t) {
  var r = this.__data__, e = Ci(r, t);
  return e < 0 ? void 0 : r[e][1];
}
function gp(t) {
  return Ci(this.__data__, t) > -1;
}
function mp(t, r) {
  var e = this.__data__, n = Ci(e, t);
  return n < 0 ? (++this.size, e.push([t, r])) : e[n][1] = r, this;
}
function kt(t) {
  var r = -1, e = t == null ? 0 : t.length;
  for (this.clear(); ++r < e; ) {
    var n = t[r];
    this.set(n[0], n[1]);
  }
}
kt.prototype.clear = cp;
kt.prototype.delete = dp;
kt.prototype.get = pp;
kt.prototype.has = gp;
kt.prototype.set = mp;
var dn = or(nt, "Map");
function vp() {
  this.size = 0, this.__data__ = {
    hash: new tr(),
    map: new (dn || kt)(),
    string: new tr()
  };
}
function yp(t) {
  var r = typeof t;
  return r == "string" || r == "number" || r == "symbol" || r == "boolean" ? t !== "__proto__" : t === null;
}
function ki(t, r) {
  var e = t.__data__;
  return yp(r) ? e[typeof r == "string" ? "string" : "hash"] : e.map;
}
function wp(t) {
  var r = ki(this, t).delete(t);
  return this.size -= r ? 1 : 0, r;
}
function Ep(t) {
  return ki(this, t).get(t);
}
function Mp(t) {
  return ki(this, t).has(t);
}
function bp(t, r) {
  var e = ki(this, t), n = e.size;
  return e.set(t, r), this.size += e.size == n ? 0 : 1, this;
}
function Tt(t) {
  var r = -1, e = t == null ? 0 : t.length;
  for (this.clear(); ++r < e; ) {
    var n = t[r];
    this.set(n[0], n[1]);
  }
}
Tt.prototype.clear = vp;
Tt.prototype.delete = wp;
Tt.prototype.get = Ep;
Tt.prototype.has = Mp;
Tt.prototype.set = bp;
var xp = "Expected a function";
function go(t, r) {
  if (typeof t != "function" || r != null && typeof r != "function")
    throw new TypeError(xp);
  var e = function() {
    var n = arguments, i = r ? r.apply(this, n) : n[0], s = e.cache;
    if (s.has(i))
      return s.get(i);
    var o = t.apply(this, n);
    return e.cache = s.set(i, o) || s, o;
  };
  return e.cache = new (go.Cache || Tt)(), e;
}
go.Cache = Tt;
var _p = 500;
function Sp(t) {
  var r = go(t, function(n) {
    return e.size === _p && e.clear(), n;
  }), e = r.cache;
  return r;
}
var Ap = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Lp = /\\(\\)?/g, Cp = Sp(function(t) {
  var r = [];
  return t.charCodeAt(0) === 46 && r.push(""), t.replace(Ap, function(e, n, i, s) {
    r.push(i ? s.replace(Lp, "$1") : n || e);
  }), r;
});
function kp(t) {
  return t == null ? "" : au(t);
}
function vu(t, r) {
  return ke(t) ? t : po(t, r) ? [t] : Cp(kp(t));
}
function Ti(t) {
  if (typeof t == "string" || Lr(t))
    return t;
  var r = t + "";
  return r == "0" && 1 / t == -1 / 0 ? "-0" : r;
}
function mo(t, r) {
  r = vu(r, t);
  for (var e = 0, n = r.length; t != null && e < n; )
    t = t[Ti(r[e++])];
  return e && e == n ? t : void 0;
}
function rr(t, r, e) {
  var n = t == null ? void 0 : mo(t, r);
  return n === void 0 ? e : n;
}
function yu(t, r) {
  for (var e = -1, n = r.length, i = t.length; ++e < n; )
    t[i + e] = r[e];
  return t;
}
var Sa = $e ? $e.isConcatSpreadable : void 0;
function Tp(t) {
  return ke(t) || cn(t) || !!(Sa && t && t[Sa]);
}
function Pp(t, r, e, n, i) {
  var s = -1, o = t.length;
  for (e || (e = Tp), i || (i = []); ++s < o; ) {
    var a = t[s];
    e(a) ? yu(i, a) : i[i.length] = a;
  }
  return i;
}
var wu = gu(Object.getPrototypeOf, Object), Ip = "[object Object]", Fp = Function.prototype, Dp = Object.prototype, Eu = Fp.toString, Op = Dp.hasOwnProperty, Gp = Eu.call(Object);
function Rp(t) {
  if (!pt(t) || ir(t) != Ip)
    return !1;
  var r = wu(t);
  if (r === null)
    return !0;
  var e = Op.call(r, "constructor") && r.constructor;
  return typeof e == "function" && e instanceof e && Eu.call(e) == Gp;
}
function Bp() {
  this.__data__ = new kt(), this.size = 0;
}
function Np(t) {
  var r = this.__data__, e = r.delete(t);
  return this.size = r.size, e;
}
function Up(t) {
  return this.__data__.get(t);
}
function Hp(t) {
  return this.__data__.has(t);
}
var zp = 200;
function Jp(t, r) {
  var e = this.__data__;
  if (e instanceof kt) {
    var n = e.__data__;
    if (!dn || n.length < zp - 1)
      return n.push([t, r]), this.size = ++e.size, this;
    e = this.__data__ = new Tt(n);
  }
  return e.set(t, r), this.size = e.size, this;
}
function tt(t) {
  var r = this.__data__ = new kt(t);
  this.size = r.size;
}
tt.prototype.clear = Bp;
tt.prototype.delete = Np;
tt.prototype.get = Up;
tt.prototype.has = Hp;
tt.prototype.set = Jp;
var Mu = typeof exports == "object" && exports && !exports.nodeType && exports, Aa = Mu && typeof module == "object" && module && !module.nodeType && module, qp = Aa && Aa.exports === Mu, La = qp ? nt.Buffer : void 0, Ca = La ? La.allocUnsafe : void 0;
function bu(t, r) {
  if (r)
    return t.slice();
  var e = t.length, n = Ca ? Ca(e) : new t.constructor(e);
  return t.copy(n), n;
}
function Vp(t, r) {
  for (var e = -1, n = t == null ? 0 : t.length, i = 0, s = []; ++e < n; ) {
    var o = t[e];
    r(o, e, t) && (s[i++] = o);
  }
  return s;
}
function Yp() {
  return [];
}
var Wp = Object.prototype, $p = Wp.propertyIsEnumerable, ka = Object.getOwnPropertySymbols, jp = ka ? function(t) {
  return t == null ? [] : (t = Object(t), Vp(ka(t), function(r) {
    return $p.call(t, r);
  }));
} : Yp;
function Zp(t, r, e) {
  var n = r(t);
  return ke(t) ? n : yu(n, e(t));
}
function Ls(t) {
  return Zp(t, Li, jp);
}
var Cs = or(nt, "DataView"), ks = or(nt, "Promise"), br = or(nt, "Set"), Ta = "[object Map]", Xp = "[object Object]", Pa = "[object Promise]", Ia = "[object Set]", Fa = "[object WeakMap]", Da = "[object DataView]", Kp = sr(Cs), Qp = sr(dn), eg = sr(ks), tg = sr(br), rg = sr(Ss), Qe = ir;
(Cs && Qe(new Cs(new ArrayBuffer(1))) != Da || dn && Qe(new dn()) != Ta || ks && Qe(ks.resolve()) != Pa || br && Qe(new br()) != Ia || Ss && Qe(new Ss()) != Fa) && (Qe = function(t) {
  var r = ir(t), e = r == Xp ? t.constructor : void 0, n = e ? sr(e) : "";
  if (n)
    switch (n) {
      case Kp:
        return Da;
      case Qp:
        return Ta;
      case eg:
        return Pa;
      case tg:
        return Ia;
      case rg:
        return Fa;
    }
  return r;
});
var ng = Object.prototype, ig = ng.hasOwnProperty;
function sg(t) {
  var r = t.length, e = new t.constructor(r);
  return r && typeof t[0] == "string" && ig.call(t, "index") && (e.index = t.index, e.input = t.input), e;
}
var oi = nt.Uint8Array;
function vo(t) {
  var r = new t.constructor(t.byteLength);
  return new oi(r).set(new oi(t)), r;
}
function og(t, r) {
  var e = vo(t.buffer);
  return new t.constructor(e, t.byteOffset, t.byteLength);
}
var ag = /\w*$/;
function lg(t) {
  var r = new t.constructor(t.source, ag.exec(t));
  return r.lastIndex = t.lastIndex, r;
}
var Oa = $e ? $e.prototype : void 0, Ga = Oa ? Oa.valueOf : void 0;
function ug(t) {
  return Ga ? Object(Ga.call(t)) : {};
}
function xu(t, r) {
  var e = r ? vo(t.buffer) : t.buffer;
  return new t.constructor(e, t.byteOffset, t.length);
}
var cg = "[object Boolean]", fg = "[object Date]", hg = "[object Map]", dg = "[object Number]", pg = "[object RegExp]", gg = "[object Set]", mg = "[object String]", vg = "[object Symbol]", yg = "[object ArrayBuffer]", wg = "[object DataView]", Eg = "[object Float32Array]", Mg = "[object Float64Array]", bg = "[object Int8Array]", xg = "[object Int16Array]", _g = "[object Int32Array]", Sg = "[object Uint8Array]", Ag = "[object Uint8ClampedArray]", Lg = "[object Uint16Array]", Cg = "[object Uint32Array]";
function kg(t, r, e) {
  var n = t.constructor;
  switch (r) {
    case yg:
      return vo(t);
    case cg:
    case fg:
      return new n(+t);
    case wg:
      return og(t);
    case Eg:
    case Mg:
    case bg:
    case xg:
    case _g:
    case Sg:
    case Ag:
    case Lg:
    case Cg:
      return xu(t, e);
    case hg:
      return new n();
    case dg:
    case mg:
      return new n(t);
    case pg:
      return lg(t);
    case gg:
      return new n();
    case vg:
      return ug(t);
  }
}
function _u(t) {
  return typeof t.constructor == "function" && !fo(t) ? Bh(wu(t)) : {};
}
var Tg = "[object Map]";
function Pg(t) {
  return pt(t) && Qe(t) == Tg;
}
var Ra = Cr && Cr.isMap, Ig = Ra ? Ai(Ra) : Pg, Fg = "[object Set]";
function Dg(t) {
  return pt(t) && Qe(t) == Fg;
}
var Ba = Cr && Cr.isSet, Og = Ba ? Ai(Ba) : Dg, Gg = 1, Su = "[object Arguments]", Rg = "[object Array]", Bg = "[object Boolean]", Ng = "[object Date]", Ug = "[object Error]", Au = "[object Function]", Hg = "[object GeneratorFunction]", zg = "[object Map]", Jg = "[object Number]", Lu = "[object Object]", qg = "[object RegExp]", Vg = "[object Set]", Yg = "[object String]", Wg = "[object Symbol]", $g = "[object WeakMap]", jg = "[object ArrayBuffer]", Zg = "[object DataView]", Xg = "[object Float32Array]", Kg = "[object Float64Array]", Qg = "[object Int8Array]", e0 = "[object Int16Array]", t0 = "[object Int32Array]", r0 = "[object Uint8Array]", n0 = "[object Uint8ClampedArray]", i0 = "[object Uint16Array]", s0 = "[object Uint32Array]", oe = {};
oe[Su] = oe[Rg] = oe[jg] = oe[Zg] = oe[Bg] = oe[Ng] = oe[Xg] = oe[Kg] = oe[Qg] = oe[e0] = oe[t0] = oe[zg] = oe[Jg] = oe[Lu] = oe[qg] = oe[Vg] = oe[Yg] = oe[Wg] = oe[r0] = oe[n0] = oe[i0] = oe[s0] = !0;
oe[Ug] = oe[Au] = oe[$g] = !1;
function jn(t, r, e, n, i, s) {
  var o, a = r & Gg;
  if (o !== void 0)
    return o;
  if (!ze(t))
    return t;
  var u = ke(t);
  if (u)
    o = sg(t);
  else {
    var l = Qe(t), c = l == Au || l == Hg;
    if (fn(t))
      return bu(t, a);
    if (l == Lu || l == Su || c && !i)
      o = c ? {} : _u(t);
    else {
      if (!oe[l])
        return i ? t : {};
      o = kg(t, l, a);
    }
  }
  s || (s = new tt());
  var h = s.get(t);
  if (h)
    return h;
  s.set(t, o), Og(t) ? t.forEach(function(M) {
    o.add(jn(M, r, e, M, t, s));
  }) : Ig(t) && t.forEach(function(M, A) {
    o.set(A, jn(M, r, e, A, t, s));
  });
  var d = Ls, v = u ? void 0 : d(t);
  return jh(v || t, function(M, A) {
    v && (A = M, M = t[A]), uu(o, A, jn(M, r, e, A, t, s));
  }), o;
}
var o0 = 1, a0 = 4;
function je(t) {
  return jn(t, o0 | a0);
}
var l0 = "__lodash_hash_undefined__";
function u0(t) {
  return this.__data__.set(t, l0), this;
}
function c0(t) {
  return this.__data__.has(t);
}
function kr(t) {
  var r = -1, e = t == null ? 0 : t.length;
  for (this.__data__ = new Tt(); ++r < e; )
    this.add(t[r]);
}
kr.prototype.add = kr.prototype.push = u0;
kr.prototype.has = c0;
function f0(t, r) {
  for (var e = -1, n = t == null ? 0 : t.length; ++e < n; )
    if (r(t[e], e, t))
      return !0;
  return !1;
}
function ai(t, r) {
  return t.has(r);
}
var h0 = 1, d0 = 2;
function Cu(t, r, e, n, i, s) {
  var o = e & h0, a = t.length, u = r.length;
  if (a != u && !(o && u > a))
    return !1;
  var l = s.get(t), c = s.get(r);
  if (l && c)
    return l == r && c == t;
  var h = -1, d = !0, v = e & d0 ? new kr() : void 0;
  for (s.set(t, r), s.set(r, t); ++h < a; ) {
    var M = t[h], A = r[h];
    if (n)
      var P = o ? n(A, M, h, r, t, s) : n(M, A, h, t, r, s);
    if (P !== void 0) {
      if (P)
        continue;
      d = !1;
      break;
    }
    if (v) {
      if (!f0(r, function(C, g) {
        if (!ai(v, g) && (M === C || i(M, C, e, n, s)))
          return v.push(g);
      })) {
        d = !1;
        break;
      }
    } else if (!(M === A || i(M, A, e, n, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(t), s.delete(r), d;
}
function p0(t) {
  var r = -1, e = Array(t.size);
  return t.forEach(function(n, i) {
    e[++r] = [i, n];
  }), e;
}
function yo(t) {
  var r = -1, e = Array(t.size);
  return t.forEach(function(n) {
    e[++r] = n;
  }), e;
}
var g0 = 1, m0 = 2, v0 = "[object Boolean]", y0 = "[object Date]", w0 = "[object Error]", E0 = "[object Map]", M0 = "[object Number]", b0 = "[object RegExp]", x0 = "[object Set]", _0 = "[object String]", S0 = "[object Symbol]", A0 = "[object ArrayBuffer]", L0 = "[object DataView]", Na = $e ? $e.prototype : void 0, es = Na ? Na.valueOf : void 0;
function C0(t, r, e, n, i, s, o) {
  switch (e) {
    case L0:
      if (t.byteLength != r.byteLength || t.byteOffset != r.byteOffset)
        return !1;
      t = t.buffer, r = r.buffer;
    case A0:
      return !(t.byteLength != r.byteLength || !s(new oi(t), new oi(r)));
    case v0:
    case y0:
    case M0:
      return En(+t, +r);
    case w0:
      return t.name == r.name && t.message == r.message;
    case b0:
    case _0:
      return t == r + "";
    case E0:
      var a = p0;
    case x0:
      var u = n & g0;
      if (a || (a = yo), t.size != r.size && !u)
        return !1;
      var l = o.get(t);
      if (l)
        return l == r;
      n |= m0, o.set(t, r);
      var c = Cu(a(t), a(r), n, i, s, o);
      return o.delete(t), c;
    case S0:
      if (es)
        return es.call(t) == es.call(r);
  }
  return !1;
}
var k0 = 1, T0 = Object.prototype, P0 = T0.hasOwnProperty;
function I0(t, r, e, n, i, s) {
  var o = e & k0, a = Ls(t), u = a.length, l = Ls(r), c = l.length;
  if (u != c && !o)
    return !1;
  for (var h = u; h--; ) {
    var d = a[h];
    if (!(o ? d in r : P0.call(r, d)))
      return !1;
  }
  var v = s.get(t), M = s.get(r);
  if (v && M)
    return v == r && M == t;
  var A = !0;
  s.set(t, r), s.set(r, t);
  for (var P = o; ++h < u; ) {
    d = a[h];
    var C = t[d], g = r[d];
    if (n)
      var D = o ? n(g, C, d, r, t, s) : n(C, g, d, t, r, s);
    if (!(D === void 0 ? C === g || i(C, g, e, n, s) : D)) {
      A = !1;
      break;
    }
    P || (P = d == "constructor");
  }
  if (A && !P) {
    var F = t.constructor, G = r.constructor;
    F != G && "constructor" in t && "constructor" in r && !(typeof F == "function" && F instanceof F && typeof G == "function" && G instanceof G) && (A = !1);
  }
  return s.delete(t), s.delete(r), A;
}
var F0 = 1, Ua = "[object Arguments]", Ha = "[object Array]", Rn = "[object Object]", D0 = Object.prototype, za = D0.hasOwnProperty;
function O0(t, r, e, n, i, s) {
  var o = ke(t), a = ke(r), u = o ? Ha : Qe(t), l = a ? Ha : Qe(r);
  u = u == Ua ? Rn : u, l = l == Ua ? Rn : l;
  var c = u == Rn, h = l == Rn, d = u == l;
  if (d && fn(t)) {
    if (!fn(r))
      return !1;
    o = !0, c = !1;
  }
  if (d && !c)
    return s || (s = new tt()), o || ho(t) ? Cu(t, r, e, n, i, s) : C0(t, r, u, e, n, i, s);
  if (!(e & F0)) {
    var v = c && za.call(t, "__wrapped__"), M = h && za.call(r, "__wrapped__");
    if (v || M) {
      var A = v ? t.value() : t, P = M ? r.value() : r;
      return s || (s = new tt()), i(A, P, e, n, s);
    }
  }
  return d ? (s || (s = new tt()), I0(t, r, e, n, i, s)) : !1;
}
function Pi(t, r, e, n, i) {
  return t === r ? !0 : t == null || r == null || !pt(t) && !pt(r) ? t !== t && r !== r : O0(t, r, e, n, Pi, i);
}
var G0 = 1, R0 = 2;
function B0(t, r, e, n) {
  var i = e.length, s = i;
  if (t == null)
    return !s;
  for (t = Object(t); i--; ) {
    var o = e[i];
    if (o[2] ? o[1] !== t[o[0]] : !(o[0] in t))
      return !1;
  }
  for (; ++i < s; ) {
    o = e[i];
    var a = o[0], u = t[a], l = o[1];
    if (o[2]) {
      if (u === void 0 && !(a in t))
        return !1;
    } else {
      var c = new tt(), h;
      if (!(h === void 0 ? Pi(l, u, G0 | R0, n, c) : h))
        return !1;
    }
  }
  return !0;
}
function ku(t) {
  return t === t && !ze(t);
}
function N0(t) {
  for (var r = Li(t), e = r.length; e--; ) {
    var n = r[e], i = t[n];
    r[e] = [n, i, ku(i)];
  }
  return r;
}
function Tu(t, r) {
  return function(e) {
    return e == null ? !1 : e[t] === r && (r !== void 0 || t in Object(e));
  };
}
function U0(t) {
  var r = N0(t);
  return r.length == 1 && r[0][2] ? Tu(r[0][0], r[0][1]) : function(e) {
    return e === t || B0(e, t, r);
  };
}
function H0(t, r) {
  return t != null && r in Object(t);
}
function z0(t, r, e) {
  r = vu(r, t);
  for (var n = -1, i = r.length, s = !1; ++n < i; ) {
    var o = Ti(r[n]);
    if (!(s = t != null && e(t, o)))
      break;
    t = t[o];
  }
  return s || ++n != i ? s : (i = t == null ? 0 : t.length, !!i && co(i) && lo(o, i) && (ke(t) || cn(t)));
}
function J0(t, r) {
  return t != null && z0(t, r, H0);
}
var q0 = 1, V0 = 2;
function Y0(t, r) {
  return po(t) && ku(r) ? Tu(Ti(t), r) : function(e) {
    var n = rr(e, t);
    return n === void 0 && n === r ? J0(e, t) : Pi(r, n, q0 | V0);
  };
}
function W0(t) {
  return function(r) {
    return r == null ? void 0 : r[t];
  };
}
function $0(t) {
  return function(r) {
    return mo(r, t);
  };
}
function j0(t) {
  return po(t) ? W0(Ti(t)) : $0(t);
}
function Pu(t) {
  return typeof t == "function" ? t : t == null ? _i : typeof t == "object" ? ke(t) ? Y0(t[0], t[1]) : U0(t) : j0(t);
}
function Z0(t, r, e, n) {
  for (var i = -1, s = t == null ? 0 : t.length; ++i < s; ) {
    var o = t[i];
    r(n, o, e(o), t);
  }
  return n;
}
function X0(t) {
  return function(r, e, n) {
    for (var i = -1, s = Object(r), o = n(r), a = o.length; a--; ) {
      var u = o[++i];
      if (e(s[u], u, s) === !1)
        break;
    }
    return r;
  };
}
var Iu = X0();
function K0(t, r) {
  return t && Iu(t, r, Li);
}
function Q0(t, r) {
  return function(e, n) {
    if (e == null)
      return e;
    if (!Ir(e))
      return t(e, n);
    for (var i = e.length, s = -1, o = Object(e); ++s < i && n(o[s], s, o) !== !1; )
      ;
    return e;
  };
}
var Fu = Q0(K0);
function em(t, r, e, n) {
  return Fu(t, function(i, s, o) {
    r(n, i, e(i), o);
  }), n;
}
function tm(t, r) {
  return function(e, n) {
    var i = ke(e) ? Z0 : em, s = r ? r() : {};
    return i(e, t, Pu(n), s);
  };
}
var ts = function() {
  return nt.Date.now();
}, rm = "Expected a function", nm = Math.max, im = Math.min;
function wo(t, r, e) {
  var n, i, s, o, a, u, l = 0, c = !1, h = !1, d = !0;
  if (typeof t != "function")
    throw new TypeError(rm);
  r = va(r) || 0, ze(e) && (c = !!e.leading, h = "maxWait" in e, s = h ? nm(va(e.maxWait) || 0, r) : s, d = "trailing" in e ? !!e.trailing : d);
  function v(B) {
    var H = n, f = i;
    return n = i = void 0, l = B, o = t.apply(f, H), o;
  }
  function M(B) {
    return l = B, a = setTimeout(C, r), c ? v(B) : o;
  }
  function A(B) {
    var H = B - u, f = B - l, p = r - H;
    return h ? im(p, s - f) : p;
  }
  function P(B) {
    var H = B - u, f = B - l;
    return u === void 0 || H >= r || H < 0 || h && f >= s;
  }
  function C() {
    var B = ts();
    if (P(B))
      return g(B);
    a = setTimeout(C, A(B));
  }
  function g(B) {
    return a = void 0, d && n ? v(B) : (n = i = void 0, o);
  }
  function D() {
    a !== void 0 && clearTimeout(a), l = 0, n = u = i = a = void 0;
  }
  function F() {
    return a === void 0 ? o : g(ts());
  }
  function G() {
    var B = ts(), H = P(B);
    if (n = arguments, i = this, u = B, H) {
      if (a === void 0)
        return M(u);
      if (h)
        return clearTimeout(a), a = setTimeout(C, r), v(u);
    }
    return a === void 0 && (a = setTimeout(C, r)), o;
  }
  return G.cancel = D, G.flush = F, G;
}
function Ts(t, r, e) {
  (e !== void 0 && !En(t[r], e) || e === void 0 && !(r in t)) && Si(t, r, e);
}
function Du(t) {
  return pt(t) && Ir(t);
}
function Ps(t, r) {
  if (!(r === "constructor" && typeof t[r] == "function") && r != "__proto__")
    return t[r];
}
function sm(t) {
  return id(t, mu(t));
}
function om(t, r, e, n, i, s, o) {
  var a = Ps(t, e), u = Ps(r, e), l = o.get(u);
  if (l) {
    Ts(t, e, l);
    return;
  }
  var c = s ? s(a, u, e + "", t, r, o) : void 0, h = c === void 0;
  if (h) {
    var d = ke(u), v = !d && fn(u), M = !d && !v && ho(u);
    c = u, d || v || M ? ke(a) ? c = a : Du(a) ? c = Hh(a) : v ? (h = !1, c = bu(u, !0)) : M ? (h = !1, c = xu(u, !0)) : c = [] : Rp(u) || cn(u) ? (c = a, cn(a) ? c = sm(a) : (!ze(a) || ao(a)) && (c = _u(u))) : h = !1;
  }
  h && (o.set(u, c), i(c, u, n, s, o), o.delete(u)), Ts(t, e, c);
}
function Eo(t, r, e, n, i) {
  t !== r && Iu(r, function(s, o) {
    if (i || (i = new tt()), ze(s))
      om(t, r, o, e, Eo, n, i);
    else {
      var a = n ? n(Ps(t, o), s, o + "", t, r, i) : void 0;
      a === void 0 && (a = s), Ts(t, o, a);
    }
  }, mu);
}
var am = cu(function(t, r, e, n) {
  Eo(t, r, e, n);
});
function lm(t, r, e) {
  for (var n = -1, i = t == null ? 0 : t.length; ++n < i; )
    if (e(r, t[n]))
      return !0;
  return !1;
}
function um(t, r) {
  var e = -1, n = Ir(t) ? Array(t.length) : [];
  return Fu(t, function(i, s, o) {
    n[++e] = r(i, s, o);
  }), n;
}
function cm(t, r) {
  return Mr(r, function(e) {
    return t[e];
  });
}
function fm(t) {
  return t == null ? [] : cm(t, Li(t));
}
var hm = Math.min;
function dm(t, r, e) {
  for (var n = lu, i = t[0].length, s = t.length, o = s, a = Array(s), u = 1 / 0, l = []; o--; ) {
    var c = t[o];
    u = hm(c.length, u), a[o] = i >= 120 && c.length >= 120 ? new kr(o && c) : void 0;
  }
  c = t[0];
  var h = -1, d = a[0];
  e:
    for (; ++h < i && l.length < u; ) {
      var v = c[h], M = v;
      if (v = v !== 0 ? v : 0, !(d ? ai(d, M) : n(l, M))) {
        for (o = s; --o; ) {
          var A = a[o];
          if (!(A ? ai(A, M) : n(t[o], M)))
            continue e;
        }
        d && d.push(M), l.push(v);
      }
    }
  return l;
}
function pm(t) {
  return Du(t) ? t : [];
}
var gm = uo(function(t) {
  var r = Mr(t, pm);
  return r.length && r[0] === t[0] ? dm(r) : [];
});
function Mn(t, r) {
  return Pi(t, r);
}
var mm = tm(function(t, r, e) {
  Si(t, e, r);
}), vm = cu(function(t, r, e) {
  Eo(t, r, e);
});
function ym(t, r) {
  var e = t.length;
  for (t.sort(r); e--; )
    t[e] = t[e].value;
  return t;
}
function wm(t, r) {
  if (t !== r) {
    var e = t !== void 0, n = t === null, i = t === t, s = Lr(t), o = r !== void 0, a = r === null, u = r === r, l = Lr(r);
    if (!a && !l && !s && t > r || s && o && u && !a && !l || n && o && u || !e && u || !i)
      return 1;
    if (!n && !s && !l && t < r || l && e && i && !n && !s || a && e && i || !o && i || !u)
      return -1;
  }
  return 0;
}
function Em(t, r, e) {
  for (var n = -1, i = t.criteria, s = r.criteria, o = i.length, a = e.length; ++n < o; ) {
    var u = wm(i[n], s[n]);
    if (u) {
      if (n >= a)
        return u;
      var l = e[n];
      return u * (l == "desc" ? -1 : 1);
    }
  }
  return t.index - r.index;
}
function Mm(t, r, e) {
  r.length ? r = Mr(r, function(s) {
    return ke(s) ? function(o) {
      return mo(o, s.length === 1 ? s[0] : s);
    } : s;
  }) : r = [_i];
  var n = -1;
  r = Mr(r, Ai(Pu));
  var i = um(t, function(s, o, a) {
    var u = Mr(r, function(l) {
      return l(s);
    });
    return { criteria: u, index: ++n, value: s };
  });
  return ym(i, function(s, o) {
    return Em(s, o, e);
  });
}
var Ja = uo(function(t, r) {
  if (t == null)
    return [];
  var e = r.length;
  return e > 1 && As(t, r[0], r[1]) ? r = [] : e > 2 && As(r[0], r[1], r[2]) && (r = [r[0]]), Mm(t, Pp(r), []);
}), bm = "Expected a function";
function Ou(t, r, e) {
  var n = !0, i = !0;
  if (typeof t != "function")
    throw new TypeError(bm);
  return ze(e) && (n = "leading" in e ? !!e.leading : n, i = "trailing" in e ? !!e.trailing : i), wo(t, r, {
    leading: n,
    maxWait: r,
    trailing: i
  });
}
var xm = 1 / 0, _m = br && 1 / yo(new br([, -0]))[1] == xm ? function(t) {
  return new br(t);
} : Uh, Sm = 200;
function Am(t, r, e) {
  var n = -1, i = lu, s = t.length, o = !0, a = [], u = a;
  if (e)
    o = !1, i = lm;
  else if (s >= Sm) {
    var l = _m(t);
    if (l)
      return yo(l);
    o = !1, i = ai, u = new kr();
  } else
    u = a;
  e:
    for (; ++n < s; ) {
      var c = t[n], h = c;
      if (c = e || c !== 0 ? c : 0, o && h === h) {
        for (var d = u.length; d--; )
          if (u[d] === h)
            continue e;
        a.push(c);
      } else i(u, h, e) || (u !== a && u.push(h), a.push(c));
    }
  return a;
}
function Is(t, r) {
  return r = typeof r == "function" ? r : void 0, t && t.length ? Am(t, void 0, r) : [];
}
const on = (t, r) => t[0] === r[0] && t[1] === r[1], Gu = (t) => t.type === "Feature" && t.geometry.type === "LineString", Ru = (t) => t.type === "Feature" && t.geometry.type === "Polygon", Bu = (t) => t.type === "Feature" && t.geometry.type === "MultiPolygon", qa = (t, r) => ({
  lng: r[0] - t[0],
  lat: r[1] - t[1]
}), li = (t) => Array.isArray(t) && t.length >= 2 && t.length <= 3 && t.every((r) => typeof r == "number"), bn = (t, r, e = !1) => {
  let n = 0;
  const i = ["features", "geometries", "geometry", "coordinates"], s = (o, a, u = !1) => {
    li(o) ? (r({ coordinate: o, path: a }, n), n += 1) : Array.isArray(o) ? o.forEach((l, c) => {
      u && e && c === o.length - 1 && li(l) || s(l, [...a, c], u);
    }) : typeof o == "object" && o !== null && Re(o).forEach((l) => {
      const c = o[l];
      if (i.includes(l) && c) {
        const h = "type" in o && o.type, d = h === "Polygon" || h === "MultiPolygon";
        s(c, [...a, l], d);
      }
    });
  };
  s(t, []);
}, Nu = (t, r) => {
  let e = { coordinate: [0, 0], path: [] }, n = -1;
  try {
    bn(t, (i, s) => {
      if (r[0] === i.coordinate[0] && r[1] === i.coordinate[1])
        throw n = s, e = i, new Error("stop");
    });
  } catch {
    if (e)
      return {
        index: n,
        coordinate: e.coordinate,
        path: e.path
      };
  }
  return null;
}, Uu = (t, r) => {
  let e = 0;
  const n = ["features", "geometries", "geometry", "coordinates"], i = (s, o, a, u) => {
    li(s) && li(o) ? (r(
      {
        start: { coordinate: [...s], path: a },
        end: { coordinate: [...o], path: u }
      },
      e
    ), e += 1) : Array.isArray(s) ? s.forEach((l, c) => {
      i(
        l,
        s[c + 1],
        [...a, c],
        [...a, c + 1]
      );
    }) : typeof s == "object" && s !== null && Re(s).forEach((l) => {
      const c = s[l];
      n.includes(l) && c && i(c, void 0, [...a, l], []);
    });
  };
  i(t, void 0, [], []);
}, Ii = (t, r) => {
  let e = {
    absCoordIndex: -1,
    featureIndex: -1,
    multiFeatureIndex: -1,
    geometryIndex: -1
  };
  try {
    Yt(
      t,
      (n, i, s, o, a) => {
        if (n[0] === r[0] && n[1] === r[1])
          throw e = { absCoordIndex: i, featureIndex: s, multiFeatureIndex: o, geometryIndex: a }, new Error("found");
      }
    );
  } catch {
  }
  return e;
}, yr = (t, r) => {
  const [e, n] = t, [i, s] = r, o = Math.min(e, i), a = Math.min(n, s), u = Math.max(e, i), l = Math.max(n, s);
  return [o, a, u, l];
}, Fs = (t, r) => {
  const e = yr(t, r), n = [e[0], e[1]], i = [e[2], e[3]], s = n[0], o = n[1], a = i[0], u = i[1];
  return {
    type: "Feature",
    properties: {
      shape: "rectangle"
    },
    geometry: {
      type: "Polygon",
      coordinates: [[
        [s, o],
        [a, o],
        [a, u],
        [s, u],
        [s, o]
      ]]
    }
  };
}, Hu = (t) => [
  t.geometry.coordinates[0],
  t.geometry.coordinates[1]
], Mo = (t) => {
  const r = nu(t);
  return [
    [r[0], r[1]],
    // South-West (min-x, min-y)
    [r[2], r[3]]
    // North-East (max-x, max-y)
  ];
}, zu = (t) => [
  t[0][0],
  t[0][1],
  t[1][0],
  t[1][1]
], Lm = (t, r) => {
  const [e, n, i, s] = t, [o, a] = r;
  return o >= e && o <= i && a >= n && a <= s;
}, Cm = (t, r) => {
  const e = zu(t);
  return Lm(e, r);
}, rs = (t) => {
  let r = 0;
  return Yt(t, () => {
    r += 1;
  }, !0), r;
}, km = (t) => {
  const r = [];
  return Yt(t, (e) => {
    r.push([e[0], e[1]]);
  }, !0), r;
}, Ju = (t) => {
  const r = km(t);
  return r.some((e) => !Mn(r[0], e));
}, qu = (t) => {
  let r = null;
  try {
    bn(t, (e) => {
      throw r = e.coordinate, new Error("found");
    });
  } catch {
    return r;
  }
  return null;
}, Zn = (t, r) => Math.sqrt(
  (t[0] - r[0]) ** 2 + (t[1] - r[1]) ** 2
), Tm = (t, r, e) => {
  const [n, i] = [t[0], t[1]], [s, o] = [r[0], r[1]], [a, u] = [e[0], e[1]], l = s - n, c = o - i, h = a - n, d = u - i, v = h * l + d * c, M = l * l + c * c;
  let A = v / M;
  return A = Math.max(0, Math.min(1, A)), [
    n + A * l,
    i + A * c
  ];
}, Pm = (t, r) => {
  const { absCoordIndex: e } = Ii(t, r);
  return e !== -1 ? (t.geometry.coordinates.splice(e, 1), !0) : !1;
}, Im = (t, r) => {
  const e = Ii(t, r);
  if (e.absCoordIndex !== -1) {
    const n = [e.geometryIndex], i = rr(t.geometry.coordinates, n), s = i.findIndex((o) => Mn(o, r));
    return i.length <= 4 ? (t.geometry.coordinates.splice(e.geometryIndex, 1), !0) : (i.splice(s, 1), s === 0 && (i[i.length - 1] = [...i[0]]), !0);
  }
  return !1;
}, Fm = (t, r) => {
  const e = Ii(t, r);
  if (e.absCoordIndex !== -1) {
    const n = [
      e.multiFeatureIndex,
      e.geometryIndex
    ], i = rr(t.geometry.coordinates, n), s = i.findIndex((o) => Mn(o, r));
    if (i.length <= 4) {
      n.pop();
      const o = rr(
        t.geometry.coordinates,
        e.multiFeatureIndex
      );
      return o.splice(e.geometryIndex, 1), o.length === 0 && t.geometry.coordinates.splice(e.multiFeatureIndex, 1), !0;
    }
    return i.splice(s, 1), s === 0 && (i[i.length - 1] = [...i[0]]), !0;
  }
  return !1;
}, Dm = (t, r) => Gu(t) ? Pm(t, r) : Ru(t) ? Im(t, r) : Bu(t) ? Fm(t, r) : !1, Om = (t, r = "marker") => ({
  type: "Feature",
  properties: {
    shape: r
  },
  geometry: {
    type: "Point",
    coordinates: t
  }
}), bo = ({ center: t, radius: r, steps: e = 80 }) => {
  const n = eh(
    t,
    r,
    {
      steps: e,
      units: "meters"
    }
  );
  return n.geometry.coordinates[0][0] = [
    ...n.geometry.coordinates[0][0]
  ], n;
};
function Vu(t, r = {}) {
  let e = 0, n = 0, i = 0;
  return Yt(
    t,
    function(s) {
      e += s[0], n += s[1], i++;
    },
    !0
  ), Rt([e / i, n / i], r.properties);
}
var Yu = Vu;
const Gm = ["circle", "rectangle"];
class ui {
  constructor(r) {
    w(this, "gm");
    w(this, "id", "no-id");
    w(this, "parent", null);
    w(this, "shape");
    w(this, "markers");
    w(this, "shapeProperties", { center: null });
    w(this, "source");
    w(this, "orders", this.getEmptyOrders());
    this.gm = r.gm, this.id = r.id, this.source = r.source, this.parent = r.parent, this.markers = /* @__PURE__ */ new Map(), this.shape = r.geoJsonShapeFeature.properties.shape, this.order = this.getFreeOrder(), this.addGeoJson(r.geoJsonShapeFeature);
  }
  get order() {
    const r = this.source.id;
    if (this.orders[r] !== null)
      return this.orders[r];
    throw new Error(`Null order for feature id: ${this.id}`);
  }
  set order(r) {
    const e = this.source.id;
    this.orders[e] = r;
  }
  getEmptyOrders() {
    return Object.fromEntries(
      Xr(O).map((r) => [r, null])
    );
  }
  get temporary() {
    return this.source.id === O.temporary;
  }
  get sourceName() {
    return this.source.id;
  }
  getFreeOrder() {
    return this.getSourceGeoJson().features.length;
  }
  getGeoJson() {
    if (!this.isFeatureAvailable())
      throw new Error(`Feature not found: "${this.id}"`);
    this.fixOrder();
    const r = this.getSourceGeoJson().features[this.order] || null;
    if (this.id !== (r == null ? void 0 : r.id))
      throw N.error(`Feature not found: ${this.id} !== ${r == null ? void 0 : r.id}`, r, this.getSourceGeoJson()), new Error("Feature not found");
    return r;
  }
  getShapeProperty(r) {
    return this.shapeProperties[r];
  }
  setShapeProperty(r, e) {
    this.shapeProperties[r] = e;
  }
  getSourceGeoJson() {
    return this.source.getGeoJson();
  }
  addGeoJson(r) {
    if (!this.isFeatureAvailable())
      throw new Error(`Feature not found: "${this.id}"`);
    const e = this.getSourceGeoJson();
    e.features[this.order] && N.error("FeatureData.addGeoJson, not an empty feature", this.id, e);
    const n = {
      ...r,
      id: this.id,
      properties: {
        ...r.properties,
        [xr]: this.id
      }
    };
    e.features[this.order] = n, this.updateGeoJsonCenter(n), this.gm.features.updateSourceData({
      diff: { add: [n] },
      sourceName: this.sourceName
    });
  }
  removeGeoJson() {
    if (!this.isFeatureAvailable())
      throw new Error(`Feature not found: "${this.id}"`);
    this.fixOrder();
    const r = this.getSourceGeoJson();
    delete r.features[this.order], this.gm.features.updateSourceData({
      diff: { remove: [this.id] },
      sourceName: this.sourceName
    }), this.order = null;
  }
  removeMarkers() {
    this.markers.forEach((r) => {
      r.instance instanceof so ? r.instance.remove() : this.gm.features.delete(r.instance);
    }), this.markers = /* @__PURE__ */ new Map();
  }
  updateGeoJsonGeometry(r) {
    if (!this.isFeatureAvailable())
      throw new Error(`Feature not found: "${this.id}"`);
    this.fixOrder();
    const e = this.getSourceGeoJson();
    e.features[this.order].geometry = r;
    const n = {
      update: [
        e.features[this.order]
      ]
    };
    this.gm.features.updateSourceData({
      diff: n,
      sourceName: this.sourceName
    });
  }
  updateGeoJsonProperties(r) {
    if (!this.isFeatureAvailable())
      throw new Error(`Feature not found: "${this.id}"`);
    this.fixOrder();
    const e = this.getSourceGeoJson();
    e.features[this.order].properties = {
      ...e.features[this.order].properties,
      ...r
    };
    const n = {
      update: [
        e.features[this.order]
      ]
    };
    this.gm.features.updateSourceData({
      diff: n,
      sourceName: this.sourceName
    });
  }
  updateGeoJsonCenter(r) {
    if (this.shape === "circle") {
      const e = Hu(Yu(r));
      this.setShapeProperty("center", e);
    }
  }
  convertToPolygon() {
    return this.isConvertableToPolygon() ? (this.shape = "polygon", this.shapeProperties.center = null, !0) : !1;
  }
  isConvertableToPolygon() {
    return Gm.includes(this.shape);
  }
  fixOrder() {
    if (!this.isFeatureAvailable())
      throw new Error(`Feature not found: "${this.id}"`);
  }
  isFeatureAvailable() {
    return this.order !== null;
  }
  changeSource({ sourceName: r, atomic: e }) {
    e ? this.gm.features.withAtomicSourcesUpdate(
      () => this.actualChangeSource({ sourceName: r, atomic: e })
    ) : this.actualChangeSource({ sourceName: r, atomic: e });
  }
  actualChangeSource({ sourceName: r, atomic: e }) {
    if (this.source.id === r) {
      N.error(`FeatureData.changeSource: feature "${this.id}" already has the source "${r}"`);
      return;
    }
    const n = this.gm.features.sources[r];
    if (!n) {
      N.error(`FeatureData.changeSource: missing source "${r}"`);
      return;
    }
    const i = this.getGeoJson();
    this.removeGeoJson(), this.source = n, this.order = this.getFreeOrder(), this.addGeoJson(i), this.markers.forEach((s) => {
      s.instance instanceof ui && s.instance.changeSource({ sourceName: r, atomic: e });
    });
  }
  delete() {
    this.removeGeoJson(), this.removeMarkers(), this.id = "no-id", this.orders = this.getEmptyOrders();
  }
}
const Rm = ["on", "off"], Wu = (t) => zt(t) && t.type === "control" && Rm.includes(t.action), zt = (t) => !!(t && typeof t == "object" && "level" in t && "type" in t && "action" in t), xo = (t) => zt(t) && Kt(t.action, qf), Y = "gm";
class Fi {
  constructor(r) {
    w(this, "gm");
    this.gm = r;
  }
  trackExclusiveModes(r) {
    if (r.action !== "mode_start")
      return;
    const {
      sectionName: e,
      modeName: n
    } = this.getControlIds(r) || {}, i = this.getControl(r);
    i != null && i.settings.exclusive && this.gm.control.eachControlWithOptions((s) => {
      const o = s.control.type, a = s.control.targetMode;
      o === e && a === n || s.controlOptions.active && s.control.settings.exclusive && this.gm.options.disableMode(o, a);
    });
  }
  trackRelatedModes(r) {
    xo(r) && this.gm.control.eachControlWithOptions((e) => {
      var i;
      const n = e.control;
      (i = n.settings.enabledBy) != null && i.includes(r.mode) && (r.action === "mode_start" ? this.gm.options.enableMode(n.type, n.targetMode) : r.action === "mode_end" ? this.gm.options.disableMode(n.type, n.targetMode) : N.error("Unknown mode action", r.action));
    });
  }
  getControl(r) {
    const { modeName: e, sectionName: n } = this.getControlIds(r) || {};
    return e && n ? this.gm.control.getControl({ actionType: n, modeName: e }) : null;
  }
  getControlOptions(r) {
    const { modeName: e, sectionName: n } = this.getControlIds(r) || {};
    return e && n ? this.gm.options.getControlOptions({ actionType: n, modeName: e }) : null;
  }
  getControlIds(r) {
    let e = null, n = null;
    return r.action === "mode_start" ? (e = r.type, n = r.mode) : Wu(r) && (e = r.section, n = r.target), e && n ? { sectionName: e, modeName: n } : null;
  }
}
class Bm {
  isInstanceAvailable() {
    return this.sourceInstance ? !0 : (N.error("Source instance is not available"), !1);
  }
}
const Nm = [
  "intersection_violation",
  "containment_violation"
], Di = (t) => zt(t) && t.type === "helper", Um = (t) => Di(t) && t.mode === "geofencing" && Kt(t.action, Nm), Hm = ["draw", "edit", "helper"];
class _o {
  constructor(r) {
    w(this, "gm");
    w(this, "options", []);
    w(this, "actions", []);
    w(this, "flags", {
      featureCreateAllowed: !0,
      featureUpdateAllowed: !0
    });
    w(this, "internalMapEventHandlers", {
      [`${Y}:helper`]: this.handleHelperEvent.bind(this)
    });
    this.gm = r;
  }
  startAction() {
    this.gm.events.bus.attachEvents(this.internalMapEventHandlers), this.gm.events.bus.attachEvents(this.mapEventHandlers), this.onStartAction();
  }
  endAction() {
    this.onEndAction(), this.gm.events.bus.detachEvents(this.mapEventHandlers), this.gm.events.bus.detachEvents(this.internalMapEventHandlers);
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  getOptionValue(r) {
    const e = this.options.find((n) => n.name === r);
    if (!e)
      throw new Error(`Option ${r} not found`);
    if (e.type === "toggle")
      return e.value;
    if (e.type === "select")
      return e.value.value;
    throw new Error(`Unknown option type: ${JSON.stringify(e)}`);
  }
  applyOptionValue(r, e) {
    const n = this.options.find((i) => i.name === r);
    if (!n) {
      N.error("Option not found", r, e);
      return;
    }
    if (n.type === "toggle" && typeof e == "boolean")
      n.value = e;
    else if (n.type === "select") {
      const i = n.choices.find((s) => s.value === e);
      i && (n.value = i);
    } else
      N.error("Can't apply option value", r, e, n);
  }
  handleHelperEvent(r) {
    return Um(r) ? this.handleGeofencingViolationEvent(r) : { next: !0 };
  }
  handleGeofencingViolationEvent(r) {
    return r.actionType === "draw" ? this.flags.featureCreateAllowed = !1 : r.actionType === "edit" && (this.flags.featureUpdateAllowed = !1), { next: !0 };
  }
  fireBeforeFeatureCreate({ geoJsonFeatures: r, forceMode: e = void 0 }) {
    this.flags.featureCreateAllowed = !0;
    const n = {
      level: "system",
      type: this.actionType,
      mode: e || this.mode,
      action: "before_create",
      geoJsonFeatures: r
    };
    this.gm.events.fire(`${Y}:${this.actionType}`, n);
  }
  fireBeforeFeatureUpdate({ features: r, geoJsonFeatures: e, forceMode: n = void 0 }) {
    this.flags.featureUpdateAllowed = !0;
    const i = {
      level: "system",
      type: this.actionType,
      mode: n || this.mode,
      action: "before_update",
      features: r,
      geoJsonFeatures: e
    };
    this.gm.events.fire(`${Y}:${this.actionType}`, i);
  }
}
const So = (t) => zt(t) && t.type === "draw", $u = (t) => zt(t) && t.type === "draw" && "variant" in t && t.variant === "line_drawer", ci = [
  // shapes
  "marker",
  "circle",
  "circle_marker",
  "text_marker",
  "line",
  "rectangle",
  "polygon"
], zm = [
  "freehand",
  "custom_shape"
], ju = [
  ...ci,
  ...zm
];
class Pt extends _o {
  constructor() {
    super(...arguments);
    w(this, "actionType", "draw");
    w(this, "shape", null);
    w(this, "featureData", null);
  }
  saveFeature() {
    if (this.featureData) {
      const e = this.featureData.getGeoJson();
      this.removeTmpFeature(), this.gm.features.createFeature({
        sourceName: O.main,
        shapeGeoJson: e
      });
    } else
      N.error("BaseDraw.saveFeature: no featureData to save");
  }
  removeTmpFeature() {
    this.featureData && (this.featureData.temporary || N.error("Not a temporary feature to remove", this.featureData), this.gm.features.delete(this.featureData), this.featureData = null);
  }
  fireMarkerPointerStartEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const e = this.gm.markerPointer.marker, n = {
      level: "system",
      variant: null,
      type: "draw",
      mode: this.shape,
      action: "start",
      markerData: {
        type: "dom",
        instance: e,
        position: {
          coordinate: e.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${Y}:draw`, n);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker || !this.shape)
      return;
    const e = this.gm.markerPointer.marker, n = {
      level: "system",
      variant: null,
      type: "draw",
      mode: this.shape,
      action: "update",
      markerData: {
        type: "dom",
        instance: e,
        position: {
          coordinate: e.getLngLat(),
          path: [-1]
        }
      },
      featureData: this.featureData
    };
    this.gm.events.fire(`${Y}:draw`, n);
  }
  fireMarkerPointerFinishEvent() {
    if (!this.shape)
      return;
    const e = {
      level: "system",
      variant: null,
      type: "draw",
      mode: this.shape,
      action: "finish"
    };
    this.gm.events.fire(`${Y}:draw`, e);
  }
  forwardLineDrawerEvent(e) {
    if (!$u(e) || !this.shape)
      return { next: !0 };
    if (e.action === "start" || e.action === "update") {
      const n = {
        level: "system",
        type: "draw",
        mode: this.shape,
        variant: null,
        action: e.action,
        featureData: e.featureData,
        markerData: e.markerData
      };
      this.gm.events.fire(`${Y}:draw`, n);
    } else if (e.action === "finish" || e.action === "cancel") {
      const n = {
        level: "system",
        type: "draw",
        mode: this.shape,
        variant: null,
        action: e.action
      };
      this.gm.events.fire(`${Y}:draw`, n);
    }
    return { next: !0 };
  }
}
const St = 11102230246251565e-32, xe = 134217729, Jm = (3 + 8 * St) * St;
function ns(t, r, e, n, i) {
  let s, o, a, u, l = r[0], c = n[0], h = 0, d = 0;
  c > l == c > -l ? (s = l, l = r[++h]) : (s = c, c = n[++d]);
  let v = 0;
  if (h < t && d < e)
    for (c > l == c > -l ? (o = l + s, a = s - (o - l), l = r[++h]) : (o = c + s, a = s - (o - c), c = n[++d]), s = o, a !== 0 && (i[v++] = a); h < t && d < e; )
      c > l == c > -l ? (o = s + l, u = o - s, a = s - (o - u) + (l - u), l = r[++h]) : (o = s + c, u = o - s, a = s - (o - u) + (c - u), c = n[++d]), s = o, a !== 0 && (i[v++] = a);
  for (; h < t; )
    o = s + l, u = o - s, a = s - (o - u) + (l - u), l = r[++h], s = o, a !== 0 && (i[v++] = a);
  for (; d < e; )
    o = s + c, u = o - s, a = s - (o - u) + (c - u), c = n[++d], s = o, a !== 0 && (i[v++] = a);
  return (s !== 0 || v === 0) && (i[v++] = s), v;
}
function qm(t, r) {
  let e = r[0];
  for (let n = 1; n < t; n++) e += r[n];
  return e;
}
function xn(t) {
  return new Float64Array(t);
}
const Vm = (3 + 16 * St) * St, Ym = (2 + 12 * St) * St, Wm = (9 + 64 * St) * St * St, dr = xn(4), Va = xn(8), Ya = xn(12), Wa = xn(16), Ae = xn(4);
function $m(t, r, e, n, i, s, o) {
  let a, u, l, c, h, d, v, M, A, P, C, g, D, F, G, B, H, f;
  const p = t - i, m = e - i, y = r - s, E = n - s;
  F = p * E, d = xe * p, v = d - (d - p), M = p - v, d = xe * E, A = d - (d - E), P = E - A, G = M * P - (F - v * A - M * A - v * P), B = y * m, d = xe * y, v = d - (d - y), M = y - v, d = xe * m, A = d - (d - m), P = m - A, H = M * P - (B - v * A - M * A - v * P), C = G - H, h = G - C, dr[0] = G - (C + h) + (h - H), g = F + C, h = g - F, D = F - (g - h) + (C - h), C = D - B, h = D - C, dr[1] = D - (C + h) + (h - B), f = g + C, h = f - g, dr[2] = g - (f - h) + (C - h), dr[3] = f;
  let S = qm(4, dr), k = Ym * o;
  if (S >= k || -S >= k || (h = t - p, a = t - (p + h) + (h - i), h = e - m, l = e - (m + h) + (h - i), h = r - y, u = r - (y + h) + (h - s), h = n - E, c = n - (E + h) + (h - s), a === 0 && u === 0 && l === 0 && c === 0) || (k = Wm * o + Jm * Math.abs(S), S += p * c + E * a - (y * l + m * u), S >= k || -S >= k)) return S;
  F = a * E, d = xe * a, v = d - (d - a), M = a - v, d = xe * E, A = d - (d - E), P = E - A, G = M * P - (F - v * A - M * A - v * P), B = u * m, d = xe * u, v = d - (d - u), M = u - v, d = xe * m, A = d - (d - m), P = m - A, H = M * P - (B - v * A - M * A - v * P), C = G - H, h = G - C, Ae[0] = G - (C + h) + (h - H), g = F + C, h = g - F, D = F - (g - h) + (C - h), C = D - B, h = D - C, Ae[1] = D - (C + h) + (h - B), f = g + C, h = f - g, Ae[2] = g - (f - h) + (C - h), Ae[3] = f;
  const b = ns(4, dr, 4, Ae, Va);
  F = p * c, d = xe * p, v = d - (d - p), M = p - v, d = xe * c, A = d - (d - c), P = c - A, G = M * P - (F - v * A - M * A - v * P), B = y * l, d = xe * y, v = d - (d - y), M = y - v, d = xe * l, A = d - (d - l), P = l - A, H = M * P - (B - v * A - M * A - v * P), C = G - H, h = G - C, Ae[0] = G - (C + h) + (h - H), g = F + C, h = g - F, D = F - (g - h) + (C - h), C = D - B, h = D - C, Ae[1] = D - (C + h) + (h - B), f = g + C, h = f - g, Ae[2] = g - (f - h) + (C - h), Ae[3] = f;
  const x = ns(b, Va, 4, Ae, Ya);
  F = a * c, d = xe * a, v = d - (d - a), M = a - v, d = xe * c, A = d - (d - c), P = c - A, G = M * P - (F - v * A - M * A - v * P), B = u * l, d = xe * u, v = d - (d - u), M = u - v, d = xe * l, A = d - (d - l), P = l - A, H = M * P - (B - v * A - M * A - v * P), C = G - H, h = G - C, Ae[0] = G - (C + h) + (h - H), g = F + C, h = g - F, D = F - (g - h) + (C - h), C = D - B, h = D - C, Ae[1] = D - (C + h) + (h - B), f = g + C, h = f - g, Ae[2] = g - (f - h) + (C - h), Ae[3] = f;
  const T = ns(x, Ya, 4, Ae, Wa);
  return Wa[T - 1];
}
function jm(t, r, e, n, i, s) {
  const o = (r - s) * (e - i), a = (t - i) * (n - s), u = o - a, l = Math.abs(o + a);
  return Math.abs(u) >= Vm * l ? u : -$m(t, r, e, n, i, s, l);
}
function Zm(t, r) {
  var e, n, i = 0, s, o, a, u, l, c, h, d = t[0], v = t[1], M = r.length;
  for (e = 0; e < M; e++) {
    n = 0;
    var A = r[e], P = A.length - 1;
    if (c = A[0], c[0] !== A[P][0] && c[1] !== A[P][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (o = c[0] - d, a = c[1] - v, n; n < P; n++) {
      if (h = A[n + 1], u = h[0] - d, l = h[1] - v, a === 0 && l === 0) {
        if (u <= 0 && o >= 0 || o <= 0 && u >= 0)
          return 0;
      } else if (l >= 0 && a <= 0 || l <= 0 && a >= 0) {
        if (s = jm(o, u, a, l, 0, 0), s === 0)
          return 0;
        (s > 0 && l > 0 && a <= 0 || s < 0 && l <= 0 && a > 0) && i++;
      }
      c = h, a = l, o = u;
    }
  }
  return i % 2 !== 0;
}
function nr(t, r, e = {}) {
  if (!t)
    throw new Error("point is required");
  if (!r)
    throw new Error("polygon is required");
  const n = he(t), i = wn(r), s = i.type, o = r.bbox;
  let a = i.coordinates;
  if (o && Xm(n, o) === !1)
    return !1;
  s === "Polygon" && (a = [a]);
  let u = !1;
  for (var l = 0; l < a.length; ++l) {
    const c = Zm(n, a[l]);
    if (c === 0) return !e.ignoreBoundary;
    c && (u = !0);
  }
  return u;
}
function Xm(t, r) {
  return r[0] <= t[0] && r[1] <= t[1] && r[2] >= t[0] && r[3] >= t[1];
}
class Zu {
  constructor(r = [], e = Km) {
    if (this.data = r, this.length = this.data.length, this.compare = e, this.length > 0)
      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(r) {
    this.data.push(r), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const r = this.data[0], e = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), r;
  }
  peek() {
    return this.data[0];
  }
  _up(r) {
    const { data: e, compare: n } = this, i = e[r];
    for (; r > 0; ) {
      const s = r - 1 >> 1, o = e[s];
      if (n(i, o) >= 0) break;
      e[r] = o, r = s;
    }
    e[r] = i;
  }
  _down(r) {
    const { data: e, compare: n } = this, i = this.length >> 1, s = e[r];
    for (; r < i; ) {
      let o = (r << 1) + 1, a = e[o];
      const u = o + 1;
      if (u < this.length && n(e[u], a) < 0 && (o = u, a = e[u]), n(a, s) >= 0) break;
      e[r] = a, r = o;
    }
    e[r] = s;
  }
}
function Km(t, r) {
  return t < r ? -1 : t > r ? 1 : 0;
}
function Xu(t, r) {
  return t.p.x > r.p.x ? 1 : t.p.x < r.p.x ? -1 : t.p.y !== r.p.y ? t.p.y > r.p.y ? 1 : -1 : 1;
}
function Qm(t, r) {
  return t.rightSweepEvent.p.x > r.rightSweepEvent.p.x ? 1 : t.rightSweepEvent.p.x < r.rightSweepEvent.p.x ? -1 : t.rightSweepEvent.p.y !== r.rightSweepEvent.p.y ? t.rightSweepEvent.p.y < r.rightSweepEvent.p.y ? 1 : -1 : 1;
}
class $a {
  constructor(r, e, n, i) {
    this.p = {
      x: r[0],
      y: r[1]
    }, this.featureId = e, this.ringId = n, this.eventId = i, this.otherEvent = null, this.isLeftEndpoint = null;
  }
  isSamePoint(r) {
    return this.p.x === r.p.x && this.p.y === r.p.y;
  }
}
function e1(t, r) {
  if (t.type === "FeatureCollection") {
    const e = t.features;
    for (let n = 0; n < e.length; n++)
      ja(e[n], r);
  } else
    ja(t, r);
}
let Bn = 0, Nn = 0, Un = 0;
function ja(t, r) {
  const e = t.type === "Feature" ? t.geometry : t;
  let n = e.coordinates;
  (e.type === "Polygon" || e.type === "MultiLineString") && (n = [n]), e.type === "LineString" && (n = [[n]]);
  for (let i = 0; i < n.length; i++)
    for (let s = 0; s < n[i].length; s++) {
      let o = n[i][s][0], a = null;
      Nn = Nn + 1;
      for (let u = 0; u < n[i][s].length - 1; u++) {
        a = n[i][s][u + 1];
        const l = new $a(o, Bn, Nn, Un), c = new $a(a, Bn, Nn, Un + 1);
        l.otherEvent = c, c.otherEvent = l, Xu(l, c) > 0 ? (c.isLeftEndpoint = !0, l.isLeftEndpoint = !1) : (l.isLeftEndpoint = !0, c.isLeftEndpoint = !1), r.push(l), r.push(c), o = a, Un = Un + 1;
      }
    }
  Bn = Bn + 1;
}
let t1 = class {
  constructor(r) {
    this.leftSweepEvent = r, this.rightSweepEvent = r.otherEvent;
  }
};
function r1(t, r) {
  if (t === null || r === null || t.leftSweepEvent.ringId === r.leftSweepEvent.ringId && (t.rightSweepEvent.isSamePoint(r.leftSweepEvent) || t.rightSweepEvent.isSamePoint(r.leftSweepEvent) || t.rightSweepEvent.isSamePoint(r.rightSweepEvent) || t.leftSweepEvent.isSamePoint(r.leftSweepEvent) || t.leftSweepEvent.isSamePoint(r.rightSweepEvent))) return !1;
  const e = t.leftSweepEvent.p.x, n = t.leftSweepEvent.p.y, i = t.rightSweepEvent.p.x, s = t.rightSweepEvent.p.y, o = r.leftSweepEvent.p.x, a = r.leftSweepEvent.p.y, u = r.rightSweepEvent.p.x, l = r.rightSweepEvent.p.y, c = (l - a) * (i - e) - (u - o) * (s - n), h = (u - o) * (n - a) - (l - a) * (e - o), d = (i - e) * (n - a) - (s - n) * (e - o);
  if (c === 0)
    return !1;
  const v = h / c, M = d / c;
  if (v >= 0 && v <= 1 && M >= 0 && M <= 1) {
    const A = e + v * (i - e), P = n + v * (s - n);
    return [A, P];
  }
  return !1;
}
function n1(t, r) {
  r = r || !1;
  const e = [], n = new Zu([], Qm);
  for (; t.length; ) {
    const i = t.pop();
    if (i.isLeftEndpoint) {
      const s = new t1(i);
      for (let o = 0; o < n.data.length; o++) {
        const a = n.data[o];
        if (r && a.leftSweepEvent.featureId === i.featureId)
          continue;
        const u = r1(s, a);
        u !== !1 && e.push(u);
      }
      n.push(s);
    } else i.isLeftEndpoint === !1 && n.pop();
  }
  return e;
}
function i1(t, r) {
  const e = new Zu([], Xu);
  return e1(t, e), n1(e, r);
}
var s1 = i1;
function _n(t, r, e = {}) {
  const { removeDuplicates: n = !0, ignoreSelfIntersections: i = !0 } = e;
  let s = [];
  t.type === "FeatureCollection" ? s = s.concat(t.features) : t.type === "Feature" ? s.push(t) : (t.type === "LineString" || t.type === "Polygon" || t.type === "MultiLineString" || t.type === "MultiPolygon") && s.push(dt(t)), r.type === "FeatureCollection" ? s = s.concat(r.features) : r.type === "Feature" ? s.push(r) : (r.type === "LineString" || r.type === "Polygon" || r.type === "MultiLineString" || r.type === "MultiPolygon") && s.push(dt(r));
  const o = s1(
    Me(s),
    i
  );
  let a = [];
  if (n) {
    const u = {};
    o.forEach((l) => {
      const c = l.join(",");
      u[c] || (u[c] = !0, a.push(l));
    });
  } else
    a = o;
  return Me(a.map((u) => Rt(u)));
}
var o1 = _n;
function Oi(t) {
  if (!t)
    throw new Error("geojson is required");
  switch (t.type) {
    case "Feature":
      return Ku(t);
    case "FeatureCollection":
      return a1(t);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return Ao(t);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function Ku(t) {
  const r = { type: "Feature" };
  return Object.keys(t).forEach((e) => {
    switch (e) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        r[e] = t[e];
    }
  }), r.properties = Qu(t.properties), t.geometry == null ? r.geometry = null : r.geometry = Ao(t.geometry), r;
}
function Qu(t) {
  const r = {};
  return t && Object.keys(t).forEach((e) => {
    const n = t[e];
    typeof n == "object" ? n === null ? r[e] = null : Array.isArray(n) ? r[e] = n.map((i) => i) : r[e] = Qu(n) : r[e] = n;
  }), r;
}
function a1(t) {
  const r = { type: "FeatureCollection" };
  return Object.keys(t).forEach((e) => {
    switch (e) {
      case "type":
      case "features":
        return;
      default:
        r[e] = t[e];
    }
  }), r.features = t.features.map((e) => Ku(e)), r;
}
function Ao(t) {
  const r = { type: t.type };
  return t.bbox && (r.bbox = t.bbox), t.type === "GeometryCollection" ? (r.geometries = t.geometries.map((e) => Ao(e)), r) : (r.coordinates = ec(t.coordinates), r);
}
function ec(t) {
  const r = t;
  return typeof r[0] != "object" ? r.slice() : r.map((e) => ec(e));
}
var tc = Oi;
function Ds(t) {
  const r = He(t);
  let e = 0, n = 1, i, s;
  for (; n < r.length; )
    i = s || r[0], s = r[n], e += (s[0] - i[0]) * (s[1] + i[1]), n++;
  return e > 0;
}
function l1(t, r = {}) {
  var e, n;
  if (r = r || {}, !oo(r)) throw new Error("options is invalid");
  const i = (e = r.mutate) != null ? e : !1, s = (n = r.reverse) != null ? n : !1;
  if (!t) throw new Error("<geojson> is required");
  if (typeof s != "boolean")
    throw new Error("<reverse> must be a boolean");
  if (typeof i != "boolean")
    throw new Error("<mutate> must be a boolean");
  !i && t.type !== "Point" && t.type !== "MultiPoint" && (t = Oi(t));
  const o = [];
  switch (t.type) {
    case "GeometryCollection":
      return yn(t, function(a) {
        Xn(a, s);
      }), t;
    case "FeatureCollection":
      return Ut(t, function(a) {
        const u = Xn(a, s);
        Ut(u, function(l) {
          o.push(l);
        });
      }), Me(o);
  }
  return Xn(t, s);
}
function Xn(t, r) {
  switch (t.type === "Feature" ? t.geometry.type : t.type) {
    case "GeometryCollection":
      return yn(t, function(n) {
        Xn(n, r);
      }), t;
    case "LineString":
      return Za(He(t), r), t;
    case "Polygon":
      return Xa(He(t), r), t;
    case "MultiLineString":
      return He(t).forEach(function(n) {
        Za(n, r);
      }), t;
    case "MultiPolygon":
      return He(t).forEach(function(n) {
        Xa(n, r);
      }), t;
    case "Point":
    case "MultiPoint":
      return t;
  }
}
function Za(t, r) {
  Ds(t) === r && t.reverse();
}
function Xa(t, r) {
  Ds(t[0]) !== r && t[0].reverse();
  for (let e = 1; e < t.length; e++)
    Ds(t[e]) === r && t[e].reverse();
}
var u1 = l1;
const c1 = ["Point", "MultiPoint"], f1 = [
  "LineString",
  "MultiLineString",
  "Polygon",
  "MultiPolygon"
], rc = (t) => c1.includes(t.geometry.type), Os = (t) => f1.includes(t.geometry.type), h1 = (t, r) => (bn(t, (e) => {
  const n = e.coordinate;
  n[0] += r.lng, n[1] += r.lat;
}), t), d1 = (t, r) => {
  const e = je(t.getGeoJson());
  return h1(e, r), e;
}, p1 = (t, r) => {
  try {
    bn(t, (e) => {
      if (!nr(e.coordinate, r))
        throw new Error("stop");
    });
  } catch {
    return !1;
  }
  return !0;
}, Ka = (t, r) => {
  const e = p1(t, r);
  return rc(t) ? e : e && Os(t) ? !o1(
    t,
    r,
    { ignoreSelfIntersections: !0 }
  ).features.length : !1;
}, Lo = (t) => {
  const r = t.getGeoJson();
  return typeof r != "object" ? null : qu(r);
}, g1 = (t) => {
  if (Os(t)) {
    const r = u1(t, { mutate: !1 });
    if (r.type === "Feature" && Os(r))
      return {
        ...r,
        properties: t.properties || {}
      };
  }
  return rc(t) ? t : null;
}, nc = [
  "click",
  "dblclick",
  "mousedown",
  "mouseup",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchcancel"
], m1 = [
  "load"
];
function is(t) {
  return nc.includes(t);
}
function $w(t) {
  return m1.includes(t);
}
const v1 = (t) => !!(t && typeof t == "object" && "once" in t && typeof t.once == "function"), ve = (t, r = { warning: !1 }) => {
  if (!t)
    return r.warning && N.warn("Empty event", t), !1;
  const e = typeof t == "object" && "lngLat" in t && "point" in t && "type" in t && "originalEvent" in t && typeof t.type == "string" && nc.includes(t.type);
  return !e && r.warning && N.warn("Not a pointer event", t), e;
}, O = {
  main: `${Y}_main`,
  temporary: `${Y}_temporary`,
  standby: `${Y}_standby`
}, xr = "_gmid";
class y1 {
  constructor(r) {
    w(this, "gm");
    w(this, "featureCounter", 0);
    w(this, "featureStore", /* @__PURE__ */ new Map());
    w(this, "featureStoreAllowedSources", [O.main, O.temporary]);
    w(this, "autoUpdatesEnabled", !0);
    w(this, "diffUpdatesEnabled", !0);
    w(this, "sources");
    w(this, "defaultSourceName", O.main);
    w(this, "updateStorage");
    w(this, "delayedSourceUpdateMethods");
    w(this, "layers");
    this.gm = r, this.sources = Object.fromEntries(
      Xr(O).map((e) => [e, null])
    ), this.updateStorage = Object.fromEntries(
      Xr(O).map((e) => [
        e,
        { add: [], remove: [], update: [] }
      ])
    ), this.delayedSourceUpdateMethods = Object.fromEntries(
      Xr(O).map((e) => [
        e,
        {
          throttled: this.getDelayedSourceUpdateMethod({
            sourceName: e,
            type: "throttled"
          }),
          debounced: this.getDelayedSourceUpdateMethod({
            sourceName: e,
            type: "debounced"
          })
        }
      ])
    ), this.layers = [];
  }
  init() {
    if (Object.values(this.sources).some((r) => r !== null)) {
      N.warn("features.init(): features are already initialized");
      return;
    }
    Re(this.sources).forEach((r) => {
      this.sources[r] = this.createSource(r);
    }), this.layers = this.createLayers();
  }
  get forEach() {
    return this.filteredForEach((r) => !r.temporary);
  }
  get tmpForEach() {
    return this.filteredForEach((r) => r.temporary);
  }
  getNewFeatureId() {
    return this.featureCounter += 1, `feature-${this.featureCounter}`;
  }
  filteredForEach(r) {
    return (e) => {
      this.featureStore.forEach((n, i, s) => {
        r(n) && e(n, i, s);
      });
    };
  }
  has(r, e) {
    const n = this.featureStore.get(e);
    return !!n && (n == null ? void 0 : n.source) === this.sources[r];
  }
  get(r, e) {
    const n = this.featureStore.get(e) || null;
    return (n == null ? void 0 : n.source) === this.sources[r] ? n : null;
  }
  add(r) {
    if (this.featureStore.has(r.id)) {
      N.error(`features.add: feature with the id "${r.id}" already exists`);
      return;
    }
    this.featureStoreAllowedSources.includes(r.source.id) && this.featureStore.set(r.id, r);
  }
  setDefaultSourceName(r) {
    this.defaultSourceName = r;
  }
  getDelayedSourceUpdateMethod({ sourceName: r, type: e }) {
    if (e === "throttled")
      return Ou(
        () => this.updateSourceByStorage(r),
        2 * this.gm.options.settings.throttlingDelay,
        { leading: !1, trailing: !0 }
      );
    if (e === "debounced")
      return wo(
        () => this.updateSourceByStorage(r),
        2 * this.gm.options.settings.throttlingDelay,
        { leading: !0, trailing: !1 }
      );
    throw new Error("Features: getDelayedSourceUpdateMethod: invalid type");
  }
  updateSourceByStorage(r) {
    const e = this.sources[r], n = this.updateStorage[r], i = Object.values(n).some((s) => s.length);
    e && i && (e.updateData(n), this.resetDiffStorage(r));
  }
  resetDiffStorage(r) {
    const e = this.updateStorage[r];
    e.add = [], e.remove = [], e.update = [];
  }
  withAtomicSourcesUpdate(r) {
    try {
      return this.autoUpdatesEnabled = !1, r();
    } finally {
      Xr(O).forEach((e) => {
        this.updateSourceByStorage(e);
      }), this.autoUpdatesEnabled = !0;
    }
  }
  updateSourceData({ diff: r, sourceName: e }) {
    this.gm.features.diffUpdatesEnabled ? this.updateSourceDataWithDiff({ diff: r, sourceName: e }) : this.setSourceData({ diff: r, sourceName: e });
  }
  updateSourceDataWithDiff({ diff: r, sourceName: e }) {
    const n = this.updateStorage[e];
    r.add && (n.add = n.add.concat(r.add)), r.update && (n.update = n.update.concat(r.update)), r.remove && (n.remove = n.remove.concat(r.remove)), this.gm.features.autoUpdatesEnabled && (this.delayedSourceUpdateMethods[e].throttled(), this.delayedSourceUpdateMethods[e].debounced());
  }
  setSourceData({ sourceName: r }) {
    N.warn("Review this Features.setSourceData() method");
    const e = this.getSourceGeoJson(r);
    e.features = e.features.filter((n) => !!n), this.setSourceGeoJson({ geoJson: e, sourceName: r });
  }
  createSource(r) {
    const e = this.gm.mapAdapter.addSource(
      r,
      {
        type: "FeatureCollection",
        features: []
      }
    );
    if (e)
      return e;
    throw new Error(`Features: failed to create the source: "${r}"`);
  }
  delete(r) {
    let e;
    r instanceof ui ? e = r : e = this.featureStore.get(r) || null, e ? (e.removeMarkers(), e.removeGeoJson(), this.featureStore.delete(e.id)) : N.error(`features.delete: feature "${r}" not found`);
  }
  getFeatureByMouseEvent({ event: r, sourceNames: e }) {
    if (!ve(r, { warning: !0 }))
      return null;
    const n = [r.point.x, r.point.y], i = this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: n,
      sourceNames: e
    });
    return i.length ? i[0] : null;
  }
  getFeaturesByGeoJsonBounds({ geoJson: r, sourceNames: e }) {
    const n = Mo(r), i = this.gm.mapAdapter.coordBoundsToScreenBounds(n);
    return this.getFeaturesByScreenBounds({ bounds: i, sourceNames: e });
  }
  getFeaturesByScreenBounds({ bounds: r, sourceNames: e }) {
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: r,
      sourceNames: e
    });
  }
  createFeature({ featureId: r, shapeGeoJson: e, parent: n, sourceName: i, imported: s }) {
    const o = this.sources[i];
    if (!o)
      return N.error("Features.createFeature Missing source for feature creation"), null;
    const a = r || e.properties[xr] || this.getNewFeatureId();
    if (this.featureStore.get(a))
      return N.error(
        `Features.createFeature: feature with the id "${a}" already exists`,
        this.featureStore.get(a)
      ), null;
    const u = new ui({
      gm: this.gm,
      id: a,
      parent: n || null,
      source: o,
      geoJsonShapeFeature: je(e)
    });
    return this.add(u), !u.temporary && !s && this.fireFeatureCreatedEvent(u), this.featureCounter += 1, u;
  }
  importGeoJson(r) {
    const e = "features" in r ? r.features : [r], n = {
      stats: {
        total: 0,
        success: 0,
        failed: 0
      },
      addedFeatures: []
    };
    return e.forEach((i) => {
      let s = null;
      n.stats.total += 1;
      const o = g1(i);
      o && (s = this.importGeoJsonFeature(o)), s ? (n.addedFeatures.push(s), n.stats.success += 1) : n.stats.failed += 1;
    }), n;
  }
  importGeoJsonFeature(r) {
    const e = this.defaultSourceName, n = this.getFeatureShapeByGeoJson(r);
    if (!n)
      return N.error("features.addGeoJsonFeature: unknown shape", n), null;
    const i = r.id || `${e}-feature-${this.featureCounter}`;
    return this.createFeature({
      featureId: r.id,
      shapeGeoJson: {
        ...r,
        properties: {
          ...r.properties,
          [xr]: i,
          shape: n
        }
      },
      sourceName: e,
      imported: !0
    });
  }
  getAll() {
    return this.exportGeoJson();
  }
  exportGeoJson() {
    return this.asGeoJsonFeatureCollection({
      sourceNames: [O.main, O.standby]
    });
  }
  getSourceGeoJson(r) {
    const e = this.sources[r];
    if (!e)
      throw new Error(`getSourceGeoJson: missing source "${r}"`);
    return e.getGeoJson();
  }
  setSourceGeoJson({ geoJson: r, sourceName: e }) {
    const n = this.sources[e];
    if (!n)
      throw new Error(`setSourceGeoJson: missing source "${e}"`);
    n.setGeoJson(r);
  }
  asGeoJsonFeatureCollection({ shapeTypes: r, sourceNames: e }) {
    const n = {
      type: "FeatureCollection",
      features: []
    };
    return e.forEach((i) => {
      const s = this.sources[i];
      s && s.getGeoJson().features.filter((a) => !!a).forEach((a) => {
        (r === void 0 || r.includes(a.properties.shape)) && n.features.push(a);
      });
    }), n;
  }
  convertSourceToGm(r) {
    const e = [], n = r.getGeoJson();
    return ("features" in n ? n.features : [n]).forEach((o) => {
      const a = this.addGeoJsonFeature({
        shapeGeoJson: o,
        defaultSource: !0
      });
      a && e.push(a);
    }), this.gm.mapAdapter.getSource(r.id).remove({ removeLayers: !0 }), e;
  }
  addGeoJsonFeature({ shapeGeoJson: r, sourceName: e, defaultSource: n }) {
    let i;
    if (n ? (i = this.defaultSourceName, e && N.warn("features.addGeoJsonFeature: default source is set, sourceName is ignored")) : i = e || null, !i)
      return N.error("features.addGeoJsonFeature: missing sourceName"), null;
    const s = this.getFeatureShapeByGeoJson(r);
    return s ? this.createFeature({
      featureId: r.id,
      shapeGeoJson: {
        ...r,
        properties: { ...r.properties, shape: s }
      },
      sourceName: i
    }) : (N.error("features.addGeoJsonFeature: unknown shape", s), null);
  }
  createLayers() {
    const r = [];
    return Re(this.gm.options.layerStyles).forEach((e) => {
      Re(this.gm.options.layerStyles[e]).forEach((n) => {
        this.gm.options.layerStyles[e][n].forEach((s) => {
          const o = this.createGenericLayer({
            layerId: `${n}-${e}-${s.type}-layer`,
            partialStyle: s,
            shape: e,
            sourceName: n
          });
          o && r.push(o);
        });
      });
    }), r;
  }
  createGenericLayer({ layerId: r, sourceName: e, partialStyle: n, shape: i }) {
    const s = {
      ...n,
      id: r,
      source: e,
      filter: [
        "in",
        ["get", "shape"],
        ["literal", [i]]
      ]
    };
    return this.gm.mapAdapter.addLayer(s);
  }
  getFeatureShapeByGeoJson(r) {
    const e = {
      Point: "marker",
      LineString: "line",
      Polygon: "polygon",
      MultiPolygon: "polygon"
    }, n = r.properties;
    return n != null && n.shape && ci.includes(n == null ? void 0 : n.shape) ? n == null ? void 0 : n.shape : e[r.geometry.type] || null;
  }
  createMarkerFeature({ parentFeature: r, coordinate: e, type: n, sourceName: i }) {
    return this.createFeature({
      sourceName: i,
      parent: r,
      shapeGeoJson: {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: e
        },
        properties: {
          shape: `${n}_marker`
        }
      }
    });
  }
  updateMarkerFeaturePosition(r, e) {
    r.updateGeoJsonGeometry({
      type: "Point",
      coordinates: e
    });
  }
  fireFeatureCreatedEvent(r) {
    if (Kt(r.shape, ci)) {
      const e = {
        level: "system",
        type: "draw",
        mode: r.shape,
        action: "feature_created",
        featureData: r
      };
      this.gm.events.fire(`${Y}:draw`, e);
    }
  }
}
const ss = (t) => [
  {
    type: "circle",
    paint: {
      "circle-radius": t.circleMarkerRadius,
      "circle-color": t.fillColor,
      "circle-opacity": t.fillOpacity,
      "circle-stroke-color": t.lineColor,
      "circle-stroke-width": t.lineWidth,
      "circle-stroke-opacity": t.lineOpacity
    }
  }
], pr = (t) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 7,
      "circle-color": "#ffffff",
      "circle-opacity": 1,
      "circle-stroke-color": t.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
], os = (t) => [
  {
    type: "line",
    paint: {
      "line-color": t.lineColor,
      "line-opacity": t.lineOpacity,
      "line-width": t.lineWidth
    }
  }
], as = () => [
  {
    type: "symbol",
    layout: {
      "icon-image": "default-marker",
      "icon-size": 0.18,
      "icon-allow-overlap": !0,
      "icon-anchor": "bottom"
    }
  }
], Et = (t) => [
  {
    type: "fill",
    paint: {
      "fill-color": t.fillColor,
      "fill-opacity": t.fillOpacity
    }
  },
  {
    type: "line",
    paint: {
      "line-color": t.lineColor,
      "line-opacity": t.lineOpacity,
      "line-width": t.lineWidth
    }
  }
], ls = (t) => [
  {
    type: "circle",
    paint: {
      "circle-radius": 6,
      "circle-color": "#ffffff",
      "circle-opacity": 0.6,
      "circle-stroke-color": t.lineColor,
      "circle-stroke-width": 2,
      "circle-stroke-opacity": 1
    }
  }
], us = () => [
  {
    type: "line",
    paint: {
      "line-color": "#00979f",
      "line-width": 1.8,
      "line-dasharray": [2, 1]
    }
  }
], cs = () => [
  {
    type: "symbol",
    layout: {
      "text-field": ["get", "text"],
      "text-justify": "center"
    },
    paint: {
      "text-color": "black",
      "text-halo-color": "#fff",
      "text-halo-width": 2
    }
  }
], ce = {
  [O.main]: {
    lineColor: "#278cda",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  [O.temporary]: {
    lineColor: "#ff5600",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#4fb3ff",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  },
  [O.standby]: {
    lineColor: "#787878",
    lineOpacity: 0.8,
    lineWidth: 3,
    fillColor: "#a5a5a5",
    fillOpacity: 0.4,
    circleMarkerRadius: 10
  }
}, w1 = {
  line: {
    [O.main]: os(ce[O.main]),
    [O.temporary]: os(ce[O.temporary]),
    [O.standby]: os(ce[O.standby])
  },
  circle: {
    [O.main]: Et(ce[O.main]),
    [O.temporary]: Et(ce[O.temporary]),
    [O.standby]: Et(ce[O.standby])
  },
  rectangle: {
    [O.main]: Et(ce[O.main]),
    [O.temporary]: Et(ce[O.temporary]),
    [O.standby]: Et(ce[O.standby])
  },
  polygon: {
    [O.main]: Et(ce[O.main]),
    [O.temporary]: Et(ce[O.temporary]),
    [O.standby]: Et(ce[O.standby])
  },
  marker: {
    [O.temporary]: as(),
    [O.main]: as(),
    [O.standby]: as()
  },
  circle_marker: {
    [O.main]: ss(ce[O.main]),
    [O.temporary]: ss(ce[O.temporary]),
    [O.standby]: ss(ce[O.standby])
  },
  text_marker: {
    [O.main]: cs(),
    [O.temporary]: cs(),
    [O.standby]: cs()
  },
  dom_marker: {
    // not a geojson source, layers aren't required
    [O.main]: [],
    [O.temporary]: [],
    [O.standby]: []
  },
  center_marker: {
    [O.main]: pr(ce[O.main]),
    [O.temporary]: pr(ce[O.temporary]),
    [O.standby]: pr(ce[O.standby])
  },
  vertex_marker: {
    [O.main]: pr(ce[O.main]),
    [O.temporary]: pr(ce[O.temporary]),
    [O.standby]: pr(ce[O.standby])
  },
  edge_marker: {
    [O.main]: ls(ce[O.main]),
    [O.temporary]: ls(ce[O.temporary]),
    [O.standby]: ls(ce[O.standby])
  },
  snap_guide: {
    // todo: check which sources can't display snap guides (and other shapes) and remove layers
    [O.main]: us(),
    [O.temporary]: us(),
    [O.standby]: us()
  }
}, fi = {
  type: "Feature",
  properties: {
    shape: "polygon"
  },
  geometry: {
    type: "MultiPolygon",
    coordinates: [
      [
        [
          [
            4,
            51.2
          ],
          [
            5.4,
            52.4
          ],
          [
            6.8,
            51.2
          ],
          [
            4,
            51.2
          ]
        ]
      ]
    ]
  }
}, ic = {
  type: "Feature",
  properties: {
    shape: "rectangle"
  },
  geometry: {
    type: "Polygon",
    coordinates: [
      [
        [
          -0.47,
          51.67
        ],
        [
          1.43,
          51.67
        ],
        [
          1.43,
          53.32
        ],
        [
          -0.47,
          53.32
        ],
        [
          -0.47,
          51.67
        ]
      ]
    ]
  }
}, E1 = {
  settings: {
    throttlingDelay: 10,
    controlsPosition: "top-left"
  },
  layerStyles: w1,
  controls: {
    draw: {
      marker: {
        title: "Marker",
        icon: te.marker,
        uiEnabled: !0,
        active: !1
      },
      circle_marker: {
        title: "Circle Marker",
        icon: te.circle_marker,
        uiEnabled: !0,
        active: !1
      },
      text_marker: {
        title: "Text Marker",
        icon: te.text_marker,
        uiEnabled: !0,
        active: !1
      },
      circle: {
        title: "Circle",
        icon: te.circle,
        uiEnabled: !0,
        active: !1
      },
      line: {
        title: "Line",
        icon: te.line,
        uiEnabled: !0,
        active: !1
      },
      rectangle: {
        title: "Rectangle",
        icon: te.rectangle,
        uiEnabled: !0,
        active: !1
      },
      polygon: {
        title: "Polygon",
        icon: te.polygon,
        uiEnabled: !0,
        active: !1
      },
      freehand: {
        title: "Freehand",
        icon: te.freehand,
        uiEnabled: !1,
        active: !1
      },
      custom_shape: {
        title: "Custom shape",
        icon: te.custom_shape,
        uiEnabled: !1,
        active: !1,
        options: [{
          type: "select",
          label: "Shape",
          name: "shape",
          value: { title: "Triangle", value: JSON.stringify(fi) },
          choices: [
            { title: "Triangle", value: JSON.stringify(fi) },
            { title: "Rectangle", value: JSON.stringify(ic) }
          ]
        }]
      }
    },
    edit: {
      drag: {
        title: "Drag",
        icon: te.drag,
        uiEnabled: !0,
        active: !1
      },
      change: {
        title: "Change",
        icon: te.change,
        uiEnabled: !0,
        active: !1
      },
      rotate: {
        title: "Rotate",
        icon: te.rotate,
        uiEnabled: !0,
        active: !1
      },
      scale: {
        title: "Scale",
        icon: te.scale,
        uiEnabled: !1,
        active: !1
      },
      copy: {
        title: "Copy",
        icon: te.copy,
        uiEnabled: !1,
        active: !1
      },
      cut: {
        title: "Cut",
        icon: te.cut,
        uiEnabled: !0,
        active: !1
      },
      split: {
        title: "Split",
        icon: te.split,
        uiEnabled: !1,
        active: !1
      },
      union: {
        title: "Union",
        icon: te.union,
        uiEnabled: !1,
        active: !1
      },
      difference: {
        title: "Difference",
        icon: te.difference,
        uiEnabled: !1,
        active: !1
      },
      line_simplification: {
        title: "Line simplification",
        icon: te.line_simplification,
        uiEnabled: !1,
        active: !1
      },
      lasso: {
        title: "Lasso select",
        icon: te.lasso,
        uiEnabled: !1,
        active: !1
      },
      delete: {
        title: "Delete",
        icon: te.delete,
        uiEnabled: !0,
        active: !1
      }
    },
    helper: {
      shape_markers: {
        title: "Shape markers",
        icon: null,
        uiEnabled: !0,
        active: !1
      },
      snapping: {
        title: "Snapping",
        icon: te.snapping,
        uiEnabled: !0,
        active: !1
      },
      pin: {
        title: "Pin",
        icon: te.pin,
        uiEnabled: !1,
        active: !1
      },
      snap_guides: {
        title: "Snap guides",
        icon: te.snap_guides,
        uiEnabled: !1,
        active: !1
      },
      measurements: {
        title: "Measurements",
        icon: te.measurements,
        uiEnabled: !1,
        active: !1
      },
      auto_trace: {
        title: "Auto trace line",
        icon: te.auto_trace,
        uiEnabled: !1,
        active: !1
      },
      geofencing: {
        title: "Geofencing",
        icon: te.geofencing,
        uiEnabled: !1,
        active: !1
      },
      zoom_to_features: {
        title: "Zoom to features",
        icon: te.zoom_to_features,
        uiEnabled: !0,
        active: !1
      },
      click_to_edit: {
        title: "Click to edit",
        icon: te.click_to_edit,
        uiEnabled: !1,
        active: !1
      }
    }
  }
};
JSON.stringify(fi), JSON.stringify(fi), JSON.stringify(ic);
const sc = () => je(E1), Qa = !1;
var Co = Array.isArray, M1 = Array.prototype.indexOf, ko = Array.from, oc = Object.defineProperty, an = Object.getOwnPropertyDescriptor, ac = Object.getOwnPropertyDescriptors, b1 = Object.prototype, x1 = Array.prototype, To = Object.getPrototypeOf;
const _r = () => {
};
function _1(t) {
  return t();
}
function Gs(t) {
  for (var r = 0; r < t.length; r++)
    t[r]();
}
const rt = 2, lc = 4, Gi = 8, Po = 16, It = 32, Sn = 64, hi = 128, We = 256, di = 512, Te = 1024, Ft = 2048, Fr = 4096, At = 8192, Ri = 16384, S1 = 32768, Io = 65536, A1 = 1 << 19, uc = 1 << 20, Qt = Symbol("$state"), L1 = Symbol("");
let pi = [];
function C1() {
  var t = pi;
  pi = [], Gs(t);
}
function k1(t) {
  pi.length === 0 && queueMicrotask(C1), pi.push(t);
}
function cc(t) {
  return t === this.v;
}
function fc(t, r) {
  return t != t ? r == r : t !== r || t !== null && typeof t == "object" || typeof t == "function";
}
function hc(t) {
  return !fc(t, this.v);
}
function T1(t) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function P1() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function I1(t) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function F1() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function D1() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function O1() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function G1() {
  throw new Error("https://svelte.dev/e/state_unsafe_local_read");
}
function R1() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
let An = !1, B1 = !1;
function N1() {
  An = !0;
}
const Fo = 1, Do = 2, dc = 4, U1 = 8, H1 = 16, z1 = 1, J1 = 2, Oe = Symbol();
function Oo(t) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
let re = null;
function el(t) {
  re = t;
}
function Go(t) {
  return (
    /** @type {T} */
    q1().get(t)
  );
}
function Dr(t, r = !1, e) {
  re = {
    p: re,
    c: null,
    e: null,
    m: !1,
    s: t,
    x: null,
    l: null
  }, An && !r && (re.l = {
    s: null,
    u: null,
    r1: [],
    r2: Ue(!1)
  });
}
function Or(t) {
  const r = re;
  if (r !== null) {
    const o = r.e;
    if (o !== null) {
      var e = se, n = ie;
      r.e = null;
      try {
        for (var i = 0; i < o.length; i++) {
          var s = o[i];
          Vt(s.effect), qt(s.reaction), Ji(s.fn);
        }
      } finally {
        Vt(e), qt(n);
      }
    }
    re = r.p, r.m = !0;
  }
  return (
    /** @type {T} */
    {}
  );
}
function Bi() {
  return !An || re !== null && re.l === null;
}
function q1(t) {
  return re === null && Oo(), re.c ?? (re.c = new Map(V1(re) || void 0));
}
function V1(t) {
  let r = t.p;
  for (; r !== null; ) {
    const e = r.c;
    if (e !== null)
      return e;
    r = r.p;
  }
  return null;
}
function Ue(t, r) {
  var e = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: t,
    reactions: null,
    equals: cc,
    rv: 0,
    wv: 0
  };
  return e;
}
function pc(t) {
  return /* @__PURE__ */ gc(Ue(t));
}
// @__NO_SIDE_EFFECTS__
function Ro(t, r = !1) {
  var n;
  const e = Ue(t);
  return r || (e.equals = hc), An && re !== null && re.l !== null && ((n = re.l).s ?? (n.s = [])).push(e), e;
}
function Y1(t, r = !1) {
  return /* @__PURE__ */ gc(/* @__PURE__ */ Ro(t, r));
}
// @__NO_SIDE_EFFECTS__
function gc(t) {
  return ie !== null && !et && (ie.f & rt) !== 0 && (ht === null ? Q1([t]) : ht.push(t)), t;
}
function Ee(t, r) {
  return ie !== null && !et && Bi() && (ie.f & (rt | Po)) !== 0 && // If the source was created locally within the current derived, then
  // we allow the mutation.
  (ht === null || !ht.includes(t)) && R1(), Rs(t, r);
}
function Rs(t, r) {
  return t.equals(r) || (t.v, t.v = r, t.wv = _c(), mc(t, Ft), Bi() && se !== null && (se.f & Te) !== 0 && (se.f & (It | Sn)) === 0 && (xt === null ? ev([t]) : xt.push(t))), r;
}
function mc(t, r) {
  var e = t.reactions;
  if (e !== null)
    for (var n = Bi(), i = e.length, s = 0; s < i; s++) {
      var o = e[s], a = o.f;
      (a & Ft) === 0 && (!n && o === se || (gt(o, r), (a & (Te | We)) !== 0 && ((a & rt) !== 0 ? mc(
        /** @type {Derived} */
        o,
        Fr
      ) : zi(
        /** @type {Effect} */
        o
      ))));
    }
}
// @__NO_SIDE_EFFECTS__
function Bo(t) {
  var r = rt | Ft, e = ie !== null && (ie.f & rt) !== 0 ? (
    /** @type {Derived} */
    ie
  ) : null;
  return se === null || e !== null && (e.f & We) !== 0 ? r |= We : se.f |= uc, {
    ctx: re,
    deps: null,
    effects: null,
    equals: cc,
    f: r,
    fn: t,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      null
    ),
    wv: 0,
    parent: e ?? se
  };
}
// @__NO_SIDE_EFFECTS__
function vc(t) {
  const r = /* @__PURE__ */ Bo(t);
  return r.equals = hc, r;
}
function yc(t) {
  var r = t.effects;
  if (r !== null) {
    t.effects = null;
    for (var e = 0; e < r.length; e += 1)
      Lt(
        /** @type {Effect} */
        r[e]
      );
  }
}
function W1(t) {
  for (var r = t.parent; r !== null; ) {
    if ((r.f & rt) === 0)
      return (
        /** @type {Effect} */
        r
      );
    r = r.parent;
  }
  return null;
}
function $1(t) {
  var r, e = se;
  Vt(W1(t));
  try {
    yc(t), r = Ac(t);
  } finally {
    Vt(e);
  }
  return r;
}
function wc(t) {
  var r = $1(t), e = (Nt || (t.f & We) !== 0) && t.deps !== null ? Fr : Te;
  gt(t, e), t.equals(r) || (t.v = r, t.wv = _c());
}
let j1 = !1;
function ut(t, r = null, e) {
  if (typeof t != "object" || t === null || Qt in t)
    return t;
  const n = To(t);
  if (n !== b1 && n !== x1)
    return t;
  var i = /* @__PURE__ */ new Map(), s = Co(t), o = Ue(0);
  s && i.set("length", Ue(
    /** @type {any[]} */
    t.length
  ));
  var a;
  return new Proxy(
    /** @type {any} */
    t,
    {
      defineProperty(u, l, c) {
        (!("value" in c) || c.configurable === !1 || c.enumerable === !1 || c.writable === !1) && D1();
        var h = i.get(l);
        return h === void 0 ? (h = Ue(c.value), i.set(l, h)) : Ee(h, ut(c.value, a)), !0;
      },
      deleteProperty(u, l) {
        var c = i.get(l);
        if (c === void 0)
          l in u && i.set(l, Ue(Oe));
        else {
          if (s && typeof l == "string") {
            var h = (
              /** @type {Source<number>} */
              i.get("length")
            ), d = Number(l);
            Number.isInteger(d) && d < h.v && Ee(h, d);
          }
          Ee(c, Oe), tl(o);
        }
        return !0;
      },
      get(u, l, c) {
        var M;
        if (l === Qt)
          return t;
        var h = i.get(l), d = l in u;
        if (h === void 0 && (!d || (M = an(u, l)) != null && M.writable) && (h = Ue(ut(d ? u[l] : Oe, a)), i.set(l, h)), h !== void 0) {
          var v = Q(h);
          return v === Oe ? void 0 : v;
        }
        return Reflect.get(u, l, c);
      },
      getOwnPropertyDescriptor(u, l) {
        var c = Reflect.getOwnPropertyDescriptor(u, l);
        if (c && "value" in c) {
          var h = i.get(l);
          h && (c.value = Q(h));
        } else if (c === void 0) {
          var d = i.get(l), v = d == null ? void 0 : d.v;
          if (d !== void 0 && v !== Oe)
            return {
              enumerable: !0,
              configurable: !0,
              value: v,
              writable: !0
            };
        }
        return c;
      },
      has(u, l) {
        var v;
        if (l === Qt)
          return !0;
        var c = i.get(l), h = c !== void 0 && c.v !== Oe || Reflect.has(u, l);
        if (c !== void 0 || se !== null && (!h || (v = an(u, l)) != null && v.writable)) {
          c === void 0 && (c = Ue(h ? ut(u[l], a) : Oe), i.set(l, c));
          var d = Q(c);
          if (d === Oe)
            return !1;
        }
        return h;
      },
      set(u, l, c, h) {
        var D;
        var d = i.get(l), v = l in u;
        if (s && l === "length")
          for (var M = c; M < /** @type {Source<number>} */
          d.v; M += 1) {
            var A = i.get(M + "");
            A !== void 0 ? Ee(A, Oe) : M in u && (A = Ue(Oe), i.set(M + "", A));
          }
        d === void 0 ? (!v || (D = an(u, l)) != null && D.writable) && (d = Ue(void 0), Ee(d, ut(c, a)), i.set(l, d)) : (v = d.v !== Oe, Ee(d, ut(c, a)));
        var P = Reflect.getOwnPropertyDescriptor(u, l);
        if (P != null && P.set && P.set.call(h, c), !v) {
          if (s && typeof l == "string") {
            var C = (
              /** @type {Source<number>} */
              i.get("length")
            ), g = Number(l);
            Number.isInteger(g) && g >= C.v && Ee(C, g + 1);
          }
          tl(o);
        }
        return !0;
      },
      ownKeys(u) {
        Q(o);
        var l = Reflect.ownKeys(u).filter((d) => {
          var v = i.get(d);
          return v === void 0 || v.v !== Oe;
        });
        for (var [c, h] of i)
          h.v !== Oe && !(c in u) && l.push(c);
        return l;
      },
      setPrototypeOf() {
        O1();
      }
    }
  );
}
function tl(t, r = 1) {
  Ee(t, t.v + r);
}
function rl(t) {
  return t !== null && typeof t == "object" && Qt in t ? t[Qt] : t;
}
function Z1(t, r) {
  return Object.is(rl(t), rl(r));
}
var nl, Ec, Mc, bc;
function X1() {
  if (nl === void 0) {
    nl = window, Ec = /Firefox/.test(navigator.userAgent);
    var t = Element.prototype, r = Node.prototype;
    Mc = an(r, "firstChild").get, bc = an(r, "nextSibling").get, t.__click = void 0, t.__className = void 0, t.__attributes = null, t.__styles = null, t.__e = void 0, Text.prototype.__t = void 0;
  }
}
function Ni(t = "") {
  return document.createTextNode(t);
}
// @__NO_SIDE_EFFECTS__
function pn(t) {
  return Mc.call(t);
}
// @__NO_SIDE_EFFECTS__
function Ui(t) {
  return bc.call(t);
}
function Bt(t, r) {
  return /* @__PURE__ */ pn(t);
}
function Jt(t, r) {
  {
    var e = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ pn(
        /** @type {Node} */
        t
      )
    );
    return e instanceof Comment && e.data === "" ? /* @__PURE__ */ Ui(e) : e;
  }
}
function gi(t, r = 1, e = !1) {
  let n = t;
  for (; r--; )
    n = /** @type {TemplateNode} */
    /* @__PURE__ */ Ui(n);
  return n;
}
function K1(t) {
  t.textContent = "";
}
let Kn = !1, Bs = !1, mi = null, Qn = !1, No = !1;
function il(t) {
  No = t;
}
let ei = [];
let ie = null, et = !1;
function qt(t) {
  ie = t;
}
let se = null;
function Vt(t) {
  se = t;
}
let ht = null;
function Q1(t) {
  ht = t;
}
let Ce = null, Ne = 0, xt = null;
function ev(t) {
  xt = t;
}
let xc = 1, vi = 0, Nt = !1;
function _c() {
  return ++xc;
}
function Ln(t) {
  var h;
  var r = t.f;
  if ((r & Ft) !== 0)
    return !0;
  if ((r & Fr) !== 0) {
    var e = t.deps, n = (r & We) !== 0;
    if (e !== null) {
      var i, s, o = (r & di) !== 0, a = n && se !== null && !Nt, u = e.length;
      if (o || a) {
        var l = (
          /** @type {Derived} */
          t
        ), c = l.parent;
        for (i = 0; i < u; i++)
          s = e[i], (o || !((h = s == null ? void 0 : s.reactions) != null && h.includes(l))) && (s.reactions ?? (s.reactions = [])).push(l);
        o && (l.f ^= di), a && c !== null && (c.f & We) === 0 && (l.f ^= We);
      }
      for (i = 0; i < u; i++)
        if (s = e[i], Ln(
          /** @type {Derived} */
          s
        ) && wc(
          /** @type {Derived} */
          s
        ), s.wv > t.wv)
          return !0;
    }
    (!n || se !== null && !Nt) && gt(t, Te);
  }
  return !1;
}
function tv(t, r) {
  for (var e = r; e !== null; ) {
    if ((e.f & hi) !== 0)
      try {
        e.fn(t);
        return;
      } catch {
        e.f ^= hi;
      }
    e = e.parent;
  }
  throw Kn = !1, t;
}
function rv(t) {
  return (t.f & Ri) === 0 && (t.parent === null || (t.parent.f & hi) === 0);
}
function Hi(t, r, e, n) {
  if (Kn) {
    if (e === null && (Kn = !1), rv(r))
      throw t;
    return;
  }
  e !== null && (Kn = !0);
  {
    tv(t, r);
    return;
  }
}
function Sc(t, r, e = !0) {
  var n = t.reactions;
  if (n !== null)
    for (var i = 0; i < n.length; i++) {
      var s = n[i];
      (s.f & rt) !== 0 ? Sc(
        /** @type {Derived} */
        s,
        r,
        !1
      ) : r === s && (e ? gt(s, Ft) : (s.f & Te) !== 0 && gt(s, Fr), zi(
        /** @type {Effect} */
        s
      ));
    }
}
function Ac(t) {
  var v;
  var r = Ce, e = Ne, n = xt, i = ie, s = Nt, o = ht, a = re, u = et, l = t.f;
  Ce = /** @type {null | Value[]} */
  null, Ne = 0, xt = null, Nt = (l & We) !== 0 && (et || !Qn || ie === null), ie = (l & (It | Sn)) === 0 ? t : null, ht = null, el(t.ctx), et = !1, vi++;
  try {
    var c = (
      /** @type {Function} */
      (0, t.fn)()
    ), h = t.deps;
    if (Ce !== null) {
      var d;
      if (yi(t, Ne), h !== null && Ne > 0)
        for (h.length = Ne + Ce.length, d = 0; d < Ce.length; d++)
          h[Ne + d] = Ce[d];
      else
        t.deps = h = Ce;
      if (!Nt)
        for (d = Ne; d < h.length; d++)
          ((v = h[d]).reactions ?? (v.reactions = [])).push(t);
    } else h !== null && Ne < h.length && (yi(t, Ne), h.length = Ne);
    if (Bi() && xt !== null && !et && h !== null && (t.f & (rt | Fr | Ft)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      xt.length; d++)
        Sc(
          xt[d],
          /** @type {Effect} */
          t
        );
    return i !== null && vi++, c;
  } finally {
    Ce = r, Ne = e, xt = n, ie = i, Nt = s, ht = o, el(a), et = u;
  }
}
function nv(t, r) {
  let e = r.reactions;
  if (e !== null) {
    var n = M1.call(e, t);
    if (n !== -1) {
      var i = e.length - 1;
      i === 0 ? e = r.reactions = null : (e[n] = e[i], e.pop());
    }
  }
  e === null && (r.f & rt) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Ce === null || !Ce.includes(r)) && (gt(r, Fr), (r.f & (We | di)) === 0 && (r.f ^= di), yc(
    /** @type {Derived} **/
    r
  ), yi(
    /** @type {Derived} **/
    r,
    0
  ));
}
function yi(t, r) {
  var e = t.deps;
  if (e !== null)
    for (var n = r; n < e.length; n++)
      nv(t, e[n]);
}
function Uo(t) {
  var r = t.f;
  if ((r & Ri) === 0) {
    gt(t, Te);
    var e = se, n = re, i = Qn;
    se = t, Qn = !0;
    try {
      (r & Po) !== 0 ? pv(t) : Tc(t), kc(t);
      var s = Ac(t);
      t.teardown = typeof s == "function" ? s : null, t.wv = xc;
      var o = t.deps, a;
      Qa && B1 && t.f & Ft;
    } catch (u) {
      Hi(u, t, e, n || t.ctx);
    } finally {
      Qn = i, se = e;
    }
  }
}
function iv() {
  try {
    F1();
  } catch (t) {
    if (mi !== null)
      Hi(t, mi, null);
    else
      throw t;
  }
}
function sv() {
  try {
    for (var t = 0; ei.length > 0; ) {
      t++ > 1e3 && iv();
      var r = ei, e = r.length;
      ei = [];
      for (var n = 0; n < e; n++) {
        var i = r[n];
        (i.f & Te) === 0 && (i.f ^= Te);
        var s = av(i);
        ov(s);
      }
    }
  } finally {
    Bs = !1, mi = null;
  }
}
function ov(t) {
  var r = t.length;
  if (r !== 0)
    for (var e = 0; e < r; e++) {
      var n = t[e];
      if ((n.f & (Ri | At)) === 0)
        try {
          Ln(n) && (Uo(n), n.deps === null && n.first === null && n.nodes_start === null && (n.teardown === null ? Pc(n) : n.fn = null));
        } catch (i) {
          Hi(i, n, null, n.ctx);
        }
    }
}
function zi(t) {
  Bs || (Bs = !0, queueMicrotask(sv));
  for (var r = mi = t; r.parent !== null; ) {
    r = r.parent;
    var e = r.f;
    if ((e & (Sn | It)) !== 0) {
      if ((e & Te) === 0) return;
      r.f ^= Te;
    }
  }
  ei.push(r);
}
function av(t) {
  for (var r = [], e = t.first; e !== null; ) {
    var n = e.f, i = (n & It) !== 0, s = i && (n & Te) !== 0;
    if (!s && (n & At) === 0) {
      if ((n & lc) !== 0)
        r.push(e);
      else if (i)
        e.f ^= Te;
      else {
        var o = ie;
        try {
          ie = e, Ln(e) && Uo(e);
        } catch (l) {
          Hi(l, e, null, e.ctx);
        } finally {
          ie = o;
        }
      }
      var a = e.first;
      if (a !== null) {
        e = a;
        continue;
      }
    }
    var u = e.parent;
    for (e = e.next; e === null && u !== null; )
      e = u.next, u = u.parent;
  }
  return r;
}
function Q(t) {
  var r = t.f, e = (r & rt) !== 0;
  if (ie !== null && !et) {
    ht !== null && ht.includes(t) && G1();
    var n = ie.deps;
    t.rv < vi && (t.rv = vi, Ce === null && n !== null && n[Ne] === t ? Ne++ : Ce === null ? Ce = [t] : (!Nt || !Ce.includes(t)) && Ce.push(t));
  } else if (e && /** @type {Derived} */
  t.deps === null && /** @type {Derived} */
  t.effects === null) {
    var i = (
      /** @type {Derived} */
      t
    ), s = i.parent;
    s !== null && (s.f & We) === 0 && (i.f ^= We);
  }
  return e && (i = /** @type {Derived} */
  t, Ln(i) && wc(i)), t.v;
}
function Cn(t) {
  var r = et;
  try {
    return et = !0, t();
  } finally {
    et = r;
  }
}
const lv = -7169;
function gt(t, r) {
  t.f = t.f & lv | r;
}
function uv(t) {
  if (!(typeof t != "object" || !t || t instanceof EventTarget)) {
    if (Qt in t)
      Ns(t);
    else if (!Array.isArray(t))
      for (let r in t) {
        const e = t[r];
        typeof e == "object" && e && Qt in e && Ns(e);
      }
  }
}
function Ns(t, r = /* @__PURE__ */ new Set()) {
  if (typeof t == "object" && t !== null && // We don't want to traverse DOM elements
  !(t instanceof EventTarget) && !r.has(t)) {
    r.add(t), t instanceof Date && t.getTime();
    for (let n in t)
      try {
        Ns(t[n], r);
      } catch {
      }
    const e = To(t);
    if (e !== Object.prototype && e !== Array.prototype && e !== Map.prototype && e !== Set.prototype && e !== Date.prototype) {
      const n = ac(e);
      for (let i in n) {
        const s = n[i].get;
        if (s)
          try {
            s.call(t);
          } catch {
          }
      }
    }
  }
}
function Lc(t) {
  se === null && ie === null && I1(), ie !== null && (ie.f & We) !== 0 && se === null && P1(), No && T1();
}
function cv(t, r) {
  var e = r.last;
  e === null ? r.last = r.first = t : (e.next = t, t.prev = e, r.last = t);
}
function Gr(t, r, e, n = !0) {
  var i = (t & Sn) !== 0, s = se, o = {
    ctx: re,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: t | Ft,
    first: null,
    fn: r,
    last: null,
    next: null,
    parent: i ? null : s,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0
  };
  if (e)
    try {
      Uo(o), o.f |= S1;
    } catch (l) {
      throw Lt(o), l;
    }
  else r !== null && zi(o);
  var a = e && o.deps === null && o.first === null && o.nodes_start === null && o.teardown === null && (o.f & (uc | hi)) === 0;
  if (!a && !i && n && (s !== null && cv(o, s), ie !== null && (ie.f & rt) !== 0)) {
    var u = (
      /** @type {Derived} */
      ie
    );
    (u.effects ?? (u.effects = [])).push(o);
  }
  return o;
}
function fv(t) {
  const r = Gr(Gi, null, !1);
  return gt(r, Te), r.teardown = t, r;
}
function Us(t) {
  Lc();
  var r = se !== null && (se.f & It) !== 0 && re !== null && !re.m;
  if (r) {
    var e = (
      /** @type {ComponentContext} */
      re
    );
    (e.e ?? (e.e = [])).push({
      fn: t,
      effect: se,
      reaction: ie
    });
  } else {
    var n = Ji(t);
    return n;
  }
}
function hv(t) {
  return Lc(), Cc(t);
}
function dv(t) {
  const r = Gr(Sn, t, !0);
  return (e = {}) => new Promise((n) => {
    e.outro ? wi(r, () => {
      Lt(r), n(void 0);
    }) : (Lt(r), n(void 0));
  });
}
function Ji(t) {
  return Gr(lc, t, !1);
}
function Cc(t) {
  return Gr(Gi, t, !0);
}
function _t(t, r = [], e = Bo) {
  const n = r.map(e);
  return qi(() => t(...n.map(Q)));
}
function qi(t, r = 0) {
  return Gr(Gi | Po | r, t, !0);
}
function Tr(t, r = !0) {
  return Gr(Gi | It, t, !0, r);
}
function kc(t) {
  var r = t.teardown;
  if (r !== null) {
    const e = No, n = ie;
    il(!0), qt(null);
    try {
      r.call(null);
    } finally {
      il(e), qt(n);
    }
  }
}
function Tc(t, r = !1) {
  var e = t.first;
  for (t.first = t.last = null; e !== null; ) {
    var n = e.next;
    Lt(e, r), e = n;
  }
}
function pv(t) {
  for (var r = t.first; r !== null; ) {
    var e = r.next;
    (r.f & It) === 0 && Lt(r), r = e;
  }
}
function Lt(t, r = !0) {
  var e = !1;
  if ((r || (t.f & A1) !== 0) && t.nodes_start !== null) {
    for (var n = t.nodes_start, i = t.nodes_end; n !== null; ) {
      var s = n === i ? null : (
        /** @type {TemplateNode} */
        /* @__PURE__ */ Ui(n)
      );
      n.remove(), n = s;
    }
    e = !0;
  }
  Tc(t, r && !e), yi(t, 0), gt(t, Ri);
  var o = t.transitions;
  if (o !== null)
    for (const u of o)
      u.stop();
  kc(t);
  var a = t.parent;
  a !== null && a.first !== null && Pc(t), t.next = t.prev = t.teardown = t.ctx = t.deps = t.fn = t.nodes_start = t.nodes_end = null;
}
function Pc(t) {
  var r = t.parent, e = t.prev, n = t.next;
  e !== null && (e.next = n), n !== null && (n.prev = e), r !== null && (r.first === t && (r.first = n), r.last === t && (r.last = e));
}
function wi(t, r) {
  var e = [];
  Ho(t, e, !0), Ic(e, () => {
    Lt(t), r && r();
  });
}
function Ic(t, r) {
  var e = t.length;
  if (e > 0) {
    var n = () => --e || r();
    for (var i of t)
      i.out(n);
  } else
    r();
}
function Ho(t, r, e) {
  if ((t.f & At) === 0) {
    if (t.f ^= At, t.transitions !== null)
      for (const o of t.transitions)
        (o.is_global || e) && r.push(o);
    for (var n = t.first; n !== null; ) {
      var i = n.next, s = (n.f & Io) !== 0 || (n.f & It) !== 0;
      Ho(n, r, s ? e : !1), n = i;
    }
  }
}
function Ei(t) {
  Fc(t, !0);
}
function Fc(t, r) {
  if ((t.f & At) !== 0) {
    t.f ^= At, (t.f & Te) === 0 && (t.f ^= Te), Ln(t) && (gt(t, Ft), zi(t));
    for (var e = t.first; e !== null; ) {
      var n = e.next, i = (e.f & Io) !== 0 || (e.f & It) !== 0;
      Fc(e, i ? r : !1), e = n;
    }
    if (t.transitions !== null)
      for (const s of t.transitions)
        (s.is_global || r) && s.in();
  }
}
const gv = ["touchstart", "touchmove"];
function mv(t) {
  return gv.includes(t);
}
let sl = !1;
function vv() {
  sl || (sl = !0, document.addEventListener(
    "reset",
    (t) => {
      Promise.resolve().then(() => {
        var r;
        if (!t.defaultPrevented)
          for (
            const e of
            /**@type {HTMLFormElement} */
            t.target.elements
          )
            (r = e.__on_r) == null || r.call(e);
      });
    },
    // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
    { capture: !0 }
  ));
}
function yv(t) {
  var r = ie, e = se;
  qt(null), Vt(null);
  try {
    return t();
  } finally {
    qt(r), Vt(e);
  }
}
function Dc(t, r, e, n = e) {
  t.addEventListener(r, () => yv(e));
  const i = t.__on_r;
  i ? t.__on_r = () => {
    i(), n(!0);
  } : t.__on_r = () => n(!0), vv();
}
const Oc = /* @__PURE__ */ new Set(), Hs = /* @__PURE__ */ new Set();
function zo(t) {
  for (var r = 0; r < t.length; r++)
    Oc.add(t[r]);
  for (var e of Hs)
    e(t);
}
function Hn(t) {
  var g;
  var r = this, e = (
    /** @type {Node} */
    r.ownerDocument
  ), n = t.type, i = ((g = t.composedPath) == null ? void 0 : g.call(t)) || [], s = (
    /** @type {null | Element} */
    i[0] || t.target
  ), o = 0, a = t.__root;
  if (a) {
    var u = i.indexOf(a);
    if (u !== -1 && (r === document || r === /** @type {any} */
    window)) {
      t.__root = r;
      return;
    }
    var l = i.indexOf(r);
    if (l === -1)
      return;
    u <= l && (o = u);
  }
  if (s = /** @type {Element} */
  i[o] || t.target, s !== r) {
    oc(t, "currentTarget", {
      configurable: !0,
      get() {
        return s || e;
      }
    });
    var c = ie, h = se;
    qt(null), Vt(null);
    try {
      for (var d, v = []; s !== null; ) {
        var M = s.assignedSlot || s.parentNode || /** @type {any} */
        s.host || null;
        try {
          var A = s["__" + n];
          if (A !== void 0 && (!/** @type {any} */
          s.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          t.target === s))
            if (Co(A)) {
              var [P, ...C] = A;
              P.apply(s, [t, ...C]);
            } else
              A.call(s, t);
        } catch (D) {
          d ? v.push(D) : d = D;
        }
        if (t.cancelBubble || M === r || M === null)
          break;
        s = M;
      }
      if (d) {
        for (let D of v)
          queueMicrotask(() => {
            throw D;
          });
        throw d;
      }
    } finally {
      t.__root = r, delete t.currentTarget, qt(c), Vt(h);
    }
  }
}
function Gc(t) {
  var r = document.createElement("template");
  return r.innerHTML = t, r.content;
}
function gn(t, r) {
  var e = (
    /** @type {Effect} */
    se
  );
  e.nodes_start === null && (e.nodes_start = t, e.nodes_end = r);
}
// @__NO_SIDE_EFFECTS__
function it(t, r) {
  var e = (r & z1) !== 0, n = (r & J1) !== 0, i, s = !t.startsWith("<!>");
  return () => {
    i === void 0 && (i = Gc(s ? t : "<!>" + t), e || (i = /** @type {Node} */
    /* @__PURE__ */ pn(i)));
    var o = (
      /** @type {TemplateNode} */
      n || Ec ? document.importNode(i, !0) : i.cloneNode(!0)
    );
    if (e) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ pn(o)
      ), u = (
        /** @type {TemplateNode} */
        o.lastChild
      );
      gn(a, u);
    } else
      gn(o, o);
    return o;
  };
}
function ol(t = "") {
  {
    var r = Ni(t + "");
    return gn(r, r), r;
  }
}
function Pr() {
  var t = document.createDocumentFragment(), r = document.createComment(""), e = Ni();
  return t.append(r, e), gn(r, e), t;
}
function de(t, r) {
  t !== null && t.before(
    /** @type {Node} */
    r
  );
}
function Sr(t, r) {
  var e = r == null ? "" : typeof r == "object" ? r + "" : r;
  e !== (t.__t ?? (t.__t = t.nodeValue)) && (t.__t = e, t.nodeValue = e + "");
}
function wv(t, r) {
  return Ev(t, r);
}
const gr = /* @__PURE__ */ new Map();
function Ev(t, { target: r, anchor: e, props: n = {}, events: i, context: s, intro: o = !0 }) {
  X1();
  var a = /* @__PURE__ */ new Set(), u = (h) => {
    for (var d = 0; d < h.length; d++) {
      var v = h[d];
      if (!a.has(v)) {
        a.add(v);
        var M = mv(v);
        r.addEventListener(v, Hn, { passive: M });
        var A = gr.get(v);
        A === void 0 ? (document.addEventListener(v, Hn, { passive: M }), gr.set(v, 1)) : gr.set(v, A + 1);
      }
    }
  };
  u(ko(Oc)), Hs.add(u);
  var l = void 0, c = dv(() => {
    var h = e ?? r.appendChild(Ni());
    return Tr(() => {
      if (s) {
        Dr({});
        var d = (
          /** @type {ComponentContext} */
          re
        );
        d.c = s;
      }
      i && (n.$$events = i), l = t(h, n) || {}, s && Or();
    }), () => {
      var M;
      for (var d of a) {
        r.removeEventListener(d, Hn);
        var v = (
          /** @type {number} */
          gr.get(d)
        );
        --v === 0 ? (document.removeEventListener(d, Hn), gr.delete(d)) : gr.set(d, v);
      }
      Hs.delete(u), h !== e && ((M = h.parentNode) == null || M.removeChild(h));
    };
  });
  return zs.set(l, c), l;
}
let zs = /* @__PURE__ */ new WeakMap();
function Mv(t, r) {
  const e = zs.get(t);
  return e ? (zs.delete(t), e(r)) : Promise.resolve();
}
function ct(t, r, [e, n] = [0, 0]) {
  var i = t, s = null, o = null, a = Oe, u = e > 0 ? Io : 0, l = !1;
  const c = (d, v = !0) => {
    l = !0, h(v, d);
  }, h = (d, v) => {
    a !== (a = d) && (a ? (s ? Ei(s) : v && (s = Tr(() => v(i))), o && wi(o, () => {
      o = null;
    })) : (o ? Ei(o) : v && (o = Tr(() => v(i, [e + 1, n]))), s && wi(s, () => {
      s = null;
    })));
  };
  qi(() => {
    l = !1, r(c), l || h(null, null);
  }, u);
}
function mn(t, r) {
  return r;
}
function bv(t, r, e, n) {
  for (var i = [], s = r.length, o = 0; o < s; o++)
    Ho(r[o].e, i, !0);
  var a = s > 0 && i.length === 0 && e !== null;
  if (a) {
    var u = (
      /** @type {Element} */
      /** @type {Element} */
      e.parentNode
    );
    K1(u), u.append(
      /** @type {Element} */
      e
    ), n.clear(), Gt(t, r[0].prev, r[s - 1].next);
  }
  Ic(i, () => {
    for (var l = 0; l < s; l++) {
      var c = r[l];
      a || (n.delete(c.k), Gt(t, c.prev, c.next)), Lt(c.e, !a);
    }
  });
}
function vn(t, r, e, n, i, s = null) {
  var o = t, a = { flags: r, items: /* @__PURE__ */ new Map(), first: null }, u = (r & dc) !== 0;
  if (u) {
    var l = (
      /** @type {Element} */
      t
    );
    o = l.appendChild(Ni());
  }
  var c = null, h = !1, d = /* @__PURE__ */ vc(() => {
    var v = e();
    return Co(v) ? v : v == null ? [] : ko(v);
  });
  qi(() => {
    var v = Q(d), M = v.length;
    h && M === 0 || (h = M === 0, xv(v, a, o, i, r, n, e), s !== null && (M === 0 ? c ? Ei(c) : c = Tr(() => s(o)) : c !== null && wi(c, () => {
      c = null;
    })), Q(d));
  });
}
function xv(t, r, e, n, i, s, o) {
  var k, b, x, T;
  var a = (i & U1) !== 0, u = (i & (Fo | Do)) !== 0, l = t.length, c = r.items, h = r.first, d = h, v, M = null, A, P = [], C = [], g, D, F, G;
  if (a)
    for (G = 0; G < l; G += 1)
      g = t[G], D = s(g, G), F = c.get(D), F !== void 0 && ((k = F.a) == null || k.measure(), (A ?? (A = /* @__PURE__ */ new Set())).add(F));
  for (G = 0; G < l; G += 1) {
    if (g = t[G], D = s(g, G), F = c.get(D), F === void 0) {
      var B = d ? (
        /** @type {TemplateNode} */
        d.e.nodes_start
      ) : e;
      M = Sv(
        B,
        r,
        M,
        M === null ? r.first : M.next,
        g,
        D,
        G,
        n,
        i,
        o
      ), c.set(D, M), P = [], C = [], d = M.next;
      continue;
    }
    if (u && _v(F, g, G, i), (F.e.f & At) !== 0 && (Ei(F.e), a && ((b = F.a) == null || b.unfix(), (A ?? (A = /* @__PURE__ */ new Set())).delete(F))), F !== d) {
      if (v !== void 0 && v.has(F)) {
        if (P.length < C.length) {
          var H = C[0], f;
          M = H.prev;
          var p = P[0], m = P[P.length - 1];
          for (f = 0; f < P.length; f += 1)
            al(P[f], H, e);
          for (f = 0; f < C.length; f += 1)
            v.delete(C[f]);
          Gt(r, p.prev, m.next), Gt(r, M, p), Gt(r, m, H), d = H, M = m, G -= 1, P = [], C = [];
        } else
          v.delete(F), al(F, d, e), Gt(r, F.prev, F.next), Gt(r, F, M === null ? r.first : M.next), Gt(r, M, F), M = F;
        continue;
      }
      for (P = [], C = []; d !== null && d.k !== D; )
        (d.e.f & At) === 0 && (v ?? (v = /* @__PURE__ */ new Set())).add(d), C.push(d), d = d.next;
      if (d === null)
        continue;
      F = d;
    }
    P.push(F), M = F, d = F.next;
  }
  if (d !== null || v !== void 0) {
    for (var y = v === void 0 ? [] : ko(v); d !== null; )
      (d.e.f & At) === 0 && y.push(d), d = d.next;
    var E = y.length;
    if (E > 0) {
      var S = (i & dc) !== 0 && l === 0 ? e : null;
      if (a) {
        for (G = 0; G < E; G += 1)
          (x = y[G].a) == null || x.measure();
        for (G = 0; G < E; G += 1)
          (T = y[G].a) == null || T.fix();
      }
      bv(r, y, S, c);
    }
  }
  a && k1(() => {
    var L;
    if (A !== void 0)
      for (F of A)
        (L = F.a) == null || L.apply();
  }), se.first = r.first && r.first.e, se.last = M && M.e;
}
function _v(t, r, e, n) {
  (n & Fo) !== 0 && Rs(t.v, r), (n & Do) !== 0 ? Rs(
    /** @type {Value<number>} */
    t.i,
    e
  ) : t.i = e;
}
function Sv(t, r, e, n, i, s, o, a, u, l) {
  var c = (u & Fo) !== 0, h = (u & H1) === 0, d = c ? h ? /* @__PURE__ */ Ro(i) : Ue(i) : i, v = (u & Do) === 0 ? o : Ue(o), M = {
    i: v,
    v: d,
    k: s,
    a: null,
    // @ts-expect-error
    e: null,
    prev: e,
    next: n
  };
  try {
    return M.e = Tr(() => a(t, d, v, l), j1), M.e.prev = e && e.e, M.e.next = n && n.e, e === null ? r.first = M : (e.next = M, e.e.next = M.e), n !== null && (n.prev = M, n.e.prev = M.e), M;
  } finally {
  }
}
function al(t, r, e) {
  for (var n = t.next ? (
    /** @type {TemplateNode} */
    t.next.e.nodes_start
  ) : e, i = r ? (
    /** @type {TemplateNode} */
    r.e.nodes_start
  ) : e, s = (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ); s !== n; ) {
    var o = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Ui(s)
    );
    i.before(s), s = o;
  }
}
function Gt(t, r, e) {
  r === null ? t.first = e : (r.next = e, r.e.next = e && e.e), e !== null && (e.prev = r, e.e.prev = r && r.e);
}
function Av(t, r, e, n, i) {
  var s = t, o = "", a;
  qi(() => {
    o !== (o = r() ?? "") && (a !== void 0 && (Lt(a), a = void 0), o !== "" && (a = Tr(() => {
      var u = o + "", l = Gc(u);
      gn(
        /** @type {TemplateNode} */
        /* @__PURE__ */ pn(l),
        /** @type {TemplateNode} */
        l.lastChild
      ), s.before(l);
    })));
  });
}
const ll = [...` 	
\r\f\v\uFEFF`];
function Lv(t, r, e) {
  var n = t == null ? "" : "" + t;
  if (r && (n = n ? n + " " + r : r), e) {
    for (var i in e)
      if (e[i])
        n = n ? n + " " + i : i;
      else if (n.length)
        for (var s = i.length, o = 0; (o = n.indexOf(i, o)) >= 0; ) {
          var a = o + s;
          (o === 0 || ll.includes(n[o - 1])) && (a === n.length || ll.includes(n[a])) ? n = (o === 0 ? "" : n.substring(0, o)) + n.substring(a + 1) : o = a;
        }
  }
  return n === "" ? null : n;
}
function Js(t, r, e, n, i, s) {
  var o = t.__className;
  if (o !== e) {
    var a = Lv(e, n, s);
    a == null ? t.removeAttribute("class") : t.className = a, t.__className = e;
  } else if (s)
    for (var u in s) {
      var l = !!s[u];
      (i == null || l !== !!i[u]) && t.classList.toggle(u, l);
    }
  return s;
}
function Xt(t, r, e, n) {
  var i = t.__attributes ?? (t.__attributes = {});
  i[r] !== (i[r] = e) && (r === "style" && "__styles" in t && (t.__styles = {}), r === "loading" && (t[L1] = e), e == null ? t.removeAttribute(r) : typeof e != "string" && Cv(t).includes(r) ? t[r] = e : t.setAttribute(r, e));
}
var ul = /* @__PURE__ */ new Map();
function Cv(t) {
  var r = ul.get(t.nodeName);
  if (r) return r;
  ul.set(t.nodeName, r = []);
  for (var e, n = t, i = Element.prototype; i !== n; ) {
    e = ac(n);
    for (var s in e)
      e[s].set && r.push(s);
    n = To(n);
  }
  return r;
}
function kv(t, r, e = r) {
  Dc(t, "change", (n) => {
    var i = n ? t.defaultChecked : t.checked;
    e(i);
  }), // If we are hydrating and the value has since changed,
  // then use the update value from the input instead.
  // If defaultChecked is set, then checked == defaultChecked
  Cn(r) == null && e(t.checked), Cc(() => {
    var n = r();
    t.checked = !!n;
  });
}
function Rc(t, r, e) {
  if (t.multiple)
    return Iv(t, r);
  for (var n of t.options) {
    var i = ln(n);
    if (Z1(i, r)) {
      n.selected = !0;
      return;
    }
  }
  (!e || r !== void 0) && (t.selectedIndex = -1);
}
function Tv(t, r) {
  Ji(() => {
    var e = new MutationObserver(() => {
      var n = t.__value;
      Rc(t, n);
    });
    return e.observe(t, {
      // Listen to option element changes
      childList: !0,
      subtree: !0,
      // because of <optgroup>
      // Listen to option element value attribute changes
      // (doesn't get notified of select value changes,
      // because that property is not reflected as an attribute)
      attributes: !0,
      attributeFilter: ["value"]
    }), () => {
      e.disconnect();
    };
  });
}
function Pv(t, r, e = r) {
  var n = !0;
  Dc(t, "change", (i) => {
    var s = i ? "[selected]" : ":checked", o;
    if (t.multiple)
      o = [].map.call(t.querySelectorAll(s), ln);
    else {
      var a = t.querySelector(s) ?? // will fall back to first non-disabled option if no option is selected
      t.querySelector("option:not([disabled])");
      o = a && ln(a);
    }
    e(o);
  }), Ji(() => {
    var i = r();
    if (Rc(t, i, n), n && i === void 0) {
      var s = t.querySelector(":checked");
      s !== null && (i = ln(s), e(i));
    }
    t.__value = i, n = !1;
  }), Tv(t);
}
function Iv(t, r) {
  for (var e of t.options)
    e.selected = ~r.indexOf(ln(e));
}
function ln(t) {
  return "__value" in t ? t.__value : t.value;
}
function Fv(t = !1) {
  const r = (
    /** @type {ComponentContextLegacy} */
    re
  ), e = r.l.u;
  if (!e) return;
  let n = () => uv(r.s);
  if (t) {
    let i = 0, s = (
      /** @type {Record<string, any>} */
      {}
    );
    const o = /* @__PURE__ */ Bo(() => {
      let a = !1;
      const u = r.s;
      for (const l in u)
        u[l] !== s[l] && (s[l] = u[l], a = !0);
      return a && i++, i;
    });
    n = () => Q(o);
  }
  e.b.length && hv(() => {
    cl(r, n), Gs(e.b);
  }), Us(() => {
    const i = Cn(() => e.m.map(_1));
    return () => {
      for (const s of i)
        typeof s == "function" && s();
    };
  }), e.a.length && Us(() => {
    cl(r, n), Gs(e.a);
  });
}
function cl(t, r) {
  if (t.l.s)
    for (const e of t.l.s) Q(e);
  r();
}
let qs = Symbol();
function Dv(t, r, e) {
  const n = e[r] ?? (e[r] = {
    store: null,
    source: /* @__PURE__ */ Ro(void 0),
    unsubscribe: _r
  });
  if (n.store !== t && !(qs in e))
    if (n.unsubscribe(), n.store = t ?? null, t == null)
      n.source.v = void 0, n.unsubscribe = _r;
    else {
      var i = !0;
      n.unsubscribe = Nc(t, (s) => {
        i ? n.source.v = s : Ee(n.source, s);
      }), i = !1;
    }
  return t && qs in e ? Nv(t) : Q(n.source);
}
function Ov() {
  const t = {};
  function r() {
    fv(() => {
      for (var e in t)
        t[e].unsubscribe();
      oc(t, qs, {
        enumerable: !1,
        value: !0
      });
    });
  }
  return [t, r];
}
function Bc(t) {
  re === null && Oo(), An && re.l !== null ? Rv(re).m.push(t) : Us(() => {
    const r = Cn(t);
    if (typeof r == "function") return (
      /** @type {() => void} */
      r
    );
  });
}
function Gv(t) {
  re === null && Oo(), Bc(() => () => Cn(t));
}
function Rv(t) {
  var r = (
    /** @type {ComponentContextLegacy} */
    t.l
  );
  return r.u ?? (r.u = { a: [], b: [], m: [] });
}
function Nc(t, r, e) {
  if (t == null)
    return r(void 0), _r;
  const n = Cn(
    () => t.subscribe(
      r,
      // @ts-expect-error
      e
    )
  );
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
const mr = [];
function Bv(t, r = _r) {
  let e = null;
  const n = /* @__PURE__ */ new Set();
  function i(a) {
    if (fc(t, a) && (t = a, e)) {
      const u = !mr.length;
      for (const l of n)
        l[1](), mr.push(l, t);
      if (u) {
        for (let l = 0; l < mr.length; l += 2)
          mr[l][0](mr[l + 1]);
        mr.length = 0;
      }
    }
  }
  function s(a) {
    i(a(
      /** @type {T} */
      t
    ));
  }
  function o(a, u = _r) {
    const l = [a, u];
    return n.add(l), n.size === 1 && (e = r(i, s) || _r), a(
      /** @type {T} */
      t
    ), () => {
      n.delete(l), n.size === 0 && e && (e(), e = null);
    };
  }
  return { set: i, update: s, subscribe: o };
}
function Nv(t) {
  let r;
  return Nc(t, (e) => r = e)(), r;
}
const Uv = {
  controls: je(Zl),
  options: sc().controls
}, Vs = Bv(Uv), Hv = "5";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(Hv);
N1();
const fl = (t, r, e) => {
  var n, i;
  if (!r.actionInstance || !r.actionOption) {
    N.error("Can't apply option value", r.actionInstance, r.actionOption);
    return;
  }
  if (((n = r.actionOption) == null ? void 0 : n.type) === "toggle") {
    const s = t.target;
    Ee(e, ut(s.checked));
  } else if (((i = r.actionOption) == null ? void 0 : i.type) === "select") {
    const s = t.target;
    Ee(e, ut(s.value));
  }
  r.actionInstance.applyOptionValue(r.actionOption.name, Q(e));
};
var zv = /* @__PURE__ */ it("<option> </option>"), Jv = /* @__PURE__ */ it('<label class="svelte-1892xbw"> </label> <select class="svelte-1892xbw"></select>', 1), qv = /* @__PURE__ */ it('<label class="svelte-1892xbw"><input type="checkbox" class="svelte-1892xbw"> </label>'), Vv = /* @__PURE__ */ it("<span>Unknown type</span>"), Yv = /* @__PURE__ */ it('<div class="action-option svelte-1892xbw"><!></div>');
function Wv(t, r) {
  Dr(r, !0);
  let e = pc("");
  Bc(() => {
    r.actionOption && (r.actionOption.type === "select" ? Ee(e, ut(r.actionOption.value.value)) : r.actionOption.type === "toggle" && Ee(e, ut(r.actionOption.value)));
  });
  var n = Pr(), i = Jt(n);
  {
    var s = (o) => {
      var a = Yv(), u = Bt(a);
      {
        var l = (h) => {
          var d = Jv(), v = Jt(d), M = Bt(v), A = gi(v, 2);
          A.__change = [fl, r, e], vn(A, 21, () => r.actionOption.choices, mn, (P, C) => {
            var g = zv(), D = {}, F = Bt(g);
            _t(() => {
              D !== (D = Q(C).value) && (g.value = (g.__value = Q(C).value) == null ? "" : Q(C).value), Sr(F, Q(C).title);
            }), de(P, g);
          }), _t(() => {
            Xt(v, "for", r.actionOption.name), Sr(M, r.actionOption.label), Xt(A, "id", r.actionOption.name);
          }), Pv(A, () => Q(e), (P) => Ee(e, P)), de(h, d);
        }, c = (h, d) => {
          {
            var v = (A) => {
              var P = qv(), C = Bt(P);
              C.__change = [fl, r, e];
              var g = gi(C);
              _t(
                (D) => {
                  Xt(P, "for", r.actionOption.name), Xt(C, "id", D), Sr(g, ` ${r.actionOption.label ?? ""}`);
                },
                [() => String(r.actionOption.name)]
              ), kv(C, () => Q(e), (D) => Ee(e, D)), de(A, P);
            }, M = (A) => {
              var P = Vv();
              de(A, P);
            };
            ct(
              h,
              (A) => {
                r.actionOption.type === "toggle" && typeof Q(e) == "boolean" ? A(v) : A(M, !1);
              },
              d
            );
          }
        };
        ct(u, (h) => {
          r.actionOption.type === "select" ? h(l) : h(c, !1);
        });
      }
      de(o, a);
    };
    ct(i, (o) => {
      r.actionOption && o(s);
    });
  }
  de(t, n), Or();
}
zo(["change"]);
const $v = (t, r) => {
  if (t.preventDefault(), !r.actionInstance || !r.subAction) {
    N.error("Can't run a SubAction", r.actionInstance, r.subAction);
    return;
  }
  r.subAction.method();
};
var jv = /* @__PURE__ */ it('<button type="submit" class="sub-action svelte-1x28ief"> </button>');
function Zv(t, r) {
  Dr(r, !0);
  var e = Pr(), n = Jt(e);
  {
    var i = (s) => {
      var o = jv();
      o.__click = [$v, r];
      var a = Bt(o);
      _t(() => {
        Xt(o, "title", r.subAction.label), Sr(a, r.subAction.label);
      }), de(s, o);
    };
    ct(n, (s) => {
      r.subAction && s(i);
    });
  }
  de(t, e), Or();
}
zo(["click"]);
var Xv = /* @__PURE__ */ it("<!> <!>", 1);
function Kv(t, r) {
  Dr(r, !0);
  const e = Go("gm"), n = r.control.type, i = r.control.targetMode;
  let s = pc(null);
  n && i && Ee(s, ut(e.actionInstances[`${n}__${i}`] || null));
  var o = Pr(), a = Jt(o);
  {
    var u = (l) => {
      var c = Xv(), h = Jt(c);
      vn(h, 17, () => Q(s).options, mn, (v, M) => {
        Wv(v, {
          get actionInstance() {
            return Q(s);
          },
          get actionOption() {
            return Q(M);
          }
        });
      });
      var d = gi(h, 2);
      vn(d, 17, () => Q(s).actions, mn, (v, M) => {
        Zv(v, {
          get actionInstance() {
            return Q(s);
          },
          get subAction() {
            return Q(M);
          }
        });
      }), de(l, c);
    };
    ct(a, (l) => {
      Q(s) && l(u);
    });
  }
  de(t, o), Or();
}
/*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE */
const {
  entries: Uc,
  setPrototypeOf: hl,
  isFrozen: Qv,
  getPrototypeOf: ey,
  getOwnPropertyDescriptor: ty
} = Object;
let {
  freeze: Pe,
  seal: Ze,
  create: Hc
} = Object, {
  apply: Ys,
  construct: Ws
} = typeof Reflect < "u" && Reflect;
Pe || (Pe = function(r) {
  return r;
});
Ze || (Ze = function(r) {
  return r;
});
Ys || (Ys = function(r, e, n) {
  return r.apply(e, n);
});
Ws || (Ws = function(r, e) {
  return new r(...e);
});
const zn = Ie(Array.prototype.forEach), ry = Ie(Array.prototype.lastIndexOf), dl = Ie(Array.prototype.pop), Jr = Ie(Array.prototype.push), ny = Ie(Array.prototype.splice), ti = Ie(String.prototype.toLowerCase), fs = Ie(String.prototype.toString), pl = Ie(String.prototype.match), qr = Ie(String.prototype.replace), iy = Ie(String.prototype.indexOf), sy = Ie(String.prototype.trim), Ke = Ie(Object.prototype.hasOwnProperty), Le = Ie(RegExp.prototype.test), Vr = oy(TypeError);
function Ie(t) {
  return function(r) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
      n[i - 1] = arguments[i];
    return Ys(t, r, n);
  };
}
function oy(t) {
  return function() {
    for (var r = arguments.length, e = new Array(r), n = 0; n < r; n++)
      e[n] = arguments[n];
    return Ws(t, e);
  };
}
function K(t, r) {
  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ti;
  hl && hl(t, null);
  let n = r.length;
  for (; n--; ) {
    let i = r[n];
    if (typeof i == "string") {
      const s = e(i);
      s !== i && (Qv(r) || (r[n] = s), i = s);
    }
    t[i] = !0;
  }
  return t;
}
function ay(t) {
  for (let r = 0; r < t.length; r++)
    Ke(t, r) || (t[r] = null);
  return t;
}
function Zt(t) {
  const r = Hc(null);
  for (const [e, n] of Uc(t))
    Ke(t, e) && (Array.isArray(n) ? r[e] = ay(n) : n && typeof n == "object" && n.constructor === Object ? r[e] = Zt(n) : r[e] = n);
  return r;
}
function Yr(t, r) {
  for (; t !== null; ) {
    const n = ty(t, r);
    if (n) {
      if (n.get)
        return Ie(n.get);
      if (typeof n.value == "function")
        return Ie(n.value);
    }
    t = ey(t);
  }
  function e() {
    return null;
  }
  return e;
}
const gl = Pe(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), hs = Pe(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ds = Pe(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), ly = Pe(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), ps = Pe(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), uy = Pe(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ml = Pe(["#text"]), vl = Pe(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), gs = Pe(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), yl = Pe(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Jn = Pe(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), cy = Ze(/\{\{[\w\W]*|[\w\W]*\}\}/gm), fy = Ze(/<%[\w\W]*|[\w\W]*%>/gm), hy = Ze(/\$\{[\w\W]*/gm), dy = Ze(/^data-[\-\w.\u00B7-\uFFFF]+$/), py = Ze(/^aria-[\-\w]+$/), zc = Ze(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), gy = Ze(/^(?:\w+script|data):/i), my = Ze(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Jc = Ze(/^html$/i), vy = Ze(/^[a-z][.\w]*(-[.\w]+)+$/i);
var wl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: py,
  ATTR_WHITESPACE: my,
  CUSTOM_ELEMENT: vy,
  DATA_ATTR: dy,
  DOCTYPE_NAME: Jc,
  ERB_EXPR: fy,
  IS_ALLOWED_URI: zc,
  IS_SCRIPT_OR_DATA: gy,
  MUSTACHE_EXPR: cy,
  TMPLIT_EXPR: hy
});
const Wr = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, yy = function() {
  return typeof window > "u" ? null : window;
}, wy = function(r, e) {
  if (typeof r != "object" || typeof r.createPolicy != "function")
    return null;
  let n = null;
  const i = "data-tt-policy-suffix";
  e && e.hasAttribute(i) && (n = e.getAttribute(i));
  const s = "dompurify" + (n ? "#" + n : "");
  try {
    return r.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, El = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function qc() {
  let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yy();
  const r = (W) => qc(W);
  if (r.version = "3.2.4", r.removed = [], !t || !t.document || t.document.nodeType !== Wr.document || !t.Element)
    return r.isSupported = !1, r;
  let {
    document: e
  } = t;
  const n = e, i = n.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: a,
    Element: u,
    NodeFilter: l,
    NamedNodeMap: c = t.NamedNodeMap || t.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: d,
    trustedTypes: v
  } = t, M = u.prototype, A = Yr(M, "cloneNode"), P = Yr(M, "remove"), C = Yr(M, "nextSibling"), g = Yr(M, "childNodes"), D = Yr(M, "parentNode");
  if (typeof o == "function") {
    const W = e.createElement("template");
    W.content && W.content.ownerDocument && (e = W.content.ownerDocument);
  }
  let F, G = "";
  const {
    implementation: B,
    createNodeIterator: H,
    createDocumentFragment: f,
    getElementsByTagName: p
  } = e, {
    importNode: m
  } = n;
  let y = El();
  r.isSupported = typeof Uc == "function" && typeof D == "function" && B && B.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: E,
    ERB_EXPR: S,
    TMPLIT_EXPR: k,
    DATA_ATTR: b,
    ARIA_ATTR: x,
    IS_SCRIPT_OR_DATA: T,
    ATTR_WHITESPACE: L,
    CUSTOM_ELEMENT: I
  } = wl;
  let {
    IS_ALLOWED_URI: J
  } = wl, U = null;
  const X = K({}, [...gl, ...hs, ...ds, ...ps, ...ml]);
  let V = null;
  const Z = K({}, [...vl, ...gs, ...yl, ...Jn]);
  let z = Object.seal(Hc(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), $ = null, ee = null, mt = !0, vt = !0, Dt = !1, _e = !0, Fe = !1, pe = !0, ae = !1, ne = !1, Vi = !1, lr = !1, Tn = !1, Pn = !1, Yo = !0, Wo = !1;
  const of = "user-content-";
  let Yi = !0, Nr = !1, ur = {}, cr = null;
  const $o = K({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let jo = null;
  const Zo = K({}, ["audio", "video", "img", "source", "image", "track"]);
  let Wi = null;
  const Xo = K({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), In = "http://www.w3.org/1998/Math/MathML", Fn = "http://www.w3.org/2000/svg", yt = "http://www.w3.org/1999/xhtml";
  let fr = yt, $i = !1, ji = null;
  const af = K({}, [In, Fn, yt], fs);
  let Dn = K({}, ["mi", "mo", "mn", "ms", "mtext"]), On = K({}, ["annotation-xml"]);
  const lf = K({}, ["title", "style", "font", "a", "script"]);
  let Ur = null;
  const uf = ["application/xhtml+xml", "text/html"], cf = "text/html";
  let ge = null, hr = null;
  const ff = e.createElement("form"), Ko = function(_) {
    return _ instanceof RegExp || _ instanceof Function;
  }, Zi = function() {
    let _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(hr && hr === _)) {
      if ((!_ || typeof _ != "object") && (_ = {}), _ = Zt(_), Ur = // eslint-disable-next-line unicorn/prefer-includes
      uf.indexOf(_.PARSER_MEDIA_TYPE) === -1 ? cf : _.PARSER_MEDIA_TYPE, ge = Ur === "application/xhtml+xml" ? fs : ti, U = Ke(_, "ALLOWED_TAGS") ? K({}, _.ALLOWED_TAGS, ge) : X, V = Ke(_, "ALLOWED_ATTR") ? K({}, _.ALLOWED_ATTR, ge) : Z, ji = Ke(_, "ALLOWED_NAMESPACES") ? K({}, _.ALLOWED_NAMESPACES, fs) : af, Wi = Ke(_, "ADD_URI_SAFE_ATTR") ? K(Zt(Xo), _.ADD_URI_SAFE_ATTR, ge) : Xo, jo = Ke(_, "ADD_DATA_URI_TAGS") ? K(Zt(Zo), _.ADD_DATA_URI_TAGS, ge) : Zo, cr = Ke(_, "FORBID_CONTENTS") ? K({}, _.FORBID_CONTENTS, ge) : $o, $ = Ke(_, "FORBID_TAGS") ? K({}, _.FORBID_TAGS, ge) : {}, ee = Ke(_, "FORBID_ATTR") ? K({}, _.FORBID_ATTR, ge) : {}, ur = Ke(_, "USE_PROFILES") ? _.USE_PROFILES : !1, mt = _.ALLOW_ARIA_ATTR !== !1, vt = _.ALLOW_DATA_ATTR !== !1, Dt = _.ALLOW_UNKNOWN_PROTOCOLS || !1, _e = _.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Fe = _.SAFE_FOR_TEMPLATES || !1, pe = _.SAFE_FOR_XML !== !1, ae = _.WHOLE_DOCUMENT || !1, lr = _.RETURN_DOM || !1, Tn = _.RETURN_DOM_FRAGMENT || !1, Pn = _.RETURN_TRUSTED_TYPE || !1, Vi = _.FORCE_BODY || !1, Yo = _.SANITIZE_DOM !== !1, Wo = _.SANITIZE_NAMED_PROPS || !1, Yi = _.KEEP_CONTENT !== !1, Nr = _.IN_PLACE || !1, J = _.ALLOWED_URI_REGEXP || zc, fr = _.NAMESPACE || yt, Dn = _.MATHML_TEXT_INTEGRATION_POINTS || Dn, On = _.HTML_INTEGRATION_POINTS || On, z = _.CUSTOM_ELEMENT_HANDLING || {}, _.CUSTOM_ELEMENT_HANDLING && Ko(_.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (z.tagNameCheck = _.CUSTOM_ELEMENT_HANDLING.tagNameCheck), _.CUSTOM_ELEMENT_HANDLING && Ko(_.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (z.attributeNameCheck = _.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), _.CUSTOM_ELEMENT_HANDLING && typeof _.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (z.allowCustomizedBuiltInElements = _.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Fe && (vt = !1), Tn && (lr = !0), ur && (U = K({}, ml), V = [], ur.html === !0 && (K(U, gl), K(V, vl)), ur.svg === !0 && (K(U, hs), K(V, gs), K(V, Jn)), ur.svgFilters === !0 && (K(U, ds), K(V, gs), K(V, Jn)), ur.mathMl === !0 && (K(U, ps), K(V, yl), K(V, Jn))), _.ADD_TAGS && (U === X && (U = Zt(U)), K(U, _.ADD_TAGS, ge)), _.ADD_ATTR && (V === Z && (V = Zt(V)), K(V, _.ADD_ATTR, ge)), _.ADD_URI_SAFE_ATTR && K(Wi, _.ADD_URI_SAFE_ATTR, ge), _.FORBID_CONTENTS && (cr === $o && (cr = Zt(cr)), K(cr, _.FORBID_CONTENTS, ge)), Yi && (U["#text"] = !0), ae && K(U, ["html", "head", "body"]), U.table && (K(U, ["tbody"]), delete $.tbody), _.TRUSTED_TYPES_POLICY) {
        if (typeof _.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Vr('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof _.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Vr('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        F = _.TRUSTED_TYPES_POLICY, G = F.createHTML("");
      } else
        F === void 0 && (F = wy(v, i)), F !== null && typeof G == "string" && (G = F.createHTML(""));
      Pe && Pe(_), hr = _;
    }
  }, Qo = K({}, [...hs, ...ds, ...ly]), ea = K({}, [...ps, ...uy]), hf = function(_) {
    let R = D(_);
    (!R || !R.tagName) && (R = {
      namespaceURI: fr,
      tagName: "template"
    });
    const q = ti(_.tagName), ue = ti(R.tagName);
    return ji[_.namespaceURI] ? _.namespaceURI === Fn ? R.namespaceURI === yt ? q === "svg" : R.namespaceURI === In ? q === "svg" && (ue === "annotation-xml" || Dn[ue]) : !!Qo[q] : _.namespaceURI === In ? R.namespaceURI === yt ? q === "math" : R.namespaceURI === Fn ? q === "math" && On[ue] : !!ea[q] : _.namespaceURI === yt ? R.namespaceURI === Fn && !On[ue] || R.namespaceURI === In && !Dn[ue] ? !1 : !ea[q] && (lf[q] || !Qo[q]) : !!(Ur === "application/xhtml+xml" && ji[_.namespaceURI]) : !1;
  }, st = function(_) {
    Jr(r.removed, {
      element: _
    });
    try {
      D(_).removeChild(_);
    } catch {
      P(_);
    }
  }, Gn = function(_, R) {
    try {
      Jr(r.removed, {
        attribute: R.getAttributeNode(_),
        from: R
      });
    } catch {
      Jr(r.removed, {
        attribute: null,
        from: R
      });
    }
    if (R.removeAttribute(_), _ === "is")
      if (lr || Tn)
        try {
          st(R);
        } catch {
        }
      else
        try {
          R.setAttribute(_, "");
        } catch {
        }
  }, ta = function(_) {
    let R = null, q = null;
    if (Vi)
      _ = "<remove></remove>" + _;
    else {
      const ye = pl(_, /^[\r\n\t ]+/);
      q = ye && ye[0];
    }
    Ur === "application/xhtml+xml" && fr === yt && (_ = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + _ + "</body></html>");
    const ue = F ? F.createHTML(_) : _;
    if (fr === yt)
      try {
        R = new d().parseFromString(ue, Ur);
      } catch {
      }
    if (!R || !R.documentElement) {
      R = B.createDocument(fr, "template", null);
      try {
        R.documentElement.innerHTML = $i ? G : ue;
      } catch {
      }
    }
    const be = R.body || R.documentElement;
    return _ && q && be.insertBefore(e.createTextNode(q), be.childNodes[0] || null), fr === yt ? p.call(R, ae ? "html" : "body")[0] : ae ? R.documentElement : be;
  }, ra = function(_) {
    return H.call(
      _.ownerDocument || _,
      _,
      // eslint-disable-next-line no-bitwise
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT | l.SHOW_PROCESSING_INSTRUCTION | l.SHOW_CDATA_SECTION,
      null
    );
  }, Xi = function(_) {
    return _ instanceof h && (typeof _.nodeName != "string" || typeof _.textContent != "string" || typeof _.removeChild != "function" || !(_.attributes instanceof c) || typeof _.removeAttribute != "function" || typeof _.setAttribute != "function" || typeof _.namespaceURI != "string" || typeof _.insertBefore != "function" || typeof _.hasChildNodes != "function");
  }, na = function(_) {
    return typeof a == "function" && _ instanceof a;
  };
  function wt(W, _, R) {
    zn(W, (q) => {
      q.call(r, _, R, hr);
    });
  }
  const ia = function(_) {
    let R = null;
    if (wt(y.beforeSanitizeElements, _, null), Xi(_))
      return st(_), !0;
    const q = ge(_.nodeName);
    if (wt(y.uponSanitizeElement, _, {
      tagName: q,
      allowedTags: U
    }), _.hasChildNodes() && !na(_.firstElementChild) && Le(/<[/\w]/g, _.innerHTML) && Le(/<[/\w]/g, _.textContent) || _.nodeType === Wr.progressingInstruction || pe && _.nodeType === Wr.comment && Le(/<[/\w]/g, _.data))
      return st(_), !0;
    if (!U[q] || $[q]) {
      if (!$[q] && oa(q) && (z.tagNameCheck instanceof RegExp && Le(z.tagNameCheck, q) || z.tagNameCheck instanceof Function && z.tagNameCheck(q)))
        return !1;
      if (Yi && !cr[q]) {
        const ue = D(_) || _.parentNode, be = g(_) || _.childNodes;
        if (be && ue) {
          const ye = be.length;
          for (let De = ye - 1; De >= 0; --De) {
            const ot = A(be[De], !0);
            ot.__removalCount = (_.__removalCount || 0) + 1, ue.insertBefore(ot, C(_));
          }
        }
      }
      return st(_), !0;
    }
    return _ instanceof u && !hf(_) || (q === "noscript" || q === "noembed" || q === "noframes") && Le(/<\/no(script|embed|frames)/i, _.innerHTML) ? (st(_), !0) : (Fe && _.nodeType === Wr.text && (R = _.textContent, zn([E, S, k], (ue) => {
      R = qr(R, ue, " ");
    }), _.textContent !== R && (Jr(r.removed, {
      element: _.cloneNode()
    }), _.textContent = R)), wt(y.afterSanitizeElements, _, null), !1);
  }, sa = function(_, R, q) {
    if (Yo && (R === "id" || R === "name") && (q in e || q in ff))
      return !1;
    if (!(vt && !ee[R] && Le(b, R))) {
      if (!(mt && Le(x, R))) {
        if (!V[R] || ee[R]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(oa(_) && (z.tagNameCheck instanceof RegExp && Le(z.tagNameCheck, _) || z.tagNameCheck instanceof Function && z.tagNameCheck(_)) && (z.attributeNameCheck instanceof RegExp && Le(z.attributeNameCheck, R) || z.attributeNameCheck instanceof Function && z.attributeNameCheck(R)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            R === "is" && z.allowCustomizedBuiltInElements && (z.tagNameCheck instanceof RegExp && Le(z.tagNameCheck, q) || z.tagNameCheck instanceof Function && z.tagNameCheck(q)))
          ) return !1;
        } else if (!Wi[R]) {
          if (!Le(J, qr(q, L, ""))) {
            if (!((R === "src" || R === "xlink:href" || R === "href") && _ !== "script" && iy(q, "data:") === 0 && jo[_])) {
              if (!(Dt && !Le(T, qr(q, L, "")))) {
                if (q)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, oa = function(_) {
    return _ !== "annotation-xml" && pl(_, I);
  }, aa = function(_) {
    wt(y.beforeSanitizeAttributes, _, null);
    const {
      attributes: R
    } = _;
    if (!R || Xi(_))
      return;
    const q = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: V,
      forceKeepAttr: void 0
    };
    let ue = R.length;
    for (; ue--; ) {
      const be = R[ue], {
        name: ye,
        namespaceURI: De,
        value: ot
      } = be, Hr = ge(ye);
      let Se = ye === "value" ? ot : sy(ot);
      if (q.attrName = Hr, q.attrValue = Se, q.keepAttr = !0, q.forceKeepAttr = void 0, wt(y.uponSanitizeAttribute, _, q), Se = q.attrValue, Wo && (Hr === "id" || Hr === "name") && (Gn(ye, _), Se = of + Se), pe && Le(/((--!?|])>)|<\/(style|title)/i, Se)) {
        Gn(ye, _);
        continue;
      }
      if (q.forceKeepAttr || (Gn(ye, _), !q.keepAttr))
        continue;
      if (!_e && Le(/\/>/i, Se)) {
        Gn(ye, _);
        continue;
      }
      Fe && zn([E, S, k], (ua) => {
        Se = qr(Se, ua, " ");
      });
      const la = ge(_.nodeName);
      if (sa(la, Hr, Se)) {
        if (F && typeof v == "object" && typeof v.getAttributeType == "function" && !De)
          switch (v.getAttributeType(la, Hr)) {
            case "TrustedHTML": {
              Se = F.createHTML(Se);
              break;
            }
            case "TrustedScriptURL": {
              Se = F.createScriptURL(Se);
              break;
            }
          }
        try {
          De ? _.setAttributeNS(De, ye, Se) : _.setAttribute(ye, Se), Xi(_) ? st(_) : dl(r.removed);
        } catch {
        }
      }
    }
    wt(y.afterSanitizeAttributes, _, null);
  }, df = function W(_) {
    let R = null;
    const q = ra(_);
    for (wt(y.beforeSanitizeShadowDOM, _, null); R = q.nextNode(); )
      wt(y.uponSanitizeShadowNode, R, null), ia(R), aa(R), R.content instanceof s && W(R.content);
    wt(y.afterSanitizeShadowDOM, _, null);
  };
  return r.sanitize = function(W) {
    let _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, R = null, q = null, ue = null, be = null;
    if ($i = !W, $i && (W = "<!-->"), typeof W != "string" && !na(W))
      if (typeof W.toString == "function") {
        if (W = W.toString(), typeof W != "string")
          throw Vr("dirty is not a string, aborting");
      } else
        throw Vr("toString is not a function");
    if (!r.isSupported)
      return W;
    if (ne || Zi(_), r.removed = [], typeof W == "string" && (Nr = !1), Nr) {
      if (W.nodeName) {
        const ot = ge(W.nodeName);
        if (!U[ot] || $[ot])
          throw Vr("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (W instanceof a)
      R = ta("<!---->"), q = R.ownerDocument.importNode(W, !0), q.nodeType === Wr.element && q.nodeName === "BODY" || q.nodeName === "HTML" ? R = q : R.appendChild(q);
    else {
      if (!lr && !Fe && !ae && // eslint-disable-next-line unicorn/prefer-includes
      W.indexOf("<") === -1)
        return F && Pn ? F.createHTML(W) : W;
      if (R = ta(W), !R)
        return lr ? null : Pn ? G : "";
    }
    R && Vi && st(R.firstChild);
    const ye = ra(Nr ? W : R);
    for (; ue = ye.nextNode(); )
      ia(ue), aa(ue), ue.content instanceof s && df(ue.content);
    if (Nr)
      return W;
    if (lr) {
      if (Tn)
        for (be = f.call(R.ownerDocument); R.firstChild; )
          be.appendChild(R.firstChild);
      else
        be = R;
      return (V.shadowroot || V.shadowrootmode) && (be = m.call(n, be, !0)), be;
    }
    let De = ae ? R.outerHTML : R.innerHTML;
    return ae && U["!doctype"] && R.ownerDocument && R.ownerDocument.doctype && R.ownerDocument.doctype.name && Le(Jc, R.ownerDocument.doctype.name) && (De = "<!DOCTYPE " + R.ownerDocument.doctype.name + `>
` + De), Fe && zn([E, S, k], (ot) => {
      De = qr(De, ot, " ");
    }), F && Pn ? F.createHTML(De) : De;
  }, r.setConfig = function() {
    let W = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Zi(W), ne = !0;
  }, r.clearConfig = function() {
    hr = null, ne = !1;
  }, r.isValidAttribute = function(W, _, R) {
    hr || Zi({});
    const q = ge(W), ue = ge(_);
    return sa(q, ue, R);
  }, r.addHook = function(W, _) {
    typeof _ == "function" && Jr(y[W], _);
  }, r.removeHook = function(W, _) {
    if (_ !== void 0) {
      const R = ry(y[W], _);
      return R === -1 ? void 0 : ny(y[W], R, 1)[0];
    }
    return dl(y[W]);
  }, r.removeHooks = function(W) {
    y[W] = [];
  }, r.removeAllHooks = function() {
    y = El();
  }, r;
}
var Ey = qc();
const My = (t, r, e) => {
  r.control && r.controlOptions ? e.options.toggleMode(r.control.type, r.control.targetMode) : N.error("Control or controlOptions not defined", r.control, r.controlOptions);
};
var by = /* @__PURE__ */ it("<div><!></div>"), xy = /* @__PURE__ */ it('<div class="control-container svelte-1rd72r"><button type="button"><!></button> <!></div>');
function _y(t, r) {
  var u;
  Dr(r, !0);
  const e = (u = r.controlOptions) != null && u.icon ? Ey.sanitize(r.controlOptions.icon.trim()) : null, n = Go("gm"), i = n.control.getDefaultPosition();
  var s = Pr(), o = Jt(s);
  {
    var a = (l) => {
      var c = xy(), h = Bt(c);
      let d;
      h.__click = [My, r, n];
      var v = Bt(h);
      {
        var M = (g) => {
          var D = Pr(), F = Jt(D);
          Av(F, () => e), de(g, D);
        }, A = (g, D) => {
          {
            var F = (B) => {
              var H = ol();
              _t((f) => Sr(H, f), [
                () => r.controlOptions.title.slice(0, 2)
              ]), de(B, H);
            }, G = (B) => {
              var H = ol();
              _t(() => Sr(H, r.control.targetMode)), de(B, H);
            };
            ct(
              g,
              (B) => {
                r.controlOptions.title ? B(F) : B(G, !1);
              },
              D
            );
          }
        };
        ct(v, (g) => {
          r.controlOptions.icon ? g(M) : g(A, !1);
        });
      }
      var P = gi(h, 2);
      {
        var C = (g) => {
          var D = by();
          let F;
          var G = Bt(D);
          Kv(G, {
            get control() {
              return r.control;
            }
          }), _t((B, H) => F = Js(D, 1, "control-menu svelte-1rd72r", null, F, { "menu-right": B, "menu-left": H }), [
            () => i.endsWith("left"),
            () => i.endsWith("right")
          ]), de(g, D);
        };
        ct(P, (g) => {
          r.controlOptions.active && g(C);
        });
      }
      _t(() => {
        Xt(h, "id", `id_${r.control.type}_${r.control.targetMode}`), d = Js(h, 1, `gm-control-button ${r.control.type}-${r.control.targetMode}`, "svelte-1rd72r", d, { active: r.controlOptions.active }), Xt(h, "title", r.controlOptions.title);
      }), de(l, c);
    };
    ct(o, (l) => {
      r.control && r.controlOptions && r.controlOptions.uiEnabled && l(a);
    });
  }
  de(t, s), Or();
}
zo(["click"]);
var Sy = /* @__PURE__ */ it("<div></div>"), Ay = /* @__PURE__ */ it('<div class="gm-reactive-controls svelte-16ufo3a"></div>');
function Ly(t, r) {
  Dr(r, !1);
  const [e, n] = Ov();
  let s = Dv(Vs, "$controlsStore", e), o = s.controls, a = Y1(s.options);
  const l = `${Go("gm").mapAdapter.mapType}gl`, c = Vs.subscribe((v) => {
    o = v.controls, Ee(a, v.options);
  });
  Gv(c);
  const h = (v, M) => {
    const A = o == null ? void 0 : o[v];
    return (A == null ? void 0 : A[M]) || null;
  };
  Fv();
  var d = Ay();
  vn(d, 5, () => Object.entries(Q(a)), mn, (v, M) => {
    let A = () => Q(M)[0], P = () => Q(M)[1];
    var C = Sy();
    vn(C, 5, () => Object.entries(P()), mn, (g, D) => {
      let F = () => Q(D)[0], G = () => Q(D)[1];
      var B = Pr();
      const H = /* @__PURE__ */ vc(() => h(A(), F()));
      var f = Jt(B);
      {
        var p = (m) => {
          _y(m, {
            get control() {
              return Q(H);
            },
            get controlOptions() {
              return G();
            }
          });
        };
        ct(f, (m) => {
          Q(H) && m(p);
        });
      }
      de(g, B);
    }), _t(() => Js(C, 1, `${l}-ctrl ${l}-ctrl-group group-${A()}`, "svelte-16ufo3a")), de(v, C);
  }), de(t, d), Or(), n();
}
class Cy {
  constructor(r) {
    w(this, "gm");
    this.gm = r;
  }
}
class ky extends Cy {
  constructor() {
    super(...arguments);
    w(this, "controls", je(Zl));
    w(this, "reactiveControls", null);
    w(this, "container");
    w(this, "mapEventHandlers", {
      [`${Y}:draw`]: this.handleModeEvent.bind(this),
      [`${Y}:edit`]: this.handleModeEvent.bind(this),
      [`${Y}:helper`]: this.handleModeEvent.bind(this)
    });
  }
  onAdd() {
    if (this.createControls(), this.gm.events.bus.attachEvents(this.mapEventHandlers), !this.container)
      throw new Error("Controls container is not initialized");
    return this.container;
  }
  createControls(e = void 0) {
    if (this.controlsAdded()) {
      N.warn("Can't add controls: controls already added");
      return;
    }
    this.container = e || this.createHtmlContainer(), this.createReactivePanel();
  }
  onRemove() {
    this.gm.events.bus.detachEvents(this.mapEventHandlers), this.reactiveControls && (Mv(this.reactiveControls), this.reactiveControls = null), this.container && this.container.parentNode && this.container.parentNode.removeChild(this.container), this.container = void 0;
  }
  handleModeEvent(e) {
    return xo(e) ? (["mode_started", "mode_ended"].includes(e.action) && this.updateReactivePanel(), { next: !0 }) : { next: !0 };
  }
  controlsAdded() {
    return !!this.reactiveControls;
  }
  createReactivePanel() {
    if (!this.container) {
      N.error("Can't create reactive panel: container is not initialized");
      return;
    }
    this.syncModeStates();
    const e = /* @__PURE__ */ new Map();
    e.set("gm", this.gm), this.reactiveControls = wv(
      Ly,
      {
        target: this.container,
        context: e
      }
    ), this.updateReactivePanel();
  }
  updateReactivePanel() {
    Vs.update(() => ({
      controls: this.controls,
      options: this.gm.options.controls
    }));
  }
  createHtmlContainer() {
    const e = document.createElement("div");
    return e.classList.add("geoman-controls"), e;
  }
  syncModeStates() {
    this.eachControlWithOptions(({ control: e }) => {
      this.gm.options.syncModeState(e.type, e.targetMode);
    });
  }
  eachControlWithOptions(e) {
    return Re(this.controls).forEach((n) => {
      const i = this.controls[n];
      return Object.keys(i).forEach((s) => {
        const o = s, a = this.getControl({ actionType: n, modeName: o }), u = this.gm.options.getControlOptions({ actionType: n, modeName: o });
        a && u ? e({ control: a, controlOptions: u }) : N.error("Can't find control/controlOptions for", n, o);
      });
    });
  }
  getControl({ actionType: e, modeName: n }) {
    return e && n && this.controls[e][n] || null;
  }
  getDefaultPosition() {
    return this.gm.options.settings.controlsPosition;
  }
}
const Ty = `_${Y}`;
class Py {
  constructor(r) {
    w(this, "gm");
    w(this, "globalEventsListener", null);
    this.gm = r;
  }
  get map() {
    return this.gm.mapAdapter.getMapInstance();
  }
  processEvent(r, e) {
    this.fireToMap(
      "system",
      r.split(":")[1],
      { ...e, level: "user" }
    ), e.action === "mode_start" || e.action === "mode_end" ? this.forwardModeToggledEvent(e) : e.action === "feature_created" ? this.forwardFeatureCreated(e) : e.action === "feature_removed" ? this.forwardFeatureRemoved(e) : e.action === "feature_updated" ? this.forwardFeatureUpdated(e) : e.action === "feature_edit_start" ? this.forwardFeatureEditStart(e) : e.action === "feature_edit_end" ? this.forwardFeatureEditEnd(e) : (e.action === "loaded" || e.action === "unloaded") && this.forwardGeomanLoaded(e);
  }
  forwardModeToggledEvent(r) {
    const e = r.action === "mode_start";
    let n;
    if (r.type === "draw") {
      const i = "globaldrawmodetoggled";
      n = { enabled: e, shape: r.mode, map: this.map }, this.fireToMap("converted", i, n), n = { shape: r.mode, map: this.map }, this.fireToMap("converted", e ? "drawstart" : "drawend", n);
    } else if (r.type === "edit") {
      const i = this.getConvertedEditModeName(r.mode);
      n = { enabled: e, map: this.map }, this.fireToMap("converted", `global${i}modetoggled`, n);
    } else r.type === "helper" && (n = { enabled: e, map: this.map }, this.fireToMap("converted", `global${r.mode}modetoggled`, n));
  }
  forwardFeatureCreated(r) {
    const e = {
      shape: r.mode,
      feature: r.featureData,
      map: this.map
    };
    this.fireToMap("converted", "create", e);
  }
  forwardFeatureRemoved(r) {
    const e = {
      shape: r.mode,
      feature: r.featureData,
      map: this.map
    };
    this.fireToMap("converted", "remove", e);
  }
  forwardFeatureUpdated(r) {
    const e = ["lasso"], n = {
      map: this.map
    };
    r.sourceFeatures.length === 1 && !e.includes(r.mode) ? n.originalFeature = r.sourceFeatures[0] : n.originalFeatures = r.sourceFeatures, r.targetFeatures.length === 1 && !e.includes(r.mode) ? (n.feature = r.targetFeatures[0], n.shape = n.feature.shape) : n.features = r.targetFeatures;
    const i = this.getConvertedEditModeName(r.mode);
    this.fireToMap("converted", `${i}`, n);
  }
  forwardFeatureEditStart(r) {
    const e = this.getConvertedEditModeName(r.mode), n = {
      shape: r.feature.shape,
      feature: r.feature,
      map: this.map
    };
    this.fireToMap("converted", `${e}start`, n);
  }
  forwardFeatureEditEnd(r) {
    const e = this.getConvertedEditModeName(r.mode), n = {
      shape: r.feature.shape,
      feature: r.feature,
      map: this.map
    };
    this.fireToMap("converted", `${e}end`, n);
  }
  forwardGeomanLoaded(r) {
    this.fireToMap(
      "converted",
      `${r.action}`,
      { map: this.map, [Y]: this.gm }
    );
  }
  fireToMap(r, e, n) {
    const s = `${r === "system" ? Ty : Y}:${e}`;
    this.globalEventsListener && this.globalEventsListener({ type: r, name: s, payload: n }), this.gm.mapAdapter.fire(s, n);
  }
  getConvertedEditModeName(r) {
    return r === "change" ? "edit" : r;
  }
}
class Iy {
  constructor(r) {
    w(this, "gm");
    w(this, "forwarder");
    w(this, "mapEventHandlers", {});
    w(this, "gmEventHandlers", {});
    this.gm = r, this.forwarder = new Py(r);
  }
  fireEvent(r, e) {
    const n = this.gmEventHandlers[r];
    if (!n)
      return;
    const { controlHandler: i } = n;
    i(e), this.forwarder.processEvent(r, e);
  }
  attachEvents(r) {
    Re(r).forEach((e) => {
      const n = r[e];
      n && this.on(e, n);
    });
  }
  detachEvents(r) {
    Re(r).forEach((e) => {
      const n = r[e];
      n && this.off(e, n);
    });
  }
  on(r, e) {
    r.startsWith(Y) ? this.onGmEvent(r, e) : this.onMapEvent(r, e);
  }
  onGmEvent(r, e) {
    var n;
    this.gmEventHandlers[r] || (this.gmEventHandlers[r] = this.createEventSection(r)), (n = this.gmEventHandlers[r]) == null || n.handlers.unshift(e);
  }
  onMapEvent(r, e) {
    var n;
    if (!this.mapEventHandlers[r]) {
      const i = this.createEventSection(r);
      this.gm.mapAdapter.on(r, i.controlHandler), this.mapEventHandlers[r] = i;
    }
    (n = this.mapEventHandlers[r]) == null || n.handlers.unshift(e);
  }
  off(r, e) {
    r.startsWith(`${Y}`) ? this.offGmEvent(r, e) : this.offMapEvent(r, e);
  }
  offGmEvent(r, e) {
    var s;
    const n = ((s = this.gmEventHandlers[r]) == null ? void 0 : s.handlers) || [], i = n.findIndex(
      (o) => e === o
    );
    i === -1 ? N.warn("MapEvents: handler not found", r, e) : (n.splice(i, 1), n.length === 0 && delete this.gmEventHandlers[r]);
  }
  offMapEvent(r, e) {
    var s, o;
    const n = ((s = this.mapEventHandlers[r]) == null ? void 0 : s.handlers) || [], i = n.findIndex(
      (a) => e === a
    );
    if (i === -1)
      N.warn("MapEvents: handler not found", r, e);
    else if (n.splice(i, 1), n.length === 0) {
      const a = (o = this.mapEventHandlers[r]) == null ? void 0 : o.controlHandler;
      a && this.gm.mapAdapter.off(r, a), delete this.mapEventHandlers[r];
    }
  }
  createEventSection(r) {
    return {
      handlers: [],
      controlHandler: (e) => {
        let n;
        if (zt(e) && r.startsWith(`${Y}`) ? n = this.gmEventHandlers[r] : n = this.mapEventHandlers[r], !n) {
          N.debug(`No handlers for eventName: "${r}"`);
          return;
        }
        n.handlers.some((i) => {
          let s;
          return zt(e), s = i(e), s && typeof s == "object" && "next" in s ? !s.next : (N.error('EventsBus: handler should return an object with a "next" property'), !1);
        });
      }
    };
  }
}
class Fy extends Fi {
  constructor(e, n) {
    super(e);
    w(this, "mapEventHandlers", {
      [`${Y}:control`]: this.handleControlEvent.bind(this)
    });
    n.attachEvents(this.mapEventHandlers);
  }
  handleControlEvent(e) {
    return Wu(e) ? (this.getControl(e) || N.error("Control not found, event payload", e), { next: !0 }) : { next: !0 };
  }
}
class Vc extends Pt {
  constructor() {
    super(...arguments);
    w(this, "mode", "circle");
    w(this, "shape", "circle");
    w(this, "circleCenterPoint", null);
    w(this, "circleCenterLngLat", null);
    w(this, "mapEventHandlers", {
      mousemove: this.onMouseMove.bind(this),
      click: this.onMouseClick.bind(this)
    });
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  createFeature() {
    const e = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(this.circleCenterLngLat || [0, 0]),
      sourceName: O.temporary
    });
    return e && this.circleCenterLngLat && e.setShapeProperty("center", this.circleCenterLngLat), e;
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: e
      }
    };
  }
  createMarker() {
    const e = document.createElement("div");
    e.innerHTML = Xl;
    const n = e.firstChild;
    return n.style.color = "#278cda", n.style.width = "28px", n.style.height = "28px", n.style.pointerEvents = "none", this.gm.mapAdapter.createDomMarker({
      draggable: !1,
      anchor: "center",
      element: n
    }, [0, 0]);
  }
  getControlMarkerData() {
    const e = this.gm.markerPointer.marker;
    return e ? {
      type: "dom",
      instance: e,
      position: {
        coordinate: e.getLngLat(),
        path: [-1]
      }
    } : null;
  }
  fireStartEvent(e, n) {
    const i = {
      level: "system",
      type: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: e,
      markerData: n
    };
    this.gm.events.fire(`${Y}:draw`, i);
  }
  fireUpdateEvent(e, n) {
    const i = {
      level: "system",
      type: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: e,
      markerData: n
    };
    this.gm.events.fire(`${Y}:draw`, i);
  }
  fireFinishEvent() {
    const e = {
      level: "system",
      type: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${Y}:draw`, e);
  }
}
class Dy extends Vc {
  constructor() {
    super(...arguments);
    w(this, "mode", "circle_marker");
    w(this, "shape", "circle_marker");
  }
  onStartAction() {
    this.gm.markerPointer.enable({
      customMarker: this.createMarker()
    });
  }
  onEndAction() {
    this.fireMarkerPointerFinishEvent(), super.onEndAction();
  }
  onMouseMove() {
    return this.fireMarkerPointerUpdateEvent(), { next: !0 };
  }
  onMouseClick(e) {
    var i;
    const n = ((i = this.gm.markerPointer.marker) == null ? void 0 : i.getLngLat()) || e.lngLat.toArray();
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(n)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(), this.circleCenterLngLat = n, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.updateFeaturePosition(this.circleCenterLngLat), this.saveFeature()), { next: !1 };
  }
  updateFeaturePosition(e) {
    if (!this.featureData)
      return;
    const n = this.getFeatureGeoJson(e);
    this.featureData.updateGeoJsonGeometry(n.geometry);
  }
}
const Oy = () => "ontouchstart" in window || navigator.maxTouchPoints > 0 || matchMedia("(hover: none)").matches ? !0 : "msMaxTouchPoints" in navigator && typeof navigator.msMaxTouchPoints == "number" && navigator.msMaxTouchPoints > 0, Rr = (t, r, e = 10) => {
  const n = { ...t };
  return Re(t).forEach((i) => {
    const s = t[i];
    typeof s == "function" ? n[i] = Ou(
      s.bind(r),
      e,
      { leading: !0, trailing: !1 }
    ) : N.error("convertToThrottled: item is not a function", t[i]);
  }), n;
}, Gy = (t, r, e = 10) => {
  const n = { ...t };
  return Re(t).forEach((i) => {
    const s = t[i];
    typeof s == "function" ? n[i] = wo(
      s.bind(r),
      e,
      { leading: !1, trailing: !0 }
    ) : N.error("convertToDebounced: item is not a function", t[i]);
  }), n;
};
class Ry extends Vc {
  constructor() {
    super(...arguments);
    w(this, "mode", "circle");
    w(this, "shape", "circle");
    w(this, "throttledMethods", Rr({
      updateFeatureGeoJson: this.updateFeatureGeoJson
    }, this, this.gm.options.settings.throttlingDelay));
  }
  onMouseClick(e) {
    var i;
    if (!ve(e))
      return { next: !0 };
    const n = ((i = this.gm.markerPointer.marker) == null ? void 0 : i.getLngLat()) || e.lngLat.toArray();
    if (this.circleCenterPoint && this.circleCenterLngLat)
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, n)]
      }), this.flags.featureCreateAllowed && (this.saveCircleFeature(n), this.circleCenterLngLat = null, this.circleCenterPoint = null, this.fireFinishEvent());
    else if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(n)] }), this.flags.featureCreateAllowed) {
      this.circleCenterLngLat = n, this.circleCenterPoint = this.gm.mapAdapter.project(this.circleCenterLngLat), this.featureData = this.createFeature();
      const s = this.getControlMarkerData();
      this.featureData && s && this.fireStartEvent(this.featureData, s);
    }
    return { next: !1 };
  }
  onMouseMove() {
    if (this.circleCenterLngLat && this.gm.markerPointer.marker) {
      const e = this.gm.markerPointer.marker.getLngLat();
      this.fireBeforeFeatureCreate({
        geoJsonFeatures: [this.getCircleGeoJson(this.circleCenterLngLat, e)]
      }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeatureGeoJson(e);
    }
    return this.circleCenterPoint || this.fireMarkerPointerUpdateEvent(), { next: !1 };
  }
  updateFeatureGeoJson(e) {
    if (this.featureData && this.circleCenterLngLat) {
      const n = this.getCircleGeoJson(this.circleCenterLngLat, e);
      this.featureData.updateGeoJsonGeometry(n.geometry);
      const i = this.getControlMarkerData();
      i && this.fireUpdateEvent(this.featureData, i);
    }
  }
  saveCircleFeature(e) {
    var n;
    if (this.circleCenterLngLat && this.featureData) {
      const i = ((n = this.gm.markerPointer.marker) == null ? void 0 : n.getLngLat()) || e;
      this.updateFeatureGeoJson(i), this.featureData.setShapeProperty("center", this.circleCenterLngLat), this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature();
    }
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? Ju(this.featureData.getGeoJson()) : !1;
  }
  getCircleGeoJson(e, n) {
    const i = this.gm.mapAdapter.getDistance(e, n);
    return {
      ...bo({ center: e, radius: i }),
      properties: {
        shape: this.shape
      }
    };
  }
}
function By(t, r, {
  ignoreSelfIntersections: e = !0
} = { ignoreSelfIntersections: !0 }) {
  let n = !0;
  return Ht(t, (i) => {
    Ht(r, (s) => {
      if (n === !1)
        return !1;
      n = Ny(
        i.geometry,
        s.geometry,
        e
      );
    });
  }), n;
}
function Ny(t, r, e) {
  switch (t.type) {
    case "Point":
      switch (r.type) {
        case "Point":
          return !Jy(t.coordinates, r.coordinates);
        case "LineString":
          return !Ml(r, t);
        case "Polygon":
          return !nr(t, r);
      }
      break;
    case "LineString":
      switch (r.type) {
        case "Point":
          return !Ml(t, r);
        case "LineString":
          return !Uy(t, r, e);
        case "Polygon":
          return !bl(r, t, e);
      }
      break;
    case "Polygon":
      switch (r.type) {
        case "Point":
          return !nr(r, t);
        case "LineString":
          return !bl(t, r, e);
        case "Polygon":
          return !Hy(r, t, e);
      }
  }
  return !1;
}
function Ml(t, r) {
  for (let e = 0; e < t.coordinates.length - 1; e++)
    if (zy(
      t.coordinates[e],
      t.coordinates[e + 1],
      r.coordinates
    ))
      return !0;
  return !1;
}
function Uy(t, r, e) {
  return _n(t, r, {
    ignoreSelfIntersections: e
  }).features.length > 0;
}
function bl(t, r, e) {
  for (const i of r.coordinates)
    if (nr(i, t))
      return !0;
  return _n(r, _s(t), {
    ignoreSelfIntersections: e
  }).features.length > 0;
}
function Hy(t, r, e) {
  for (const i of t.coordinates[0])
    if (nr(i, r))
      return !0;
  for (const i of r.coordinates[0])
    if (nr(i, t))
      return !0;
  return _n(
    _s(t),
    _s(r),
    { ignoreSelfIntersections: e }
  ).features.length > 0;
}
function zy(t, r, e) {
  const n = e[0] - t[0], i = e[1] - t[1], s = r[0] - t[0], o = r[1] - t[1];
  return n * o - i * s !== 0 ? !1 : Math.abs(s) >= Math.abs(o) ? s > 0 ? t[0] <= e[0] && e[0] <= r[0] : r[0] <= e[0] && e[0] <= t[0] : o > 0 ? t[1] <= e[1] && e[1] <= r[1] : r[1] <= e[1] && e[1] <= t[1];
}
function Jy(t, r) {
  return t[0] === r[0] && t[1] === r[1];
}
function qy(t, r, e = {}) {
  let n;
  return e.final ? n = xl(he(r), he(t)) : n = xl(he(t), he(r)), n > 180 ? -(360 - n) : n;
}
function xl(t, r) {
  const e = me(t[1]), n = me(r[1]);
  let i = me(r[0] - t[0]);
  i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI);
  const s = Math.log(
    Math.tan(n / 2 + Math.PI / 4) / Math.tan(e / 2 + Math.PI / 4)
  ), o = Math.atan2(i, s);
  return (Ar(o) + 360) % 360;
}
function Vy(t, r, e = {}) {
  const n = he(t), i = he(r);
  i[0] += i[0] - n[0] > 180 ? -360 : n[0] - i[0] > 180 ? 360 : 0;
  const s = Yy(n, i);
  return ru(s, "meters", e.units);
}
function Yy(t, r, e) {
  e = e === void 0 ? we : Number(e);
  const n = e, i = t[1] * Math.PI / 180, s = r[1] * Math.PI / 180, o = s - i;
  let a = Math.abs(r[0] - t[0]) * Math.PI / 180;
  a > Math.PI && (a -= 2 * Math.PI);
  const u = Math.log(
    Math.tan(s / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)
  ), l = Math.abs(u) > 1e-11 ? o / u : Math.cos(i);
  return Math.sqrt(
    o * o + l * l * a * a
  ) * n;
}
function Wy(t, r, e, n = {}) {
  const i = r < 0;
  let s = ru(
    Math.abs(r),
    n.units,
    "meters"
  );
  i && (s = -Math.abs(s));
  const o = he(t), a = $y(
    o,
    s,
    e
  );
  return a[0] += a[0] - o[0] > 180 ? -360 : o[0] - a[0] > 180 ? 360 : 0, Rt(a, n.properties);
}
function $y(t, r, e, n) {
  n = n === void 0 ? we : Number(n);
  const i = r / n, s = t[0] * Math.PI / 180, o = me(t[1]), a = me(e), u = i * Math.cos(a);
  let l = o + u;
  Math.abs(l) > Math.PI / 2 && (l = l > 0 ? Math.PI - l : -Math.PI - l);
  const c = Math.log(
    Math.tan(l / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)
  ), h = Math.abs(c) > 1e-11 ? u / c : Math.cos(o), d = i * Math.sin(a) / h;
  return [
    ((s + d) * 180 / Math.PI + 540) % 360 - 180,
    l * 180 / Math.PI
  ];
}
const Yc = [
  "drag",
  "change",
  "rotate",
  "scale",
  "copy",
  "cut",
  "split",
  "union",
  "difference",
  "line_simplification",
  "lasso",
  "delete"
];
class kn extends _o {
  constructor() {
    super(...arguments);
    w(this, "actionType", "edit");
    w(this, "featureData", null);
    w(this, "cursorExcludedLayerIds", [
      "rectangle-line",
      "polygon-line",
      "circle-line"
    ]);
    w(this, "layerEventHandlersData", []);
  }
  startAction() {
    this.setEventsForLayers("mouseenter", this.setCursorToPointer.bind(this)), this.setEventsForLayers("mouseleave", this.setCursorToEmpty.bind(this)), super.startAction();
  }
  endAction() {
    this.clearEventsForLayers(), super.endAction();
  }
  setCursorToPointer() {
    this.gm.mapAdapter.setCursor("pointer");
  }
  setCursorToEmpty() {
    this.gm.mapAdapter.setCursor("");
  }
  setEventsForLayers(e, n) {
    this.gm.features.layers.map((s) => s.id).filter(
      (s) => !this.cursorExcludedLayerIds.some((o) => s.includes(o))
    ).forEach((s) => {
      this.gm.mapAdapter.on(e, s, n), this.layerEventHandlersData.push({ eventName: e, layerId: s, callback: n });
    });
  }
  clearEventsForLayers() {
    this.layerEventHandlersData.forEach(({ eventName: e, layerId: n, callback: i }) => {
      this.gm.mapAdapter.off(e, n, i);
    }), this.layerEventHandlersData = [];
  }
  updateFeatureGeoJson({ featureData: e, featureGeoJson: n, forceMode: i = void 0 }) {
    return this.flags.featureUpdateAllowed ? (e.shape === "circle" && n.properties.center && e.setShapeProperty("center", n.properties.center), e.updateGeoJsonGeometry(n.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [e],
      targetFeatures: [e],
      forceMode: i
    }), !0) : !1;
  }
  fireFeatureUpdatedEvent({ sourceFeatures: e, targetFeatures: n, markerData: i = void 0, forceMode: s = void 0 }) {
    const o = {
      level: "system",
      type: "edit",
      action: "feature_updated",
      mode: s || this.mode,
      sourceFeatures: e,
      targetFeatures: n,
      markerData: i || null
    };
    this.gm.events.fire(`${Y}:edit`, o);
  }
  fireFeatureEditStartEvent({ feature: e, forceMode: n = void 0 }) {
    const i = {
      level: "system",
      type: "edit",
      action: "feature_edit_start",
      mode: n || this.mode,
      feature: e
    };
    this.gm.events.fire(`${Y}:edit`, i);
  }
  fireFeatureEditEndEvent({ feature: e, forceMode: n = void 0 }) {
    const i = {
      level: "system",
      type: "edit",
      action: "feature_edit_end",
      mode: n || this.mode,
      feature: e
    };
    this.gm.events.fire(`${Y}:edit`, i);
  }
  fireMarkerPointerUpdateEvent() {
    if (!this.gm.markerPointer.marker)
      return;
    const e = this.gm.markerPointer.marker, n = {
      level: "system",
      variant: null,
      type: "draw",
      mode: this.getLineDrawerMode(),
      action: "update",
      markerData: {
        type: "dom",
        instance: e,
        position: {
          coordinate: e.getLngLat(),
          path: [-1]
        }
      },
      featureData: null
    };
    this.gm.events.fire(`${Y}:draw`, n);
  }
  forwardLineDrawerEvent(e) {
    if (!$u(e) || !["cut", "split"].includes(this.mode))
      return { next: !0 };
    if (e.action === "start" || e.action === "update") {
      const n = {
        level: "system",
        type: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: e.action,
        featureData: e.featureData,
        markerData: e.markerData
      };
      this.gm.events.fire(`${Y}:draw`, n);
    } else if (e.action === "finish" || e.action === "cancel") {
      const n = {
        level: "system",
        type: "draw",
        mode: this.getLineDrawerMode(),
        variant: null,
        action: e.action
      };
      this.gm.events.fire(`${Y}:draw`, n);
    }
    return { next: !0 };
  }
  fireFeatureRemovedEvent(e) {
    if (Kt(e.shape, ci)) {
      const n = {
        level: "system",
        type: "edit",
        mode: e.shape,
        action: "feature_removed",
        featureData: e
      };
      this.gm.events.fire(`${Y}:edit`, n);
    }
  }
  getLineDrawerMode() {
    return this.mode === "cut" ? "polygon" : (this.mode === "split", "line");
  }
}
const Wc = [
  "shape_markers",
  "pin",
  "snapping",
  "snap_guides",
  "measurements",
  "auto_trace",
  "geofencing",
  "zoom_to_features",
  "click_to_edit"
];
class ar extends _o {
  constructor() {
    super(...arguments);
    w(this, "actionType", "helper");
  }
}
const Br = (t) => zt(t) && t.type === "edit", jy = (t) => Hm.includes(t), Zy = (t) => ju.includes(t), Xy = (t) => Yc.includes(t), Ky = (t) => Wc.includes(t), Qy = (t) => Zy(t) || Xy(t) || Ky(t), $s = (t, r) => (t % r + r) % r;
class $c extends ar {
  constructor() {
    super(...arguments);
    w(this, "mode", "snap_guides");
    w(this, "features", /* @__PURE__ */ new Map());
    w(this, "mapEventHandlers", {});
  }
  onStartAction() {
  }
  onEndAction() {
    this.removeSnapGuides();
  }
  updateSnapGuides(e, n, i = !1) {
    var o;
    const s = new Set(this.features.keys());
    e && n && this.getSnapGuidesLines(
      e,
      n,
      i
    ).forEach((u) => {
      const l = JSON.stringify(u);
      if (this.features.has(l)) {
        s.delete(l);
        return;
      }
      const c = [
        this.createGuideLine(u, { orthogonal: !1 }),
        this.createGuideLine(u, { orthogonal: !0 })
      ].filter((h) => h !== null);
      c.length && this.features.set(l, c);
    }), s.forEach((a) => this.removeSnapGuide(a)), (o = this.snappingHelper) == null || o.setCustomSnappingCoordinates(
      this.mode,
      this.getGuideLinesIntersections()
    );
  }
  removeSnapGuides() {
    this.features.forEach((e) => {
      e.forEach((n) => {
        var i;
        (i = this.snappingHelper) == null || i.removeCustomSnappingFeature(n.featureData), this.gm.features.delete(n.featureData);
      });
    }), this.features.clear();
  }
  removeSnapGuide(e) {
    const n = this.features.get(e);
    n == null || n.forEach((i) => {
      var s;
      (s = this.snappingHelper) == null || s.removeCustomSnappingFeature(i.featureData), this.gm.features.delete(i.featureData);
    }), this.features.delete(e);
  }
  getGuideLinesIntersections() {
    const e = [], n = Array.from(
      this.features.values()
    ).flat().map(
      (i) => i.lineLngLats
    ).map(
      (i) => i.map((s) => this.gm.mapAdapter.project(s))
    );
    for (let i = 0; i < n.length; i += 1)
      for (let s = i + 1; s < n.length; s += 1)
        if (n[i].length === 2 || n[s].length === 2) {
          const o = this.getLinesIntersection(
            n[i],
            n[s]
          );
          if (o) {
            const a = this.gm.mapAdapter.unproject(o);
            Cm(this.gm.globalLngLatBounds, a) && e.push(a);
          }
        }
    return Is(e, Mn);
  }
  getSnapGuidesLines(e, n, i = !1) {
    const s = [], o = Nu(e, n);
    if (!o)
      return N.error("getSnapGuidesCoordsForLine: position not found"), [];
    const a = o.path.slice(0, -1), u = je(rr(e, a, []));
    u.length > 2 && on(u[0], u.at(-1)) && u.pop();
    const l = o.path.at(-1), c = $s(l + 1, u.length), h = $s(l - 1, u.length);
    if (u.length === 1) {
      const d = u[h];
      return s.push([d, [d[0] + 0.1, d[1]]]), s;
    }
    return l === u.length - 1 ? (s.push([u[0], u[1]]), i ? s.push([u[l], u[l - 1]]) : u.length > 2 && s.push([u[l - 1], u[l - 2]]), s) : (s.push([u[h], u[l]]), h !== c && s.push([u[c], u[l]]), s);
  }
  createGuideLine(e, { orthogonal: n }) {
    if (on(e[0], e[1]))
      return null;
    const i = this.getGuideLineLngLats(e, { orthogonal: n });
    if (!i)
      return null;
    const s = this.createGuideLineFeature(i);
    return s ? {
      lineLngLats: [i[0], i[1]],
      featureData: s
    } : null;
  }
  getGuideLineLngLats(e, { orthogonal: n }) {
    const i = this.gm.mapAdapter.project(e[0]), s = this.gm.mapAdapter.project(e[1]);
    let o = [i, s];
    n && (o = this.rotateLine90Degrees(o));
    const a = this.getLineBoundsCoordinates(o);
    return a ? a.map((u) => this.gm.mapAdapter.unproject(u)) : null;
  }
  createGuideLineFeature(e) {
    var i;
    const n = this.gm.features.createFeature({
      shapeGeoJson: this.getLineGeoJson(e),
      sourceName: O.temporary
    });
    return n ? ((i = this.snappingHelper) == null || i.addCustomSnappingFeature(n), n) : null;
  }
  getLineGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: "snap_guide"
      },
      geometry: {
        type: "LineString",
        coordinates: e
      }
    };
  }
  rotateLine90Degrees(e) {
    const [n, i] = e, s = [i[0] - n[0], i[1] - n[1]], o = [-s[1], s[0]], a = [o[0] + n[0], o[1] + n[1]];
    return [n, a];
  }
  getLineBoundsCoordinates(e) {
    const n = this.getGlobalPlanarBounds(), s = [
      // coordIndex means "x" or "y" according to the given line
      { coordIndex: 0, boundsLine: [n.leftTop, n.rightTop] },
      { coordIndex: 1, boundsLine: [n.rightTop, n.rightBottom] },
      { coordIndex: 0, boundsLine: [n.leftBottom, n.rightBottom] },
      { coordIndex: 1, boundsLine: [n.leftTop, n.leftBottom] }
    ].map((o) => {
      const { coordIndex: a, boundsLine: u } = o, l = this.getLinesIntersection(e, o.boundsLine);
      return l && l[a] >= u[0][a] && l[a] <= u[1][a] ? l : null;
    }).filter(
      (o) => o !== null
    );
    return s.length !== 2 ? null : s;
  }
  getGlobalPlanarBounds() {
    const e = zu(this.gm.globalLngLatBounds), n = this.gm.mapAdapter.project([e[0], e[3]]), i = this.gm.mapAdapter.project([e[2], e[3]]), s = this.gm.mapAdapter.project([e[2], e[1]]), o = this.gm.mapAdapter.project([e[0], e[1]]);
    return {
      leftTop: n,
      rightTop: i,
      rightBottom: s,
      leftBottom: o
    };
  }
  getLinesIntersection(e, n) {
    const [i, s] = e[0], [o, a] = e[1], [u, l] = n[0], [c, h] = n[1], d = (i - o) * (l - h) - (s - a) * (u - c);
    return d === 0 ? null : [
      ((i * a - s * o) * (u - c) - (i - o) * (u * h - l * c)) / d,
      ((i * a - s * o) * (l - h) - (s - a) * (u * h - l * c)) / d
    ];
  }
}
const e2 = `<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21">
    <circle cx="10.5" cy="10.5" r="9.213" fill="#fff" stroke="#278cda" stroke-width="2.303"/>
</svg>
`, t2 = {
  dom: e2
}, jc = (t, r = void 0) => {
  const e = document.createElement("div");
  e.classList.add("marker-wrapper"), e.style.lineHeight = "0", e.innerHTML = t2[t];
  const n = e.firstChild;
  return r && Object.assign(n.style, r), e;
};
function r2(t, r = {}) {
  var e, n, i, s = r.properties, o = (e = r.autoComplete) != null ? e : !0, a = (n = r.orderCoords) != null ? n : !0, u = (i = r.mutate) != null ? i : !1;
  switch (u || (t = Oi(t)), t.type) {
    case "FeatureCollection":
      var l = [];
      return t.features.forEach(function(c) {
        l.push(
          He(_l(c, {}, o, a))
        );
      }), Ql(l, s);
    default:
      return _l(t, s, o, a);
  }
}
function _l(t, r, e, n) {
  r = r || (t.type === "Feature" ? t.properties : {});
  var i = wn(t), s = i.coordinates, o = i.type;
  if (!s.length) throw new Error("line must contain coordinates");
  switch (o) {
    case "LineString":
      return e && (s = Sl(s)), er([s], r);
    case "MultiLineString":
      var a = [], u = 0;
      return s.forEach(function(l) {
        if (e && (l = Sl(l)), n) {
          var c = n2(bt(un(l)));
          c > u ? (a.unshift(l), u = c) : a.push(l);
        } else
          a.push(l);
      }), er(a, r);
    default:
      throw new Error("geometry type " + o + " is not supported");
  }
}
function Sl(t) {
  var r = t[0], e = r[0], n = r[1], i = t[t.length - 1], s = i[0], o = i[1];
  return (e !== s || n !== o) && t.push(r), t;
}
function n2(t) {
  var r = t[0], e = t[1], n = t[2], i = t[3];
  return Math.abs(r - n) * Math.abs(e - i);
}
var Jo = r2;
class qo extends Pt {
  constructor(e, n = {
    snappingMarkers: "none",
    targetShape: "line"
  }) {
    super(e);
    w(this, "mode", "line");
    w(this, "snappingKey", "line_drawer");
    w(this, "drawOptions");
    w(this, "shapeLngLats", []);
    w(this, "throttledMethods", Rr({
      onMouseMove: this.onMouseMove
    }, this, this.gm.options.settings.throttlingDelay));
    w(this, "mapEventHandlers", {
      [`${Y}:helper`]: this.handleGmHelperEvent.bind(this),
      click: this.onMouseClick.bind(this),
      mousemove: this.throttledMethods.onMouseMove.bind(this)
    });
    w(this, "drawerEventHandlers", {
      firstMarkerClick: null,
      lastMarkerClick: null,
      nMarkerClick: null
    });
    this.drawOptions = n;
  }
  get snapGuidesInstance() {
    const e = this.gm.actionInstances.helper__snap_guides;
    return e instanceof $c ? e : null;
  }
  get autoTraceEnabled() {
    var e;
    return ((e = this.gm.options.controls.helper.auto_trace) == null ? void 0 : e.active) || !1;
  }
  get autoTraceHelperInstance() {
    return this.autoTraceEnabled && Object.values(this.gm.actionInstances).find(
      (e) => e instanceof ar && e.mode === "auto_trace"
    ) || null;
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    var e;
    this.gm.markerPointer.disable(), this.endShape(), (e = this.snapGuidesInstance) == null || e.removeSnapGuides();
  }
  handleGmHelperEvent(e) {
    return Di(e) ? (e.mode === "snap_guides" && e.action === "mode_start" && this.updateSnapGuides(), { next: !0 }) : (N.error("LineDrawer.handleGmHelperEvent: invalid event", e), { next: !0 });
  }
  updateSnapGuides() {
    var e;
    if (this.snapGuidesInstance) {
      const n = (e = this.featureData) == null ? void 0 : e.getGeoJson();
      n && n.geometry.coordinates.pop(), this.snapGuidesInstance.updateSnapGuides(
        n || null,
        this.shapeLngLats.at(-1) || null,
        !0
      );
    }
  }
  on(e, n) {
    this.drawerEventHandlers[e] = n;
  }
  onMouseClick(e) {
    var i;
    if (!ve(e, { warning: !0 }))
      return { next: !0 };
    const n = ((i = this.gm.markerPointer.marker) == null ? void 0 : i.getLngLat()) || e.lngLat.toArray();
    if (this.featureData) {
      const s = this.getClickedMarkerInfo(e);
      this.handleNextVertex(n, s);
    } else this.isFeatureAllowed(Om(n)) && this.startShape(n);
    return this.updateSnapGuides(), { next: !0 };
  }
  handleNextVertex(e, n) {
    var o, a, u, l, c, h;
    if (!this.featureData) {
      N.error("LineDrawer.handleNextVertex: no featureData");
      return;
    }
    const i = this.featureData.markers.size, s = this.getMarkerClickEventData(n.index);
    n.index < i - 1 && this.addPoint(e, n), n.index !== -1 && (n.index === 0 ? (a = (o = this.drawerEventHandlers).firstMarkerClick) == null || a.call(o, s) : n.index > 0 && n.index === i - 1 && ((l = (u = this.drawerEventHandlers).lastMarkerClick) == null || l.call(u, s)), n.index >= 0 && ((h = (c = this.drawerEventHandlers).nMarkerClick) == null || h.call(c, s)));
  }
  getMarkerClickEventData(e) {
    const n = this.getFeatureGeoJson({ withControlMarker: !1 });
    return {
      markerIndex: e,
      shapeCoordinates: this.getShapeCoordinates({ withControlMarker: !1 }),
      geoJson: n,
      bounds: Mo(n)
    };
  }
  onMouseMove(e) {
    return ve(e, { warning: !0 }) ? (this.featureData && this.shapeLngLats.length && this.updateFeatureSource(), { next: !0 }) : { next: !0 };
  }
  startShape(e) {
    this.shapeLngLats = [e], this.featureData = this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson({ withControlMarker: !0 }),
      sourceName: O.temporary
    });
    const n = {
      type: "dom",
      instance: this.createMarker(e),
      position: {
        coordinate: e,
        path: ["geometry", "coordinates", 0]
      }
    };
    this.featureData && (this.featureData.markers.set(
      n.position.path.join("."),
      n
    ), this.setSnapping(), this.fireStartEvent(this.featureData, n)), this.gm.mapAdapter.disableMapInteractions(["doubleClickZoom"]);
  }
  endShape() {
    this.removeSnapping(), this.removeTmpFeature(), this.shapeLngLats = [], this.gm.mapAdapter.enableMapInteractions(["doubleClickZoom"]), this.fireStopEvent();
  }
  setSnapping() {
    if (!this.snappingHelper)
      return;
    const e = this.drawOptions.snappingMarkers;
    e === "none" ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, []) : e === "all" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, this.shapeLngLats) : e === "first" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(this.snappingKey, [this.shapeLngLats[0]]) : e === "last" && this.shapeLngLats.length ? this.snappingHelper.setCustomSnappingCoordinates(
      this.snappingKey,
      [this.shapeLngLats[this.shapeLngLats.length - 1]]
    ) : N.error("LineDrawer.setSnapping: invalid data", e, this.shapeLngLats);
  }
  removeSnapping() {
    this.snappingHelper && this.snappingHelper.clearCustomSnappingCoordinates(this.snappingKey);
  }
  getClickedMarkerInfo(e) {
    if (!this.featureData)
      return { index: -1, path: null };
    let n = 0, i = null;
    try {
      this.featureData.markers.forEach((s, o) => {
        if (s.instance instanceof so) {
          const a = s.instance.getElement() || null, u = e.originalEvent.target, l = u instanceof Element ? u : null;
          if (a && a.contains(l))
            throw i = o, new Error("stop");
        }
        n += 1;
      });
    } catch {
      if (i)
        return { index: n, path: i };
    }
    return { index: -1, path: null };
  }
  addPoint(e, n) {
    const i = this.featureData;
    if (!i) {
      N.error("LineDrawer.addPoint: no featureData");
      return;
    }
    const s = this.getAddedLngLats(e, n), o = this.getFeatureGeoJsonWithType({
      withControlMarker: !0,
      coordinates: this.shapeLngLats.concat(s)
    });
    this.isFeatureAllowed(o) && (s.forEach((a) => {
      this.shapeLngLats.push(a);
      const u = this.addMarker(a, i);
      this.fireUpdateEvent(i, u);
    }), this.updateFeatureSource());
  }
  isFeatureAllowed(e) {
    return this.gm.getActiveDrawModes().length ? (this.fireBeforeFeatureCreate({ geoJsonFeatures: [e] }), this.flags.featureCreateAllowed) : !0;
  }
  getAddedLngLats(e, n) {
    if (!this.featureData)
      return N.error("LineDrawer.getCurrentLngLats: no featureData"), [];
    const s = this.getMarkerInfoLngLat(n) || e, o = this.getAutoTracePath(s);
    return [
      ...(o == null ? void 0 : o.slice(1, -1)) || [],
      s
    ];
  }
  getAutoTracePath(e) {
    const n = this.shapeLngLats.at(-1);
    return this.autoTraceEnabled && this.autoTraceHelperInstance && n && this.autoTraceHelperInstance.getShortestPath(
      n,
      e
    ) || null;
  }
  getMarkerInfoLngLat(e) {
    if (this.featureData && e.path) {
      const n = this.featureData.markers.get(e.path);
      if (n && n.type === "dom")
        return n.instance.getLngLat();
      N.error("LineDrawer.addPoint: no markerData", e);
    }
    return null;
  }
  addMarker(e, n) {
    const i = {
      type: "dom",
      instance: this.createMarker(e),
      position: {
        coordinate: e,
        path: ["geometry", "coordinates", this.shapeLngLats.length]
      }
    };
    return n.markers.set(
      i.position.path.join("."),
      {
        type: "dom",
        instance: i.instance,
        position: {
          coordinate: e,
          path: []
        }
      }
    ), i;
  }
  createMarker(e) {
    return this.gm.mapAdapter.createDomMarker({
      element: jc("dom", {
        pointerEvents: "auto",
        cursor: "pointer"
      }),
      anchor: "center"
    }, e);
  }
  updateFeatureSource() {
    if (this.featureData && (this.featureData.updateGeoJsonGeometry(
      this.getFeatureGeoJson({ withControlMarker: !0 }).geometry
    ), this.gm.markerPointer.marker)) {
      const e = {
        type: "dom",
        instance: this.gm.markerPointer.marker,
        position: {
          coordinate: this.gm.markerPointer.marker.getLngLat(),
          path: ["geometry", "coordinates", this.shapeLngLats.length]
        }
      };
      this.fireUpdateEvent(this.featureData, e);
    }
  }
  getFeatureGeoJson({ withControlMarker: e, coordinates: n = void 0 }) {
    return {
      type: "Feature",
      properties: {
        shape: "line"
      },
      geometry: {
        type: "LineString",
        coordinates: n || this.getShapeCoordinates({ withControlMarker: e })
      }
    };
  }
  getFeatureGeoJsonWithType({ withControlMarker: e, coordinates: n = void 0 }) {
    const i = this.getFeatureGeoJson({ withControlMarker: e, coordinates: n });
    return this.drawOptions.targetShape === "polygon" && i.geometry.coordinates.length > 3 ? Jo(
      i,
      { properties: i.properties }
    ) : i;
  }
  getShapeCoordinates({ withControlMarker: e }) {
    const n = [...this.shapeLngLats];
    return e && this.gm.markerPointer.marker && n.push(this.gm.markerPointer.marker.getLngLat()), n;
  }
  fireStartEvent(e, n) {
    this.gm.events.fire(
      `${Y}:draw`,
      {
        level: "system",
        type: "draw",
        mode: "line",
        variant: "line_drawer",
        action: "start",
        featureData: e,
        markerData: n
      }
    );
  }
  fireUpdateEvent(e, n) {
    this.gm.events.fire(
      `${Y}:draw`,
      {
        level: "system",
        type: "draw",
        mode: "line",
        variant: "line_drawer",
        action: "update",
        featureData: e,
        markerData: n
      }
    );
  }
  fireStopEvent() {
    this.gm.events.fire(
      `${Y}:draw`,
      {
        level: "system",
        type: "draw",
        mode: "line",
        action: "finish",
        variant: "line_drawer"
      }
    );
  }
}
class i2 extends Pt {
  constructor() {
    super(...arguments);
    w(this, "mode", "line");
    w(this, "shape", "line");
    w(this, "lineDrawer", new qo(
      this.gm,
      { snappingMarkers: "first", targetShape: "line" }
    ));
    w(this, "mapEventHandlers", {
      [`${Y}:draw`]: this.forwardLineDrawerEvent.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on("nMarkerClick", this.lineFinished.bind(this));
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(e) {
    return ve(e) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  lineFinished(e) {
    this.lineDrawer.endShape();
    let n = e.shapeCoordinates;
    return e.markerIndex > 0 && (n = n.slice(0, e.markerIndex + 1)), n.length < 2 ? null : this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(n),
      sourceName: O.main
    });
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "LineString",
        coordinates: e
      }
    };
  }
}
class s2 extends Pt {
  constructor() {
    super(...arguments);
    w(this, "mode", "marker");
    w(this, "shape", "marker");
    w(this, "mapEventHandlers", {
      click: this.onMouseClick.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    const e = this.createMarker();
    this.gm.markerPointer.enable({ customMarker: e }), this.fireMarkerPointerStartEvent();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseClick(e) {
    return ve(e) && (this.featureData = this.createFeature(e), this.featureData && this.saveFeature()), { next: !1 };
  }
  onMouseMove(e) {
    return !ve(e) || !this.gm.markerPointer.marker ? { next: !0 } : (this.fireMarkerPointerUpdateEvent(), { next: !0 });
  }
  createMarker() {
    const e = document.createElement("div");
    return e.style.backgroundImage = `url("${jl}")`, e.style.width = "36px", e.style.height = "36px", e.style.backgroundSize = "cover", e.style.pointerEvents = "none", this.gm.mapAdapter.createDomMarker({
      draggable: !1,
      anchor: "bottom",
      element: e
    }, [0, 0]);
  }
  createFeature(e) {
    var s;
    const n = ((s = this.gm.markerPointer.marker) == null ? void 0 : s.getLngLat()) || e.lngLat.toArray(), i = this.getFeatureGeoJson(n);
    return i && (this.fireBeforeFeatureCreate({ geoJsonFeatures: [i] }), this.flags.featureCreateAllowed) ? this.gm.features.createFeature({
      shapeGeoJson: i,
      sourceName: O.temporary
    }) : null;
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape
      },
      geometry: {
        type: "Point",
        coordinates: e
      }
    };
  }
}
function o2(t) {
  var r = {
    MultiPoint: {
      coordinates: [],
      properties: []
    },
    MultiLineString: {
      coordinates: [],
      properties: []
    },
    MultiPolygon: {
      coordinates: [],
      properties: []
    }
  };
  return Ut(t, (e) => {
    var n;
    switch ((n = e.geometry) == null ? void 0 : n.type) {
      case "Point":
        r.MultiPoint.coordinates.push(e.geometry.coordinates), r.MultiPoint.properties.push(e.properties);
        break;
      case "MultiPoint":
        r.MultiPoint.coordinates.push(...e.geometry.coordinates), r.MultiPoint.properties.push(e.properties);
        break;
      case "LineString":
        r.MultiLineString.coordinates.push(e.geometry.coordinates), r.MultiLineString.properties.push(e.properties);
        break;
      case "MultiLineString":
        r.MultiLineString.coordinates.push(
          ...e.geometry.coordinates
        ), r.MultiLineString.properties.push(e.properties);
        break;
      case "Polygon":
        r.MultiPolygon.coordinates.push(e.geometry.coordinates), r.MultiPolygon.properties.push(e.properties);
        break;
      case "MultiPolygon":
        r.MultiPolygon.coordinates.push(...e.geometry.coordinates), r.MultiPolygon.properties.push(e.properties);
        break;
    }
  }), Me(
    Object.keys(r).filter(function(e) {
      return r[e].coordinates.length;
    }).sort().map(function(e) {
      var n = { type: e, coordinates: r[e].coordinates }, i = { collectedProperties: r[e].properties };
      return dt(n, i);
    })
  );
}
var a2 = o2;
function l2(t, r, e, n, i) {
  Zc(t, r, e || 0, n || t.length - 1, i || u2);
}
function Zc(t, r, e, n, i) {
  for (; n > e; ) {
    if (n - e > 600) {
      var s = n - e + 1, o = r - e + 1, a = Math.log(s), u = 0.5 * Math.exp(2 * a / 3), l = 0.5 * Math.sqrt(a * u * (s - u) / s) * (o - s / 2 < 0 ? -1 : 1), c = Math.max(e, Math.floor(r - o * u / s + l)), h = Math.min(n, Math.floor(r + (s - o) * u / s + l));
      Zc(t, r, c, h, i);
    }
    var d = t[r], v = e, M = n;
    for ($r(t, e, r), i(t[n], d) > 0 && $r(t, e, n); v < M; ) {
      for ($r(t, v, M), v++, M--; i(t[v], d) < 0; ) v++;
      for (; i(t[M], d) > 0; ) M--;
    }
    i(t[e], d) === 0 ? $r(t, e, M) : (M++, $r(t, M, n)), M <= r && (e = M + 1), r <= M && (n = M - 1);
  }
}
function $r(t, r, e) {
  var n = t[r];
  t[r] = t[e], t[e] = n;
}
function u2(t, r) {
  return t < r ? -1 : t > r ? 1 : 0;
}
class Ye {
  constructor(r = 9) {
    this._maxEntries = Math.max(4, r), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(r) {
    let e = this.data;
    const n = [];
    if (!Vn(r, e)) return n;
    const i = this.toBBox, s = [];
    for (; e; ) {
      for (let o = 0; o < e.children.length; o++) {
        const a = e.children[o], u = e.leaf ? i(a) : a;
        Vn(r, u) && (e.leaf ? n.push(a) : vs(r, u) ? this._all(a, n) : s.push(a));
      }
      e = s.pop();
    }
    return n;
  }
  collides(r) {
    let e = this.data;
    if (!Vn(r, e)) return !1;
    const n = [];
    for (; e; ) {
      for (let i = 0; i < e.children.length; i++) {
        const s = e.children[i], o = e.leaf ? this.toBBox(s) : s;
        if (Vn(r, o)) {
          if (e.leaf || vs(r, o)) return !0;
          n.push(s);
        }
      }
      e = n.pop();
    }
    return !1;
  }
  load(r) {
    if (!(r && r.length)) return this;
    if (r.length < this._minEntries) {
      for (let n = 0; n < r.length; n++)
        this.insert(r[n]);
      return this;
    }
    let e = this._build(r.slice(), 0, r.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const n = this.data;
        this.data = e, e = n;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(r) {
    return r && this._insert(r, this.data.height - 1), this;
  }
  clear() {
    return this.data = wr([]), this;
  }
  remove(r, e) {
    if (!r) return this;
    let n = this.data;
    const i = this.toBBox(r), s = [], o = [];
    let a, u, l;
    for (; n || s.length; ) {
      if (n || (n = s.pop(), u = s[s.length - 1], a = o.pop(), l = !0), n.leaf) {
        const c = c2(r, n.children, e);
        if (c !== -1)
          return n.children.splice(c, 1), s.push(n), this._condense(s), this;
      }
      !l && !n.leaf && vs(n, i) ? (s.push(n), o.push(a), a = 0, u = n, n = n.children[0]) : u ? (a++, n = u.children[a], l = !1) : n = null;
    }
    return this;
  }
  toBBox(r) {
    return r;
  }
  compareMinX(r, e) {
    return r.minX - e.minX;
  }
  compareMinY(r, e) {
    return r.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(r) {
    return this.data = r, this;
  }
  _all(r, e) {
    const n = [];
    for (; r; )
      r.leaf ? e.push(...r.children) : n.push(...r.children), r = n.pop();
    return e;
  }
  _build(r, e, n, i) {
    const s = n - e + 1;
    let o = this._maxEntries, a;
    if (s <= o)
      return a = wr(r.slice(e, n + 1)), vr(a, this.toBBox), a;
    i || (i = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, i - 1))), a = wr([]), a.leaf = !1, a.height = i;
    const u = Math.ceil(s / o), l = u * Math.ceil(Math.sqrt(o));
    Al(r, e, n, l, this.compareMinX);
    for (let c = e; c <= n; c += l) {
      const h = Math.min(c + l - 1, n);
      Al(r, c, h, u, this.compareMinY);
      for (let d = c; d <= h; d += u) {
        const v = Math.min(d + u - 1, h);
        a.children.push(this._build(r, d, v, i - 1));
      }
    }
    return vr(a, this.toBBox), a;
  }
  _chooseSubtree(r, e, n, i) {
    for (; i.push(e), !(e.leaf || i.length - 1 === n); ) {
      let s = 1 / 0, o = 1 / 0, a;
      for (let u = 0; u < e.children.length; u++) {
        const l = e.children[u], c = ms(l), h = d2(r, l) - c;
        h < o ? (o = h, s = c < s ? c : s, a = l) : h === o && c < s && (s = c, a = l);
      }
      e = a || e.children[0];
    }
    return e;
  }
  _insert(r, e, n) {
    const i = n ? r : this.toBBox(r), s = [], o = this._chooseSubtree(i, this.data, e, s);
    for (o.children.push(r), Qr(o, i); e >= 0 && s[e].children.length > this._maxEntries; )
      this._split(s, e), e--;
    this._adjustParentBBoxes(i, s, e);
  }
  // split overflowed node into two
  _split(r, e) {
    const n = r[e], i = n.children.length, s = this._minEntries;
    this._chooseSplitAxis(n, s, i);
    const o = this._chooseSplitIndex(n, s, i), a = wr(n.children.splice(o, n.children.length - o));
    a.height = n.height, a.leaf = n.leaf, vr(n, this.toBBox), vr(a, this.toBBox), e ? r[e - 1].children.push(a) : this._splitRoot(n, a);
  }
  _splitRoot(r, e) {
    this.data = wr([r, e]), this.data.height = r.height + 1, this.data.leaf = !1, vr(this.data, this.toBBox);
  }
  _chooseSplitIndex(r, e, n) {
    let i, s = 1 / 0, o = 1 / 0;
    for (let a = e; a <= n - e; a++) {
      const u = Kr(r, 0, a, this.toBBox), l = Kr(r, a, n, this.toBBox), c = p2(u, l), h = ms(u) + ms(l);
      c < s ? (s = c, i = a, o = h < o ? h : o) : c === s && h < o && (o = h, i = a);
    }
    return i || n - e;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(r, e, n) {
    const i = r.leaf ? this.compareMinX : f2, s = r.leaf ? this.compareMinY : h2, o = this._allDistMargin(r, e, n, i), a = this._allDistMargin(r, e, n, s);
    o < a && r.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(r, e, n, i) {
    r.children.sort(i);
    const s = this.toBBox, o = Kr(r, 0, e, s), a = Kr(r, n - e, n, s);
    let u = qn(o) + qn(a);
    for (let l = e; l < n - e; l++) {
      const c = r.children[l];
      Qr(o, r.leaf ? s(c) : c), u += qn(o);
    }
    for (let l = n - e - 1; l >= e; l--) {
      const c = r.children[l];
      Qr(a, r.leaf ? s(c) : c), u += qn(a);
    }
    return u;
  }
  _adjustParentBBoxes(r, e, n) {
    for (let i = n; i >= 0; i--)
      Qr(e[i], r);
  }
  _condense(r) {
    for (let e = r.length - 1, n; e >= 0; e--)
      r[e].children.length === 0 ? e > 0 ? (n = r[e - 1].children, n.splice(n.indexOf(r[e]), 1)) : this.clear() : vr(r[e], this.toBBox);
  }
}
function c2(t, r, e) {
  if (!e) return r.indexOf(t);
  for (let n = 0; n < r.length; n++)
    if (e(t, r[n])) return n;
  return -1;
}
function vr(t, r) {
  Kr(t, 0, t.children.length, r, t);
}
function Kr(t, r, e, n, i) {
  i || (i = wr(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let s = r; s < e; s++) {
    const o = t.children[s];
    Qr(i, t.leaf ? n(o) : o);
  }
  return i;
}
function Qr(t, r) {
  return t.minX = Math.min(t.minX, r.minX), t.minY = Math.min(t.minY, r.minY), t.maxX = Math.max(t.maxX, r.maxX), t.maxY = Math.max(t.maxY, r.maxY), t;
}
function f2(t, r) {
  return t.minX - r.minX;
}
function h2(t, r) {
  return t.minY - r.minY;
}
function ms(t) {
  return (t.maxX - t.minX) * (t.maxY - t.minY);
}
function qn(t) {
  return t.maxX - t.minX + (t.maxY - t.minY);
}
function d2(t, r) {
  return (Math.max(r.maxX, t.maxX) - Math.min(r.minX, t.minX)) * (Math.max(r.maxY, t.maxY) - Math.min(r.minY, t.minY));
}
function p2(t, r) {
  const e = Math.max(t.minX, r.minX), n = Math.max(t.minY, r.minY), i = Math.min(t.maxX, r.maxX), s = Math.min(t.maxY, r.maxY);
  return Math.max(0, i - e) * Math.max(0, s - n);
}
function vs(t, r) {
  return t.minX <= r.minX && t.minY <= r.minY && r.maxX <= t.maxX && r.maxY <= t.maxY;
}
function Vn(t, r) {
  return r.minX <= t.maxX && r.minY <= t.maxY && r.maxX >= t.minX && r.maxY >= t.minY;
}
function wr(t) {
  return {
    children: t,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Al(t, r, e, n, i) {
  const s = [r, e];
  for (; s.length; ) {
    if (e = s.pop(), r = s.pop(), e - r <= n) continue;
    const o = r + Math.ceil((e - r) / n / 2) * n;
    l2(t, o, r, e, i), s.push(r, o, o, e);
  }
}
function g2(t) {
  return Xf(
    t,
    (r, e) => r + m2(e),
    0
  );
}
function m2(t) {
  let r = 0, e;
  switch (t.type) {
    case "Polygon":
      return Ll(t.coordinates);
    case "MultiPolygon":
      for (e = 0; e < t.coordinates.length; e++)
        r += Ll(t.coordinates[e]);
      return r;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function Ll(t) {
  let r = 0;
  if (t && t.length > 0) {
    r += Math.abs(Cl(t[0]));
    for (let e = 1; e < t.length; e++)
      r -= Math.abs(Cl(t[e]));
  }
  return r;
}
var v2 = we * we / 2, ys = Math.PI / 180;
function Cl(t) {
  const r = t.length - 1;
  if (r <= 2) return 0;
  let e = 0, n = 0;
  for (; n < r; ) {
    const i = t[n], s = t[n + 1 === r ? 0 : n + 1], o = t[n + 2 >= r ? (n + 2) % r : n + 2], a = i[0] * ys, u = s[1] * ys, l = o[0] * ys;
    e += (l - a) * Math.sin(u), n++;
  }
  return e * v2;
}
function y2(t, r, e) {
  if (t.geometry.type !== "Polygon")
    throw new Error("The input feature must be a Polygon");
  e === void 0 && (e = 1);
  var n = t.geometry.coordinates, i = [], s = {};
  if (e) {
    for (var o = [], a = 0; a < n.length; a++)
      for (var u = 0; u < n[a].length - 1; u++)
        o.push(P(a, u));
    var l = new Ye();
    l.load(o);
  }
  for (var c = 0; c < n.length; c++)
    for (var h = 0; h < n[c].length - 1; h++)
      if (e) {
        var d = l.search(P(c, h));
        d.forEach(function(C) {
          var g = C.ring, D = C.edge;
          A(c, h, g, D);
        });
      } else
        for (var v = 0; v < n.length; v++)
          for (var M = 0; M < n[v].length - 1; M++)
            A(c, h, v, M);
  return r || (i = {
    type: "Feature",
    geometry: { type: "MultiPoint", coordinates: i }
  }), i;
  function A(C, g, D, F) {
    var G = n[C][g], B = n[C][g + 1], H = n[D][F], f = n[D][F + 1], p = w2(G, B, H, f);
    if (p !== null) {
      var m, y;
      if (B[0] !== G[0] ? m = (p[0] - G[0]) / (B[0] - G[0]) : m = (p[1] - G[1]) / (B[1] - G[1]), f[0] !== H[0] ? y = (p[0] - H[0]) / (f[0] - H[0]) : y = (p[1] - H[1]) / (f[1] - H[1]), !(m >= 1 || m <= 0 || y >= 1 || y <= 0)) {
        var E = p, S = !s[E];
        S && (s[E] = !0), r ? i.push(
          r(
            p,
            C,
            g,
            G,
            B,
            m,
            D,
            F,
            H,
            f,
            y,
            S
          )
        ) : i.push(p);
      }
    }
  }
  function P(C, g) {
    var D = n[C][g], F = n[C][g + 1], G, B, H, f;
    return D[0] < F[0] ? (G = D[0], B = F[0]) : (G = F[0], B = D[0]), D[1] < F[1] ? (H = D[1], f = F[1]) : (H = F[1], f = D[1]), {
      minX: G,
      minY: H,
      maxX: B,
      maxY: f,
      ring: C,
      edge: g
    };
  }
}
function w2(t, r, e, n) {
  if (en(t, e) || en(t, n) || en(r, e) || en(n, e))
    return null;
  var i = t[0], s = t[1], o = r[0], a = r[1], u = e[0], l = e[1], c = n[0], h = n[1], d = (i - o) * (l - h) - (s - a) * (u - c);
  if (d === 0) return null;
  var v = ((i * a - s * o) * (u - c) - (i - o) * (u * h - l * c)) / d, M = ((i * a - s * o) * (l - h) - (s - a) * (u * h - l * c)) / d;
  return [v, M];
}
function en(t, r) {
  if (!t || !r || t.length !== r.length) return !1;
  for (var e = 0, n = t.length; e < n; e++)
    if (t[e] instanceof Array && r[e] instanceof Array) {
      if (!en(t[e], r[e])) return !1;
    } else if (t[e] !== r[e])
      return !1;
  return !0;
}
function E2(t) {
  if (t.type != "Feature")
    throw new Error("The input must a geojson object of type Feature");
  if (t.geometry === void 0 || t.geometry == null)
    throw new Error(
      "The input must a geojson object with a non-empty geometry"
    );
  if (t.geometry.type != "Polygon")
    throw new Error("The input must be a geojson Polygon");
  for (var r = t.geometry.coordinates.length, e = [], g = 0; g < r; g++) {
    var n = t.geometry.coordinates[g];
    tn(n[0], n[n.length - 1]) || n.push(n[0]);
    for (var i = 0; i < n.length - 1; i++)
      e.push(n[i]);
  }
  if (!b2(e))
    throw new Error(
      "The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"
    );
  var s = e.length, o = y2(
    t,
    function(Z, z, $, ee, mt, vt, Dt, _e, Fe, pe, ae, ne) {
      return [
        Z,
        z,
        $,
        ee,
        mt,
        vt,
        Dt,
        _e,
        Fe,
        pe,
        ae,
        ne
      ];
    }
  ), a = o.length;
  if (a == 0) {
    for (var H = [], g = 0; g < r; g++)
      H.push(
        er([t.geometry.coordinates[g]], {
          parent: -1,
          winding: M2(t.geometry.coordinates[g])
        })
      );
    var I = Me(H);
    return J(), U(), I;
  }
  for (var u = [], l = [], g = 0; g < r; g++) {
    u.push([]);
    for (var i = 0; i < t.geometry.coordinates[g].length - 1; i++)
      u[g].push([
        new kl(
          t.geometry.coordinates[g][Er(i + 1, t.geometry.coordinates[g].length - 1)],
          1,
          [g, i],
          [g, Er(i + 1, t.geometry.coordinates[g].length - 1)],
          void 0
        )
      ]), l.push(
        new Tl(
          t.geometry.coordinates[g][i],
          [g, Er(i - 1, t.geometry.coordinates[g].length - 1)],
          [g, i],
          void 0,
          void 0,
          !1,
          !0
        )
      );
  }
  for (var g = 0; g < a; g++)
    u[o[g][1]][o[g][2]].push(
      new kl(
        o[g][0],
        o[g][5],
        [o[g][1], o[g][2]],
        [o[g][6], o[g][7]],
        void 0
      )
    ), o[g][11] && l.push(
      new Tl(
        o[g][0],
        [o[g][1], o[g][2]],
        [o[g][6], o[g][7]],
        void 0,
        void 0,
        !0,
        !0
      )
    );
  for (var c = l.length, g = 0; g < u.length; g++)
    for (var i = 0; i < u[g].length; i++)
      u[g][i].sort(function(z, $) {
        return z.param < $.param ? -1 : 1;
      });
  for (var h = [], g = 0; g < c; g++)
    h.push({
      minX: l[g].coord[0],
      minY: l[g].coord[1],
      maxX: l[g].coord[0],
      maxY: l[g].coord[1],
      index: g
    });
  var d = new Ye();
  d.load(h);
  for (var g = 0; g < u.length; g++)
    for (var i = 0; i < u[g].length; i++)
      for (var v = 0; v < u[g][i].length; v++) {
        var M;
        v == u[g][i].length - 1 ? M = u[g][Er(i + 1, t.geometry.coordinates[g].length - 1)][0].coord : M = u[g][i][v + 1].coord;
        var A = d.search({
          minX: M[0],
          minY: M[1],
          maxX: M[0],
          maxY: M[1]
        })[0];
        u[g][i][v].nxtIsectAlongEdgeIn = A.index;
      }
  for (var g = 0; g < u.length; g++)
    for (var i = 0; i < u[g].length; i++)
      for (var v = 0; v < u[g][i].length; v++) {
        var M = u[g][i][v].coord, A = d.search({
          minX: M[0],
          minY: M[1],
          maxX: M[0],
          maxY: M[1]
        })[0], P = A.index;
        P < s ? l[P].nxtIsectAlongRingAndEdge2 = u[g][i][v].nxtIsectAlongEdgeIn : tn(
          l[P].ringAndEdge1,
          u[g][i][v].ringAndEdgeIn
        ) ? l[P].nxtIsectAlongRingAndEdge1 = u[g][i][v].nxtIsectAlongEdgeIn : l[P].nxtIsectAlongRingAndEdge2 = u[g][i][v].nxtIsectAlongEdgeIn;
      }
  for (var C = [], g = 0, i = 0; i < r; i++) {
    for (var D = g, v = 0; v < t.geometry.coordinates[i].length - 1; v++)
      l[g].coord[0] < l[D].coord[0] && (D = g), g++;
    for (var F = l[D].nxtIsectAlongRingAndEdge2, v = 0; v < l.length; v++)
      if (l[v].nxtIsectAlongRingAndEdge1 == D || l[v].nxtIsectAlongRingAndEdge2 == D) {
        var G = v;
        break;
      }
    var B = ri(
      [
        l[G].coord,
        l[D].coord,
        l[F].coord
      ],
      !0
    ) ? 1 : -1;
    C.push({ isect: D, parent: -1, winding: B });
  }
  C.sort(function(V, Z) {
    return l[V.isect].coord > l[Z.isect].coord ? -1 : 1;
  });
  for (var H = []; C.length > 0; ) {
    var f = C.pop(), p = f.isect, m = f.parent, y = f.winding, E = H.length, S = [l[p].coord], k = p;
    if (l[p].ringAndEdge1Walkable)
      var b = l[p].ringAndEdge1, x = l[p].nxtIsectAlongRingAndEdge1;
    else
      var b = l[p].ringAndEdge2, x = l[p].nxtIsectAlongRingAndEdge2;
    for (; !tn(l[p].coord, l[x].coord); ) {
      S.push(l[x].coord);
      for (var T = void 0, g = 0; g < C.length; g++)
        if (C[g].isect == x) {
          T = g;
          break;
        }
      if (T != null && C.splice(T, 1), tn(b, l[x].ringAndEdge1)) {
        if (b = l[x].ringAndEdge2, l[x].ringAndEdge2Walkable = !1, l[x].ringAndEdge1Walkable) {
          var L = { isect: x };
          ri(
            [
              l[k].coord,
              l[x].coord,
              l[l[x].nxtIsectAlongRingAndEdge2].coord
            ],
            y == 1
          ) ? (L.parent = m, L.winding = -y) : (L.parent = E, L.winding = y), C.push(L);
        }
        k = x, x = l[x].nxtIsectAlongRingAndEdge2;
      } else {
        if (b = l[x].ringAndEdge1, l[x].ringAndEdge1Walkable = !1, l[x].ringAndEdge2Walkable) {
          var L = { isect: x };
          ri(
            [
              l[k].coord,
              l[x].coord,
              l[l[x].nxtIsectAlongRingAndEdge1].coord
            ],
            y == 1
          ) ? (L.parent = m, L.winding = -y) : (L.parent = E, L.winding = y), C.push(L);
        }
        k = x, x = l[x].nxtIsectAlongRingAndEdge1;
      }
    }
    S.push(l[x].coord), H.push(
      er([S], {
        index: E,
        parent: m,
        winding: y,
        netWinding: void 0
      })
    );
  }
  var I = Me(H);
  J(), U();
  function J() {
    for (var V = [], Z = 0; Z < I.features.length; Z++)
      I.features[Z].properties.parent == -1 && V.push(Z);
    if (V.length > 1)
      for (var Z = 0; Z < V.length; Z++) {
        for (var z = -1, $ = 1 / 0, ee = 0; ee < I.features.length; ee++)
          V[Z] != ee && nr(
            I.features[V[Z]].geometry.coordinates[0][0],
            I.features[ee],
            { ignoreBoundary: !0 }
          ) && g2(I.features[ee]) < $ && (z = ee);
        I.features[V[Z]].properties.parent = z;
      }
  }
  function U() {
    for (var V = 0; V < I.features.length; V++)
      if (I.features[V].properties.parent == -1) {
        var Z = I.features[V].properties.winding;
        I.features[V].properties.netWinding = Z, X(V, Z);
      }
  }
  function X(V, Z) {
    for (var z = 0; z < I.features.length; z++)
      if (I.features[z].properties.parent == V) {
        var $ = Z + I.features[z].properties.winding;
        I.features[z].properties.netWinding = $, X(z, $);
      }
  }
  return I;
}
var kl = function(t, r, e, n, i) {
  this.coord = t, this.param = r, this.ringAndEdgeIn = e, this.ringAndEdgeOut = n, this.nxtIsectAlongEdgeIn = i;
}, Tl = function(t, r, e, n, i, s, o) {
  this.coord = t, this.ringAndEdge1 = r, this.ringAndEdge2 = e, this.nxtIsectAlongRingAndEdge1 = n, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = s, this.ringAndEdge2Walkable = o;
};
function ri(t, r) {
  if (typeof r > "u" && (r = !0), t.length != 3)
    throw new Error("This function requires an array of three points [x,y]");
  var e = (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]);
  return e >= 0 == r;
}
function M2(t) {
  for (var r = 0, e = 0; e < t.length - 1; e++)
    t[e][0] < t[r][0] && (r = e);
  if (ri(
    [
      t[Er(r - 1, t.length - 1)],
      t[r],
      t[Er(r + 1, t.length - 1)]
    ],
    !0
  ))
    var n = 1;
  else
    var n = -1;
  return n;
}
function tn(t, r) {
  if (!t || !r || t.length != r.length) return !1;
  for (var e = 0, n = t.length; e < n; e++)
    if (t[e] instanceof Array && r[e] instanceof Array) {
      if (!tn(t[e], r[e])) return !1;
    } else if (t[e] != r[e])
      return !1;
  return !0;
}
function Er(t, r) {
  return (t % r + r) % r;
}
function b2(t) {
  for (var r = {}, e = 1, n = 0, i = t.length; n < i; ++n) {
    if (Object.prototype.hasOwnProperty.call(r, t[n])) {
      e = 0;
      break;
    }
    r[t[n]] = 1;
  }
  return e;
}
function x2(t) {
  var r = [];
  return Ht(t, function(e) {
    e.geometry.type === "Polygon" && Ut(E2(e), function(n) {
      r.push(er(n.geometry.coordinates, e.properties));
    });
  }), Me(r);
}
var _2 = x2;
class S2 extends Pt {
  constructor() {
    super(...arguments);
    w(this, "mode", "polygon");
    w(this, "shape", "polygon");
    w(this, "lineDrawer", new qo(
      this.gm,
      { snappingMarkers: "first", targetShape: "polygon" }
    ));
    w(this, "mapEventHandlers", {
      [`${Y}:draw`]: this.forwardLineDrawerEvent.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on(
      "firstMarkerClick",
      this.polygonFinished.bind(this)
    );
  }
  onMouseMove(e) {
    return ve(e) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  polygonFinished(e) {
    if (this.lineDrawer.endShape(), e.shapeCoordinates.length < 3)
      return;
    const n = this.fixShapeGeoJson(Jo(e.geoJson));
    n && this.gm.features.createFeature({
      shapeGeoJson: {
        ...n,
        properties: {
          ...n.properties,
          shape: this.shape
        }
      },
      sourceName: O.main
    });
  }
  fixShapeGeoJson(e) {
    try {
      return tc(a2(_2(e))).features[0];
    } catch {
      return null;
    }
  }
}
class A2 extends Pt {
  constructor() {
    super(...arguments);
    w(this, "mode", "rectangle");
    w(this, "shape", "rectangle");
    w(this, "startLngLat", null);
    w(this, "mapEventHandlers", {
      mousemove: this.onMouseMove.bind(this),
      click: this.onMouseClick.bind(this)
    });
    w(this, "throttledMethods", Rr({
      updateFeaturePosition: this.updateFeaturePosition
    }, this, this.gm.options.settings.throttlingDelay));
  }
  onStartAction() {
    this.gm.markerPointer.enable();
  }
  onEndAction() {
    this.removeTmpFeature(), this.startLngLat = null, this.gm.markerPointer.disable(), this.fireFinishEvent();
  }
  onMouseClick(e) {
    var i;
    if (!ve(e, { warning: !0 }))
      return { next: !1 };
    const n = ((i = this.gm.markerPointer.marker) == null ? void 0 : i.getLngLat()) || e.lngLat.toArray();
    if (this.startLngLat) {
      const s = this.getFeatureGeoJson(
        yr(this.startLngLat, n)
      );
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [s] }), this.flags.featureCreateAllowed && this.finishShape(n);
    } else {
      const s = this.getFeatureGeoJson(
        yr(n, n)
      );
      if (this.fireBeforeFeatureCreate({ geoJsonFeatures: [s] }), this.flags.featureCreateAllowed) {
        const o = this.startShape(n);
        if (o) {
          const a = this.getControlMarkerData(["geometry", "coordinates", 4]);
          this.fireStartEvent(o, a);
        }
      }
    }
    return { next: !1 };
  }
  onMouseMove(e) {
    var o;
    if (!ve(e, { warning: !0 }))
      return { next: !1 };
    if (!this.startLngLat)
      return this.fireMarkerPointerUpdateEvent(), { next: !1 };
    const n = ((o = this.gm.markerPointer.marker) == null ? void 0 : o.getLngLat()) || e.lngLat.toArray(), i = yr(this.startLngLat, n), s = this.getFeatureGeoJson(i);
    return this.fireBeforeFeatureCreate({ geoJsonFeatures: [s] }), this.flags.featureCreateAllowed && this.throttledMethods.updateFeaturePosition(i), { next: !1 };
  }
  startShape(e) {
    this.startLngLat = e;
    const n = yr(this.startLngLat, this.startLngLat);
    return this.featureData = this.createFeature(n), this.featureData;
  }
  finishShape(e) {
    if (this.startLngLat) {
      const n = yr(this.startLngLat, e);
      this.throttledMethods.updateFeaturePosition(n);
    }
    this.featureData && (this.isFeatureGeoJsonValid() ? this.saveFeature() : this.removeTmpFeature()), this.startLngLat = null, this.fireFinishEvent();
  }
  createFeature(e) {
    return this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(e),
      sourceName: O.temporary
    });
  }
  isFeatureGeoJsonValid() {
    return this.featureData ? Ju(this.featureData.getGeoJson()) : !1;
  }
  getFeatureGeoJson(e) {
    return {
      ...Fs(
        [e[0], e[2]],
        [e[2], e[3]]
      ),
      properties: {
        shape: this.shape
      }
    };
  }
  updateFeaturePosition(e) {
    if (!this.featureData)
      return;
    const n = Fs(
      [e[0], e[1]],
      [e[2], e[3]]
    );
    this.featureData.updateGeoJsonGeometry(n.geometry);
    const i = this.getControlMarkerData(["geometry", "coordinates", 4]);
    this.fireUpdateEvent(this.featureData, i);
  }
  getControlMarkerData(e) {
    const n = this.gm.markerPointer.marker;
    return n ? {
      type: "dom",
      instance: n,
      position: {
        coordinate: n.getLngLat(),
        path: e
      }
    } : null;
  }
  fireStartEvent(e, n) {
    const i = {
      level: "system",
      type: "draw",
      mode: this.shape,
      variant: null,
      action: "start",
      featureData: e,
      markerData: n
    };
    this.gm.events.fire(`${Y}:draw`, i);
  }
  fireUpdateEvent(e, n) {
    const i = {
      level: "system",
      type: "draw",
      mode: this.shape,
      variant: null,
      action: "update",
      featureData: e,
      markerData: n
    };
    this.gm.events.fire(`${Y}:draw`, i);
  }
  fireFinishEvent() {
    const e = {
      level: "system",
      type: "draw",
      mode: this.shape,
      variant: null,
      action: "finish"
    };
    this.gm.events.fire(`${Y}:draw`, e);
  }
}
class L2 extends Pt {
  constructor() {
    super(...arguments);
    w(this, "mode", "text_marker");
    w(this, "shape", "text_marker");
    w(this, "textarea", null);
    w(this, "mapEventHandlers", {
      click: this.onMouseClick.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: !0 });
  }
  onEndAction() {
    this.removeTextarea(), this.removeTmpFeature(), this.featureData = null, this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent();
  }
  onMouseMove(e) {
    return ve(e, { warning: !0 }) ? (this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  onMouseClick(e) {
    var n;
    if (!ve(e, { warning: !0 }))
      return { next: !0 };
    if (this.textarea)
      this.endShape(), this.gm.markerPointer.enable({ invisibleMarker: !0, lngLat: e.lngLat.toArray() }), this.fireMarkerPointerUpdateEvent();
    else {
      const i = ((n = this.gm.markerPointer.marker) == null ? void 0 : n.getLngLat()) || e.lngLat.toArray();
      this.fireBeforeFeatureCreate({ geoJsonFeatures: [this.getFeatureGeoJson(i)] }), this.flags.featureCreateAllowed && (this.featureData = this.createFeature(i), this.gm.markerPointer.disable(), this.fireMarkerPointerFinishEvent());
    }
    return { next: !1 };
  }
  createFeature(e) {
    const n = this.gm.mapAdapter.project(e);
    return this.createTextarea(n), this.gm.features.createFeature({
      shapeGeoJson: this.getFeatureGeoJson(e),
      sourceName: O.temporary
    });
  }
  endShape() {
    var n;
    const e = ((n = this.textarea) == null ? void 0 : n.value) || "";
    this.removeTextarea(), e.trim() ? (this.updateFeatureSource(e), this.saveFeature()) : this.removeTmpFeature();
  }
  createTextarea(e) {
    this.textarea = document.createElement("textarea"), this.textarea.style.position = "absolute", this.textarea.style.left = `${e[0]}px`, this.textarea.style.top = `${e[1]}px`, this.textarea.style.opacity = "0.7", this.gm.mapAdapter.getContainer().appendChild(this.textarea), this.textarea.focus();
  }
  removeTextarea() {
    var e;
    (e = this.textarea) == null || e.remove(), this.textarea = null;
  }
  getFeatureGeoJson(e) {
    return {
      type: "Feature",
      properties: {
        shape: this.shape,
        text: ""
      },
      geometry: {
        type: "Point",
        coordinates: e
      }
    };
  }
  updateFeatureSource(e) {
    this.featureData && this.featureData.updateGeoJsonProperties({ shape: this.shape, text: e });
  }
}
const js = {
  marker: s2,
  circle: Ry,
  circle_marker: Dy,
  text_marker: L2,
  line: i2,
  rectangle: A2,
  polygon: S2,
  freehand: null,
  custom_shape: null
}, C2 = (t, r) => js[r] ? new js[r](t) : (N.error(`Draw "${r}" is not available`), null);
class k2 extends Fi {
  constructor(e, n) {
    super(e);
    w(this, "mapEventHandlers", {
      [`${Y}:draw`]: this.handleDrawEvent.bind(this)
    });
    n.attachEvents(this.mapEventHandlers);
  }
  handleDrawEvent(e) {
    if (!So(e))
      return { next: !0 };
    const n = `${e.type}__${e.mode}`;
    return e.action === "mode_start" ? (this.trackExclusiveModes(e), this.start(n, e), this.trackRelatedModes(e)) : e.action === "mode_end" && (this.trackRelatedModes(e), this.end(n)), { next: !0 };
  }
  start(e, n) {
    const i = C2(this.gm, n.mode);
    i && (e in this.gm.actionInstances && N.error(`Action instance "${e}" already exists`), this.gm.actionInstances[e] = i, i.startAction());
  }
  end(e) {
    const n = this.gm.actionInstances[e];
    n instanceof Pt ? (n.endAction(), delete this.gm.actionInstances[e]) : console.error(
      `Wrong action instance for draw event "${e}":`,
      n
    );
  }
}
class Vo extends kn {
  constructor() {
    super(...arguments);
    w(this, "mode", "drag");
    w(this, "isDragging", !1);
    w(this, "previousLngLat", null);
    w(this, "pointBasedShapes", [
      "marker",
      "circle_marker",
      "text_marker"
    ]);
    w(this, "throttledMethods", Rr({
      onMouseMove: this.onMouseMove
    }, this, this.gm.options.settings.throttlingDelay));
    w(this, "mapEventHandlers", {
      [`${Y}:edit`]: this.handleGmEdit.bind(this),
      mousedown: this.onMouseDown.bind(this),
      touchstart: this.onMouseDown.bind(this),
      mousemove: this.throttledMethods.onMouseMove.bind(this),
      touchmove: this.throttledMethods.onMouseMove.bind(this),
      mouseup: this.onMouseUp.bind(this),
      touchend: this.onMouseUp.bind(this)
    });
    w(this, "getUpdatedGeoJsonHandlers", {
      marker: this.moveSource.bind(this),
      circle: this.moveCircle.bind(this),
      circle_marker: this.moveSource.bind(this),
      text_marker: this.moveSource.bind(this),
      line: this.moveSource.bind(this),
      rectangle: this.moveSource.bind(this),
      polygon: this.moveSource.bind(this)
    });
  }
  onMouseDown(e) {
    var n;
    return this.featureData = this.gm.features.getFeatureByMouseEvent({
      event: e,
      sourceNames: [O.main]
    }), this.featureData && this.getUpdatedGeoJsonHandlers[this.featureData.shape] ? (this.featureData.changeSource({ sourceName: O.temporary, atomic: !0 }), this.gm.mapAdapter.setDragPan(!1), this.isDragging = !0, (n = this.snappingHelper) == null || n.addExcludedFeature(this.featureData), this.isPointBasedShape() && this.alignShapeCenterWithControlMarker(this.featureData, e), this.fireFeatureEditStartEvent({ feature: this.featureData, forceMode: "drag" }), { next: !1 }) : { next: !0 };
  }
  onMouseUp() {
    var e;
    return this.featureData ? ((e = this.snappingHelper) == null || e.clearExcludedFeatures(), this.featureData.changeSource({ sourceName: O.main, atomic: !0 }), this.isDragging = !1, this.previousLngLat = null, this.gm.mapAdapter.setDragPan(!0), this.fireFeatureEditEndEvent({ feature: this.featureData, forceMode: "drag" }), this.featureData = null, { next: !0 }) : { next: !0 };
  }
  onMouseMove(e) {
    var n;
    if (!this.isDragging || !ve(e, { warning: !0 }))
      return { next: !0 };
    if (this.featureData) {
      const i = ((n = this.gm.markerPointer.marker) == null ? void 0 : n.getLngLat()) || e.lngLat.toArray();
      this.moveFeature(this.featureData, i);
    }
    return { next: !1 };
  }
  isPointBasedShape() {
    return !!this.featureData && this.pointBasedShapes.includes(this.featureData.shape);
  }
  alignShapeCenterWithControlMarker(e, n) {
    var s;
    const i = Lo(e);
    i && ((s = this.gm.markerPointer.marker) == null || s.setLngLat(i), this.onMouseMove(n));
  }
  moveFeature(e, n) {
    if (!this.isDragging)
      return;
    if (!this.previousLngLat) {
      this.previousLngLat = n;
      return;
    }
    const i = this.getUpdatedGeoJsonHandlers[e.shape];
    if (i) {
      const s = i(e, this.previousLngLat, n);
      if (!s) {
        N.error("BaseDrag.moveFeature: invalid updatedGeoJson", e);
        return;
      }
      this.fireBeforeFeatureUpdate({
        features: [e],
        geoJsonFeatures: [s],
        forceMode: "drag"
      }), this.updateFeatureGeoJson({
        featureData: e,
        featureGeoJson: s,
        forceMode: "drag"
      }) && (this.previousLngLat = n);
    }
  }
  moveSource(e, n, i) {
    const s = qa(n, i);
    return d1(e, s);
  }
  moveCircle(e, n, i) {
    if (e.shape !== "circle")
      return N.error("BaseDrag.moveCircle: invalid shape type", e), null;
    const s = e.getShapeProperty("center");
    if (!s)
      return N.error("BaseDrag.moveCircle: missing center in the featureData", e), null;
    const o = e.getGeoJson(), a = qa(n, i), u = qu(o);
    if (!u)
      return N.error("BaseDrag.moveCircle: missing center circleRimLngLat"), null;
    const l = [
      s[0] + a.lng,
      s[1] + a.lat
    ], c = bo({
      center: l,
      radius: this.gm.mapAdapter.getDistance(s, u)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle",
        center: l
      },
      geometry: c.geometry
    };
  }
}
class T2 extends Vo {
  constructor() {
    super(...arguments);
    w(this, "mode", "change");
    w(this, "cutVertexShapeTypes", ["line", "polygon", "rectangle"]);
    w(this, "markerData", null);
    w(this, "shapeUpdateHandlers", {
      marker: this.updateSingleVertex.bind(this),
      circle: this.updateCircle.bind(this),
      circle_marker: this.updateSingleVertex.bind(this),
      text_marker: this.updateSingleVertex.bind(this),
      line: this.updateSingleVertex.bind(this),
      rectangle: this.updateRectangle.bind(this),
      polygon: this.updateSingleVertex.bind(this)
    });
  }
  get snapGuidesInstance() {
    const e = this.gm.actionInstances.helper__snap_guides;
    return e instanceof $c ? e : null;
  }
  onStartAction() {
  }
  onEndAction() {
    var e;
    (e = this.snapGuidesInstance) == null || e.removeSnapGuides();
  }
  handleGmEdit(e) {
    var n;
    if (!Br(e))
      return { next: !0 };
    if (e.action === "marker_move" && e.lngLatStart && e.markerData) {
      if (e.markerData.type === "vertex")
        return this.moveVertex(e), { next: !1 };
      if (e.lngLatEnd)
        return this.moveSource(
          e.featureData,
          e.lngLatStart,
          e.lngLatEnd
        ), { next: !1 };
    }
    return e.action === "marker_right_click" ? (this.cutVertex(e), this.fireFeatureEditEndEvent({ feature: e.featureData })) : e.action === "edge_marker_click" ? this.insertVertex(e) : e.action === "marker_captured" ? (e.featureData.changeSource({ sourceName: O.temporary, atomic: !0 }), this.fireFeatureEditStartEvent({ feature: e.featureData })) : e.action === "marker_released" && (this.markerData = null, (n = this.snapGuidesInstance) == null || n.removeSnapGuides(), e.featureData.changeSource({ sourceName: O.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: e.featureData })), { next: !0 };
  }
  moveVertex(e) {
    var o, a, u;
    this.markerData || (this.markerData = e.markerData || null, (o = this.snapGuidesInstance) == null || o.updateSnapGuides(
      e.featureData.getGeoJson(),
      e.lngLatStart
    ));
    const n = e.featureData, i = n.shape, s = ((u = (a = this.shapeUpdateHandlers)[i]) == null ? void 0 : u.call(a, e)) || null;
    s ? (this.fireBeforeFeatureUpdate({
      features: [n],
      geoJsonFeatures: [s]
    }), this.updateFeatureGeoJson({ featureData: n, featureGeoJson: s })) : N.error("EditChange.moveVertex: invalid geojson", s, e);
  }
  cutVertex(e) {
    const n = e.featureData;
    if (e.markerData.type !== "vertex" || !this.cutVertexShapeTypes.includes(n.shape))
      return;
    let i = !1;
    const s = n.getGeoJson(), o = e.markerData.instance;
    if (Gu(s)) {
      if (rs(s) <= 2) {
        this.gm.features.delete(n);
        return;
      }
    } else if (Bu(s)) {
      if (rs(s) <= 3) {
        this.gm.features.delete(n);
        return;
      }
    } else if (Ru(s) && rs(s) <= 3) {
      this.gm.features.delete(n);
      return;
    }
    const a = Lo(o);
    a && (i = Dm(s, a)), i ? (n.convertToPolygon(), n.updateGeoJsonGeometry(s.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [n],
      targetFeatures: [n],
      markerData: e.markerData
    })) : N.error("EditChange.cutVertex: feature not updated", e);
  }
  insertVertex(e) {
    if (e.markerData.type !== "edge")
      return;
    const n = e.featureData.getGeoJson(), i = e.markerData.segment.end.path, s = i.pop(), o = rr(n, i);
    typeof s == "number" && (o.splice(s, 0, [...e.markerData.position.coordinate]), e.featureData.updateGeoJsonGeometry(n.geometry), e.featureData.convertToPolygon(), this.fireFeatureUpdatedEvent({
      sourceFeatures: [e.featureData],
      targetFeatures: [e.featureData],
      markerData: e.markerData
    }));
  }
  updateSingleVertex({ featureData: e, lngLatEnd: n, markerData: i }) {
    const s = je(e.getGeoJson()), o = je(i.position.path), a = o.pop(), u = rr(s, o);
    return Array.isArray(u) && typeof a == "number" ? (u[a] = [...n], a === 0 && e.shape === "polygon" && (u[u.length - 1] = [...n])) : N.error("BaseDrag.moveSingleVertex: invalid coordinates", s, o), s;
  }
  updateCircle({ featureData: e, lngLatEnd: n }) {
    if (e.shape !== "circle" || e.shapeProperties.center === null)
      return N.error("BaseDrag.moveCircle: invalid shape type / missing center", e), null;
    const i = e.shapeProperties.center, s = bo({
      center: i,
      radius: this.gm.mapAdapter.getDistance(i, n)
    });
    return {
      type: "Feature",
      properties: {
        shape: "circle",
        center: i
      },
      geometry: s.geometry
    };
  }
  updateRectangle({ featureData: e, lngLatStart: n, lngLatEnd: i }) {
    const o = e.getGeoJson(), a = o.geometry.coordinates[0], { absCoordIndex: u } = Ii(o, n);
    if (u === -1)
      return N.error("EditChange.updateRectangle: start vertex not found", e), null;
    const l = $s(u - 2, 4), c = a[l];
    return Fs(
      i,
      c
    );
  }
}
const P2 = (t) => t.length > 0;
function I2(t, r, {
  ignoreSelfIntersections: e = !0
} = {}) {
  let n = !1;
  return Ht(t, (i) => {
    Ht(r, (s) => {
      if (n === !0)
        return !0;
      n = !By(i.geometry, s.geometry, {
        ignoreSelfIntersections: e
      });
    });
  }), n;
}
var F2 = I2, D2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, ws = Math.ceil, qe = Math.floor, Ge = "[BigNumber Error] ", Pl = Ge + "Number primitive has more than 15 significant digits: ", Xe = 1e14, j = 14, Il = 9007199254740991, Es = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], Ot = 1e7, Be = 1e9;
function Xc(t) {
  var r, e, n, i = g.prototype = { constructor: g, toString: null, valueOf: null }, s = new g(1), o = 20, a = 4, u = -7, l = 21, c = -1e7, h = 1e7, d = !1, v = 1, M = 0, A = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, P = "0123456789abcdefghijklmnopqrstuvwxyz", C = !0;
  function g(f, p) {
    var m, y, E, S, k, b, x, T, L = this;
    if (!(L instanceof g)) return new g(f, p);
    if (p == null) {
      if (f && f._isBigNumber === !0) {
        L.s = f.s, !f.c || f.e > h ? L.c = L.e = null : f.e < c ? L.c = [L.e = 0] : (L.e = f.e, L.c = f.c.slice());
        return;
      }
      if ((b = typeof f == "number") && f * 0 == 0) {
        if (L.s = 1 / f < 0 ? (f = -f, -1) : 1, f === ~~f) {
          for (S = 0, k = f; k >= 10; k /= 10, S++) ;
          S > h ? L.c = L.e = null : (L.e = S, L.c = [f]);
          return;
        }
        T = String(f);
      } else {
        if (!D2.test(T = String(f))) return n(L, T, b);
        L.s = T.charCodeAt(0) == 45 ? (T = T.slice(1), -1) : 1;
      }
      (S = T.indexOf(".")) > -1 && (T = T.replace(".", "")), (k = T.search(/e/i)) > 0 ? (S < 0 && (S = k), S += +T.slice(k + 1), T = T.substring(0, k)) : S < 0 && (S = T.length);
    } else {
      if (fe(p, 2, P.length, "Base"), p == 10 && C)
        return L = new g(f), B(L, o + L.e + 1, a);
      if (T = String(f), b = typeof f == "number") {
        if (f * 0 != 0) return n(L, T, b, p);
        if (L.s = 1 / f < 0 ? (T = T.slice(1), -1) : 1, g.DEBUG && T.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Pl + f);
      } else
        L.s = T.charCodeAt(0) === 45 ? (T = T.slice(1), -1) : 1;
      for (m = P.slice(0, p), S = k = 0, x = T.length; k < x; k++)
        if (m.indexOf(y = T.charAt(k)) < 0) {
          if (y == ".") {
            if (k > S) {
              S = x;
              continue;
            }
          } else if (!E && (T == T.toUpperCase() && (T = T.toLowerCase()) || T == T.toLowerCase() && (T = T.toUpperCase()))) {
            E = !0, k = -1, S = 0;
            continue;
          }
          return n(L, String(f), b, p);
        }
      b = !1, T = e(T, p, 10, L.s), (S = T.indexOf(".")) > -1 ? T = T.replace(".", "") : S = T.length;
    }
    for (k = 0; T.charCodeAt(k) === 48; k++) ;
    for (x = T.length; T.charCodeAt(--x) === 48; ) ;
    if (T = T.slice(k, ++x)) {
      if (x -= k, b && g.DEBUG && x > 15 && (f > Il || f !== qe(f)))
        throw Error(Pl + L.s * f);
      if ((S = S - k - 1) > h)
        L.c = L.e = null;
      else if (S < c)
        L.c = [L.e = 0];
      else {
        if (L.e = S, L.c = [], k = (S + 1) % j, S < 0 && (k += j), k < x) {
          for (k && L.c.push(+T.slice(0, k)), x -= j; k < x; )
            L.c.push(+T.slice(k, k += j));
          k = j - (T = T.slice(k)).length;
        } else
          k -= x;
        for (; k--; T += "0") ;
        L.c.push(+T);
      }
    } else
      L.c = [L.e = 0];
  }
  g.clone = Xc, g.ROUND_UP = 0, g.ROUND_DOWN = 1, g.ROUND_CEIL = 2, g.ROUND_FLOOR = 3, g.ROUND_HALF_UP = 4, g.ROUND_HALF_DOWN = 5, g.ROUND_HALF_EVEN = 6, g.ROUND_HALF_CEIL = 7, g.ROUND_HALF_FLOOR = 8, g.EUCLID = 9, g.config = g.set = function(f) {
    var p, m;
    if (f != null)
      if (typeof f == "object") {
        if (f.hasOwnProperty(p = "DECIMAL_PLACES") && (m = f[p], fe(m, 0, Be, p), o = m), f.hasOwnProperty(p = "ROUNDING_MODE") && (m = f[p], fe(m, 0, 8, p), a = m), f.hasOwnProperty(p = "EXPONENTIAL_AT") && (m = f[p], m && m.pop ? (fe(m[0], -1e9, 0, p), fe(m[1], 0, Be, p), u = m[0], l = m[1]) : (fe(m, -1e9, Be, p), u = -(l = m < 0 ? -m : m))), f.hasOwnProperty(p = "RANGE"))
          if (m = f[p], m && m.pop)
            fe(m[0], -1e9, -1, p), fe(m[1], 1, Be, p), c = m[0], h = m[1];
          else if (fe(m, -1e9, Be, p), m)
            c = -(h = m < 0 ? -m : m);
          else
            throw Error(Ge + p + " cannot be zero: " + m);
        if (f.hasOwnProperty(p = "CRYPTO"))
          if (m = f[p], m === !!m)
            if (m)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                d = m;
              else
                throw d = !m, Error(Ge + "crypto unavailable");
            else
              d = m;
          else
            throw Error(Ge + p + " not true or false: " + m);
        if (f.hasOwnProperty(p = "MODULO_MODE") && (m = f[p], fe(m, 0, 9, p), v = m), f.hasOwnProperty(p = "POW_PRECISION") && (m = f[p], fe(m, 0, Be, p), M = m), f.hasOwnProperty(p = "FORMAT"))
          if (m = f[p], typeof m == "object") A = m;
          else throw Error(Ge + p + " not an object: " + m);
        if (f.hasOwnProperty(p = "ALPHABET"))
          if (m = f[p], typeof m == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(m))
            C = m.slice(0, 10) == "0123456789", P = m;
          else
            throw Error(Ge + p + " invalid: " + m);
      } else
        throw Error(Ge + "Object expected: " + f);
    return {
      DECIMAL_PLACES: o,
      ROUNDING_MODE: a,
      EXPONENTIAL_AT: [u, l],
      RANGE: [c, h],
      CRYPTO: d,
      MODULO_MODE: v,
      POW_PRECISION: M,
      FORMAT: A,
      ALPHABET: P
    };
  }, g.isBigNumber = function(f) {
    if (!f || f._isBigNumber !== !0) return !1;
    if (!g.DEBUG) return !0;
    var p, m, y = f.c, E = f.e, S = f.s;
    e: if ({}.toString.call(y) == "[object Array]") {
      if ((S === 1 || S === -1) && E >= -1e9 && E <= Be && E === qe(E)) {
        if (y[0] === 0) {
          if (E === 0 && y.length === 1) return !0;
          break e;
        }
        if (p = (E + 1) % j, p < 1 && (p += j), String(y[0]).length == p) {
          for (p = 0; p < y.length; p++)
            if (m = y[p], m < 0 || m >= Xe || m !== qe(m)) break e;
          if (m !== 0) return !0;
        }
      }
    } else if (y === null && E === null && (S === null || S === 1 || S === -1))
      return !0;
    throw Error(Ge + "Invalid BigNumber: " + f);
  }, g.maximum = g.max = function() {
    return F(arguments, -1);
  }, g.minimum = g.min = function() {
    return F(arguments, 1);
  }, g.random = function() {
    var f = 9007199254740992, p = Math.random() * f & 2097151 ? function() {
      return qe(Math.random() * f);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(m) {
      var y, E, S, k, b, x = 0, T = [], L = new g(s);
      if (m == null ? m = o : fe(m, 0, Be), k = ws(m / j), d)
        if (crypto.getRandomValues) {
          for (y = crypto.getRandomValues(new Uint32Array(k *= 2)); x < k; )
            b = y[x] * 131072 + (y[x + 1] >>> 11), b >= 9e15 ? (E = crypto.getRandomValues(new Uint32Array(2)), y[x] = E[0], y[x + 1] = E[1]) : (T.push(b % 1e14), x += 2);
          x = k / 2;
        } else if (crypto.randomBytes) {
          for (y = crypto.randomBytes(k *= 7); x < k; )
            b = (y[x] & 31) * 281474976710656 + y[x + 1] * 1099511627776 + y[x + 2] * 4294967296 + y[x + 3] * 16777216 + (y[x + 4] << 16) + (y[x + 5] << 8) + y[x + 6], b >= 9e15 ? crypto.randomBytes(7).copy(y, x) : (T.push(b % 1e14), x += 7);
          x = k / 7;
        } else
          throw d = !1, Error(Ge + "crypto unavailable");
      if (!d)
        for (; x < k; )
          b = p(), b < 9e15 && (T[x++] = b % 1e14);
      for (k = T[--x], m %= j, k && m && (b = Es[j - m], T[x] = qe(k / b) * b); T[x] === 0; T.pop(), x--) ;
      if (x < 0)
        T = [S = 0];
      else {
        for (S = -1; T[0] === 0; T.splice(0, 1), S -= j) ;
        for (x = 1, b = T[0]; b >= 10; b /= 10, x++) ;
        x < j && (S -= j - x);
      }
      return L.e = S, L.c = T, L;
    };
  }(), g.sum = function() {
    for (var f = 1, p = arguments, m = new g(p[0]); f < p.length; ) m = m.plus(p[f++]);
    return m;
  }, e = /* @__PURE__ */ function() {
    var f = "0123456789";
    function p(m, y, E, S) {
      for (var k, b = [0], x, T = 0, L = m.length; T < L; ) {
        for (x = b.length; x--; b[x] *= y) ;
        for (b[0] += S.indexOf(m.charAt(T++)), k = 0; k < b.length; k++)
          b[k] > E - 1 && (b[k + 1] == null && (b[k + 1] = 0), b[k + 1] += b[k] / E | 0, b[k] %= E);
      }
      return b.reverse();
    }
    return function(m, y, E, S, k) {
      var b, x, T, L, I, J, U, X, V = m.indexOf("."), Z = o, z = a;
      for (V >= 0 && (L = M, M = 0, m = m.replace(".", ""), X = new g(y), J = X.pow(m.length - V), M = L, X.c = p(
        Mt(Je(J.c), J.e, "0"),
        10,
        E,
        f
      ), X.e = X.c.length), U = p(m, y, E, k ? (b = P, f) : (b = f, P)), T = L = U.length; U[--L] == 0; U.pop()) ;
      if (!U[0]) return b.charAt(0);
      if (V < 0 ? --T : (J.c = U, J.e = T, J.s = S, J = r(J, X, Z, z, E), U = J.c, I = J.r, T = J.e), x = T + Z + 1, V = U[x], L = E / 2, I = I || x < 0 || U[x + 1] != null, I = z < 4 ? (V != null || I) && (z == 0 || z == (J.s < 0 ? 3 : 2)) : V > L || V == L && (z == 4 || I || z == 6 && U[x - 1] & 1 || z == (J.s < 0 ? 8 : 7)), x < 1 || !U[0])
        m = I ? Mt(b.charAt(1), -Z, b.charAt(0)) : b.charAt(0);
      else {
        if (U.length = x, I)
          for (--E; ++U[--x] > E; )
            U[x] = 0, x || (++T, U = [1].concat(U));
        for (L = U.length; !U[--L]; ) ;
        for (V = 0, m = ""; V <= L; m += b.charAt(U[V++])) ;
        m = Mt(m, T, b.charAt(0));
      }
      return m;
    };
  }(), r = /* @__PURE__ */ function() {
    function f(y, E, S) {
      var k, b, x, T, L = 0, I = y.length, J = E % Ot, U = E / Ot | 0;
      for (y = y.slice(); I--; )
        x = y[I] % Ot, T = y[I] / Ot | 0, k = U * x + T * J, b = J * x + k % Ot * Ot + L, L = (b / S | 0) + (k / Ot | 0) + U * T, y[I] = b % S;
      return L && (y = [L].concat(y)), y;
    }
    function p(y, E, S, k) {
      var b, x;
      if (S != k)
        x = S > k ? 1 : -1;
      else
        for (b = x = 0; b < S; b++)
          if (y[b] != E[b]) {
            x = y[b] > E[b] ? 1 : -1;
            break;
          }
      return x;
    }
    function m(y, E, S, k) {
      for (var b = 0; S--; )
        y[S] -= b, b = y[S] < E[S] ? 1 : 0, y[S] = b * k + y[S] - E[S];
      for (; !y[0] && y.length > 1; y.splice(0, 1)) ;
    }
    return function(y, E, S, k, b) {
      var x, T, L, I, J, U, X, V, Z, z, $, ee, mt, vt, Dt, _e, Fe, pe = y.s == E.s ? 1 : -1, ae = y.c, ne = E.c;
      if (!ae || !ae[0] || !ne || !ne[0])
        return new g(
          // Return NaN if either NaN, or both Infinity or 0.
          !y.s || !E.s || (ae ? ne && ae[0] == ne[0] : !ne) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            ae && ae[0] == 0 || !ne ? pe * 0 : pe / 0
          )
        );
      for (V = new g(pe), Z = V.c = [], T = y.e - E.e, pe = S + T + 1, b || (b = Xe, T = Ve(y.e / j) - Ve(E.e / j), pe = pe / j | 0), L = 0; ne[L] == (ae[L] || 0); L++) ;
      if (ne[L] > (ae[L] || 0) && T--, pe < 0)
        Z.push(1), I = !0;
      else {
        for (vt = ae.length, _e = ne.length, L = 0, pe += 2, J = qe(b / (ne[0] + 1)), J > 1 && (ne = f(ne, J, b), ae = f(ae, J, b), _e = ne.length, vt = ae.length), mt = _e, z = ae.slice(0, _e), $ = z.length; $ < _e; z[$++] = 0) ;
        Fe = ne.slice(), Fe = [0].concat(Fe), Dt = ne[0], ne[1] >= b / 2 && Dt++;
        do {
          if (J = 0, x = p(ne, z, _e, $), x < 0) {
            if (ee = z[0], _e != $ && (ee = ee * b + (z[1] || 0)), J = qe(ee / Dt), J > 1)
              for (J >= b && (J = b - 1), U = f(ne, J, b), X = U.length, $ = z.length; p(U, z, X, $) == 1; )
                J--, m(U, _e < X ? Fe : ne, X, b), X = U.length, x = 1;
            else
              J == 0 && (x = J = 1), U = ne.slice(), X = U.length;
            if (X < $ && (U = [0].concat(U)), m(z, U, $, b), $ = z.length, x == -1)
              for (; p(ne, z, _e, $) < 1; )
                J++, m(z, _e < $ ? Fe : ne, $, b), $ = z.length;
          } else x === 0 && (J++, z = [0]);
          Z[L++] = J, z[0] ? z[$++] = ae[mt] || 0 : (z = [ae[mt]], $ = 1);
        } while ((mt++ < vt || z[0] != null) && pe--);
        I = z[0] != null, Z[0] || Z.splice(0, 1);
      }
      if (b == Xe) {
        for (L = 1, pe = Z[0]; pe >= 10; pe /= 10, L++) ;
        B(V, S + (V.e = L + T * j - 1) + 1, k, I);
      } else
        V.e = T, V.r = +I;
      return V;
    };
  }();
  function D(f, p, m, y) {
    var E, S, k, b, x;
    if (m == null ? m = a : fe(m, 0, 8), !f.c) return f.toString();
    if (E = f.c[0], k = f.e, p == null)
      x = Je(f.c), x = y == 1 || y == 2 && (k <= u || k >= l) ? Wn(x, k) : Mt(x, k, "0");
    else if (f = B(new g(f), p, m), S = f.e, x = Je(f.c), b = x.length, y == 1 || y == 2 && (p <= S || S <= u)) {
      for (; b < p; x += "0", b++) ;
      x = Wn(x, S);
    } else if (p -= k, x = Mt(x, S, "0"), S + 1 > b) {
      if (--p > 0) for (x += "."; p--; x += "0") ;
    } else if (p += S - b, p > 0)
      for (S + 1 == b && (x += "."); p--; x += "0") ;
    return f.s < 0 && E ? "-" + x : x;
  }
  function F(f, p) {
    for (var m, y, E = 1, S = new g(f[0]); E < f.length; E++)
      y = new g(f[E]), (!y.s || (m = Wt(S, y)) === p || m === 0 && S.s === p) && (S = y);
    return S;
  }
  function G(f, p, m) {
    for (var y = 1, E = p.length; !p[--E]; p.pop()) ;
    for (E = p[0]; E >= 10; E /= 10, y++) ;
    return (m = y + m * j - 1) > h ? f.c = f.e = null : m < c ? f.c = [f.e = 0] : (f.e = m, f.c = p), f;
  }
  n = /* @__PURE__ */ function() {
    var f = /^(-?)0([xbo])(?=\w[\w.]*$)/i, p = /^([^.]+)\.$/, m = /^\.([^.]+)$/, y = /^-?(Infinity|NaN)$/, E = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(S, k, b, x) {
      var T, L = b ? k : k.replace(E, "");
      if (y.test(L))
        S.s = isNaN(L) ? null : L < 0 ? -1 : 1;
      else {
        if (!b && (L = L.replace(f, function(I, J, U) {
          return T = (U = U.toLowerCase()) == "x" ? 16 : U == "b" ? 2 : 8, !x || x == T ? J : I;
        }), x && (T = x, L = L.replace(p, "$1").replace(m, "0.$1")), k != L))
          return new g(L, T);
        if (g.DEBUG)
          throw Error(Ge + "Not a" + (x ? " base " + x : "") + " number: " + k);
        S.s = null;
      }
      S.c = S.e = null;
    };
  }();
  function B(f, p, m, y) {
    var E, S, k, b, x, T, L, I = f.c, J = Es;
    if (I) {
      e: {
        for (E = 1, b = I[0]; b >= 10; b /= 10, E++) ;
        if (S = p - E, S < 0)
          S += j, k = p, x = I[T = 0], L = qe(x / J[E - k - 1] % 10);
        else if (T = ws((S + 1) / j), T >= I.length)
          if (y) {
            for (; I.length <= T; I.push(0)) ;
            x = L = 0, E = 1, S %= j, k = S - j + 1;
          } else
            break e;
        else {
          for (x = b = I[T], E = 1; b >= 10; b /= 10, E++) ;
          S %= j, k = S - j + E, L = k < 0 ? 0 : qe(x / J[E - k - 1] % 10);
        }
        if (y = y || p < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        I[T + 1] != null || (k < 0 ? x : x % J[E - k - 1]), y = m < 4 ? (L || y) && (m == 0 || m == (f.s < 0 ? 3 : 2)) : L > 5 || L == 5 && (m == 4 || y || m == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (S > 0 ? k > 0 ? x / J[E - k] : 0 : I[T - 1]) % 10 & 1 || m == (f.s < 0 ? 8 : 7)), p < 1 || !I[0])
          return I.length = 0, y ? (p -= f.e + 1, I[0] = J[(j - p % j) % j], f.e = -p || 0) : I[0] = f.e = 0, f;
        if (S == 0 ? (I.length = T, b = 1, T--) : (I.length = T + 1, b = J[j - S], I[T] = k > 0 ? qe(x / J[E - k] % J[k]) * b : 0), y)
          for (; ; )
            if (T == 0) {
              for (S = 1, k = I[0]; k >= 10; k /= 10, S++) ;
              for (k = I[0] += b, b = 1; k >= 10; k /= 10, b++) ;
              S != b && (f.e++, I[0] == Xe && (I[0] = 1));
              break;
            } else {
              if (I[T] += b, I[T] != Xe) break;
              I[T--] = 0, b = 1;
            }
        for (S = I.length; I[--S] === 0; I.pop()) ;
      }
      f.e > h ? f.c = f.e = null : f.e < c && (f.c = [f.e = 0]);
    }
    return f;
  }
  function H(f) {
    var p, m = f.e;
    return m === null ? f.toString() : (p = Je(f.c), p = m <= u || m >= l ? Wn(p, m) : Mt(p, m, "0"), f.s < 0 ? "-" + p : p);
  }
  return i.absoluteValue = i.abs = function() {
    var f = new g(this);
    return f.s < 0 && (f.s = 1), f;
  }, i.comparedTo = function(f, p) {
    return Wt(this, new g(f, p));
  }, i.decimalPlaces = i.dp = function(f, p) {
    var m, y, E, S = this;
    if (f != null)
      return fe(f, 0, Be), p == null ? p = a : fe(p, 0, 8), B(new g(S), f + S.e + 1, p);
    if (!(m = S.c)) return null;
    if (y = ((E = m.length - 1) - Ve(this.e / j)) * j, E = m[E]) for (; E % 10 == 0; E /= 10, y--) ;
    return y < 0 && (y = 0), y;
  }, i.dividedBy = i.div = function(f, p) {
    return r(this, new g(f, p), o, a);
  }, i.dividedToIntegerBy = i.idiv = function(f, p) {
    return r(this, new g(f, p), 0, 1);
  }, i.exponentiatedBy = i.pow = function(f, p) {
    var m, y, E, S, k, b, x, T, L, I = this;
    if (f = new g(f), f.c && !f.isInteger())
      throw Error(Ge + "Exponent not an integer: " + H(f));
    if (p != null && (p = new g(p)), b = f.e > 14, !I.c || !I.c[0] || I.c[0] == 1 && !I.e && I.c.length == 1 || !f.c || !f.c[0])
      return L = new g(Math.pow(+H(I), b ? f.s * (2 - Yn(f)) : +H(f))), p ? L.mod(p) : L;
    if (x = f.s < 0, p) {
      if (p.c ? !p.c[0] : !p.s) return new g(NaN);
      y = !x && I.isInteger() && p.isInteger(), y && (I = I.mod(p));
    } else {
      if (f.e > 9 && (I.e > 0 || I.e < -1 || (I.e == 0 ? I.c[0] > 1 || b && I.c[1] >= 24e7 : I.c[0] < 8e13 || b && I.c[0] <= 9999975e7)))
        return S = I.s < 0 && Yn(f) ? -0 : 0, I.e > -1 && (S = 1 / S), new g(x ? 1 / S : S);
      M && (S = ws(M / j + 2));
    }
    for (b ? (m = new g(0.5), x && (f.s = 1), T = Yn(f)) : (E = Math.abs(+H(f)), T = E % 2), L = new g(s); ; ) {
      if (T) {
        if (L = L.times(I), !L.c) break;
        S ? L.c.length > S && (L.c.length = S) : y && (L = L.mod(p));
      }
      if (E) {
        if (E = qe(E / 2), E === 0) break;
        T = E % 2;
      } else if (f = f.times(m), B(f, f.e + 1, 1), f.e > 14)
        T = Yn(f);
      else {
        if (E = +H(f), E === 0) break;
        T = E % 2;
      }
      I = I.times(I), S ? I.c && I.c.length > S && (I.c.length = S) : y && (I = I.mod(p));
    }
    return y ? L : (x && (L = s.div(L)), p ? L.mod(p) : S ? B(L, M, a, k) : L);
  }, i.integerValue = function(f) {
    var p = new g(this);
    return f == null ? f = a : fe(f, 0, 8), B(p, p.e + 1, f);
  }, i.isEqualTo = i.eq = function(f, p) {
    return Wt(this, new g(f, p)) === 0;
  }, i.isFinite = function() {
    return !!this.c;
  }, i.isGreaterThan = i.gt = function(f, p) {
    return Wt(this, new g(f, p)) > 0;
  }, i.isGreaterThanOrEqualTo = i.gte = function(f, p) {
    return (p = Wt(this, new g(f, p))) === 1 || p === 0;
  }, i.isInteger = function() {
    return !!this.c && Ve(this.e / j) > this.c.length - 2;
  }, i.isLessThan = i.lt = function(f, p) {
    return Wt(this, new g(f, p)) < 0;
  }, i.isLessThanOrEqualTo = i.lte = function(f, p) {
    return (p = Wt(this, new g(f, p))) === -1 || p === 0;
  }, i.isNaN = function() {
    return !this.s;
  }, i.isNegative = function() {
    return this.s < 0;
  }, i.isPositive = function() {
    return this.s > 0;
  }, i.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, i.minus = function(f, p) {
    var m, y, E, S, k = this, b = k.s;
    if (f = new g(f, p), p = f.s, !b || !p) return new g(NaN);
    if (b != p)
      return f.s = -p, k.plus(f);
    var x = k.e / j, T = f.e / j, L = k.c, I = f.c;
    if (!x || !T) {
      if (!L || !I) return L ? (f.s = -p, f) : new g(I ? k : NaN);
      if (!L[0] || !I[0])
        return I[0] ? (f.s = -p, f) : new g(L[0] ? k : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          a == 3 ? -0 : 0
        ));
    }
    if (x = Ve(x), T = Ve(T), L = L.slice(), b = x - T) {
      for ((S = b < 0) ? (b = -b, E = L) : (T = x, E = I), E.reverse(), p = b; p--; E.push(0)) ;
      E.reverse();
    } else
      for (y = (S = (b = L.length) < (p = I.length)) ? b : p, b = p = 0; p < y; p++)
        if (L[p] != I[p]) {
          S = L[p] < I[p];
          break;
        }
    if (S && (E = L, L = I, I = E, f.s = -f.s), p = (y = I.length) - (m = L.length), p > 0) for (; p--; L[m++] = 0) ;
    for (p = Xe - 1; y > b; ) {
      if (L[--y] < I[y]) {
        for (m = y; m && !L[--m]; L[m] = p) ;
        --L[m], L[y] += Xe;
      }
      L[y] -= I[y];
    }
    for (; L[0] == 0; L.splice(0, 1), --T) ;
    return L[0] ? G(f, L, T) : (f.s = a == 3 ? -1 : 1, f.c = [f.e = 0], f);
  }, i.modulo = i.mod = function(f, p) {
    var m, y, E = this;
    return f = new g(f, p), !E.c || !f.s || f.c && !f.c[0] ? new g(NaN) : !f.c || E.c && !E.c[0] ? new g(E) : (v == 9 ? (y = f.s, f.s = 1, m = r(E, f, 0, 3), f.s = y, m.s *= y) : m = r(E, f, 0, v), f = E.minus(m.times(f)), !f.c[0] && v == 1 && (f.s = E.s), f);
  }, i.multipliedBy = i.times = function(f, p) {
    var m, y, E, S, k, b, x, T, L, I, J, U, X, V, Z, z = this, $ = z.c, ee = (f = new g(f, p)).c;
    if (!$ || !ee || !$[0] || !ee[0])
      return !z.s || !f.s || $ && !$[0] && !ee || ee && !ee[0] && !$ ? f.c = f.e = f.s = null : (f.s *= z.s, !$ || !ee ? f.c = f.e = null : (f.c = [0], f.e = 0)), f;
    for (y = Ve(z.e / j) + Ve(f.e / j), f.s *= z.s, x = $.length, I = ee.length, x < I && (X = $, $ = ee, ee = X, E = x, x = I, I = E), E = x + I, X = []; E--; X.push(0)) ;
    for (V = Xe, Z = Ot, E = I; --E >= 0; ) {
      for (m = 0, J = ee[E] % Z, U = ee[E] / Z | 0, k = x, S = E + k; S > E; )
        T = $[--k] % Z, L = $[k] / Z | 0, b = U * T + L * J, T = J * T + b % Z * Z + X[S] + m, m = (T / V | 0) + (b / Z | 0) + U * L, X[S--] = T % V;
      X[S] = m;
    }
    return m ? ++y : X.splice(0, 1), G(f, X, y);
  }, i.negated = function() {
    var f = new g(this);
    return f.s = -f.s || null, f;
  }, i.plus = function(f, p) {
    var m, y = this, E = y.s;
    if (f = new g(f, p), p = f.s, !E || !p) return new g(NaN);
    if (E != p)
      return f.s = -p, y.minus(f);
    var S = y.e / j, k = f.e / j, b = y.c, x = f.c;
    if (!S || !k) {
      if (!b || !x) return new g(E / 0);
      if (!b[0] || !x[0]) return x[0] ? f : new g(b[0] ? y : E * 0);
    }
    if (S = Ve(S), k = Ve(k), b = b.slice(), E = S - k) {
      for (E > 0 ? (k = S, m = x) : (E = -E, m = b), m.reverse(); E--; m.push(0)) ;
      m.reverse();
    }
    for (E = b.length, p = x.length, E - p < 0 && (m = x, x = b, b = m, p = E), E = 0; p; )
      E = (b[--p] = b[p] + x[p] + E) / Xe | 0, b[p] = Xe === b[p] ? 0 : b[p] % Xe;
    return E && (b = [E].concat(b), ++k), G(f, b, k);
  }, i.precision = i.sd = function(f, p) {
    var m, y, E, S = this;
    if (f != null && f !== !!f)
      return fe(f, 1, Be), p == null ? p = a : fe(p, 0, 8), B(new g(S), f, p);
    if (!(m = S.c)) return null;
    if (E = m.length - 1, y = E * j + 1, E = m[E]) {
      for (; E % 10 == 0; E /= 10, y--) ;
      for (E = m[0]; E >= 10; E /= 10, y++) ;
    }
    return f && S.e + 1 > y && (y = S.e + 1), y;
  }, i.shiftedBy = function(f) {
    return fe(f, -9007199254740991, Il), this.times("1e" + f);
  }, i.squareRoot = i.sqrt = function() {
    var f, p, m, y, E, S = this, k = S.c, b = S.s, x = S.e, T = o + 4, L = new g("0.5");
    if (b !== 1 || !k || !k[0])
      return new g(!b || b < 0 && (!k || k[0]) ? NaN : k ? S : 1 / 0);
    if (b = Math.sqrt(+H(S)), b == 0 || b == 1 / 0 ? (p = Je(k), (p.length + x) % 2 == 0 && (p += "0"), b = Math.sqrt(+p), x = Ve((x + 1) / 2) - (x < 0 || x % 2), b == 1 / 0 ? p = "5e" + x : (p = b.toExponential(), p = p.slice(0, p.indexOf("e") + 1) + x), m = new g(p)) : m = new g(b + ""), m.c[0]) {
      for (x = m.e, b = x + T, b < 3 && (b = 0); ; )
        if (E = m, m = L.times(E.plus(r(S, E, T, 1))), Je(E.c).slice(0, b) === (p = Je(m.c)).slice(0, b))
          if (m.e < x && --b, p = p.slice(b - 3, b + 1), p == "9999" || !y && p == "4999") {
            if (!y && (B(E, E.e + o + 2, 0), E.times(E).eq(S))) {
              m = E;
              break;
            }
            T += 4, b += 4, y = 1;
          } else {
            (!+p || !+p.slice(1) && p.charAt(0) == "5") && (B(m, m.e + o + 2, 1), f = !m.times(m).eq(S));
            break;
          }
    }
    return B(m, m.e + o + 1, a, f);
  }, i.toExponential = function(f, p) {
    return f != null && (fe(f, 0, Be), f++), D(this, f, p, 1);
  }, i.toFixed = function(f, p) {
    return f != null && (fe(f, 0, Be), f = f + this.e + 1), D(this, f, p);
  }, i.toFormat = function(f, p, m) {
    var y, E = this;
    if (m == null)
      f != null && p && typeof p == "object" ? (m = p, p = null) : f && typeof f == "object" ? (m = f, f = p = null) : m = A;
    else if (typeof m != "object")
      throw Error(Ge + "Argument not an object: " + m);
    if (y = E.toFixed(f, p), E.c) {
      var S, k = y.split("."), b = +m.groupSize, x = +m.secondaryGroupSize, T = m.groupSeparator || "", L = k[0], I = k[1], J = E.s < 0, U = J ? L.slice(1) : L, X = U.length;
      if (x && (S = b, b = x, x = S, X -= S), b > 0 && X > 0) {
        for (S = X % b || b, L = U.substr(0, S); S < X; S += b) L += T + U.substr(S, b);
        x > 0 && (L += T + U.slice(S)), J && (L = "-" + L);
      }
      y = I ? L + (m.decimalSeparator || "") + ((x = +m.fractionGroupSize) ? I.replace(
        new RegExp("\\d{" + x + "}\\B", "g"),
        "$&" + (m.fractionGroupSeparator || "")
      ) : I) : L;
    }
    return (m.prefix || "") + y + (m.suffix || "");
  }, i.toFraction = function(f) {
    var p, m, y, E, S, k, b, x, T, L, I, J, U = this, X = U.c;
    if (f != null && (b = new g(f), !b.isInteger() && (b.c || b.s !== 1) || b.lt(s)))
      throw Error(Ge + "Argument " + (b.isInteger() ? "out of range: " : "not an integer: ") + H(b));
    if (!X) return new g(U);
    for (p = new g(s), T = m = new g(s), y = x = new g(s), J = Je(X), S = p.e = J.length - U.e - 1, p.c[0] = Es[(k = S % j) < 0 ? j + k : k], f = !f || b.comparedTo(p) > 0 ? S > 0 ? p : T : b, k = h, h = 1 / 0, b = new g(J), x.c[0] = 0; L = r(b, p, 0, 1), E = m.plus(L.times(y)), E.comparedTo(f) != 1; )
      m = y, y = E, T = x.plus(L.times(E = T)), x = E, p = b.minus(L.times(E = p)), b = E;
    return E = r(f.minus(m), y, 0, 1), x = x.plus(E.times(T)), m = m.plus(E.times(y)), x.s = T.s = U.s, S = S * 2, I = r(T, y, S, a).minus(U).abs().comparedTo(
      r(x, m, S, a).minus(U).abs()
    ) < 1 ? [T, y] : [x, m], h = k, I;
  }, i.toNumber = function() {
    return +H(this);
  }, i.toPrecision = function(f, p) {
    return f != null && fe(f, 1, Be), D(this, f, p, 2);
  }, i.toString = function(f) {
    var p, m = this, y = m.s, E = m.e;
    return E === null ? y ? (p = "Infinity", y < 0 && (p = "-" + p)) : p = "NaN" : (f == null ? p = E <= u || E >= l ? Wn(Je(m.c), E) : Mt(Je(m.c), E, "0") : f === 10 && C ? (m = B(new g(m), o + E + 1, a), p = Mt(Je(m.c), m.e, "0")) : (fe(f, 2, P.length, "Base"), p = e(Mt(Je(m.c), E, "0"), 10, f, y, !0)), y < 0 && m.c[0] && (p = "-" + p)), p;
  }, i.valueOf = i.toJSON = function() {
    return H(this);
  }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, t != null && g.set(t), g;
}
function Ve(t) {
  var r = t | 0;
  return t > 0 || t === r ? r : r - 1;
}
function Je(t) {
  for (var r, e, n = 1, i = t.length, s = t[0] + ""; n < i; ) {
    for (r = t[n++] + "", e = j - r.length; e--; r = "0" + r) ;
    s += r;
  }
  for (i = s.length; s.charCodeAt(--i) === 48; ) ;
  return s.slice(0, i + 1 || 1);
}
function Wt(t, r) {
  var e, n, i = t.c, s = r.c, o = t.s, a = r.s, u = t.e, l = r.e;
  if (!o || !a) return null;
  if (e = i && !i[0], n = s && !s[0], e || n) return e ? n ? 0 : -a : o;
  if (o != a) return o;
  if (e = o < 0, n = u == l, !i || !s) return n ? 0 : !i ^ e ? 1 : -1;
  if (!n) return u > l ^ e ? 1 : -1;
  for (a = (u = i.length) < (l = s.length) ? u : l, o = 0; o < a; o++) if (i[o] != s[o]) return i[o] > s[o] ^ e ? 1 : -1;
  return u == l ? 0 : u > l ^ e ? 1 : -1;
}
function fe(t, r, e, n) {
  if (t < r || t > e || t !== qe(t))
    throw Error(Ge + (n || "Argument") + (typeof t == "number" ? t < r || t > e ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t));
}
function Yn(t) {
  var r = t.c.length - 1;
  return Ve(t.e / j) == r && t.c[r] % 2 != 0;
}
function Wn(t, r) {
  return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (r < 0 ? "e" : "e+") + r;
}
function Mt(t, r, e) {
  var n, i;
  if (r < 0) {
    for (i = e + "."; ++r; i += e) ;
    t = i + t;
  } else if (n = t.length, ++r > n) {
    for (i = e, r -= n; --r; i += e) ;
    t += i;
  } else r < n && (t = t.slice(0, r) + "." + t.slice(r));
  return t;
}
var ft = Xc(), O2 = class {
  constructor(t) {
    w(this, "key");
    w(this, "left", null);
    w(this, "right", null);
    this.key = t;
  }
}, jr = class extends O2 {
  constructor(t) {
    super(t);
  }
}, G2 = class {
  constructor() {
    w(this, "size", 0);
    w(this, "modificationCount", 0);
    w(this, "splayCount", 0);
  }
  splay(t) {
    const r = this.root;
    if (r == null)
      return this.compare(t, t), -1;
    let e = null, n = null, i = null, s = null, o = r;
    const a = this.compare;
    let u;
    for (; ; )
      if (u = a(o.key, t), u > 0) {
        let l = o.left;
        if (l == null || (u = a(l.key, t), u > 0 && (o.left = l.right, l.right = o, o = l, l = o.left, l == null)))
          break;
        e == null ? n = o : e.left = o, e = o, o = l;
      } else if (u < 0) {
        let l = o.right;
        if (l == null || (u = a(l.key, t), u < 0 && (o.right = l.left, l.left = o, o = l, l = o.right, l == null)))
          break;
        i == null ? s = o : i.right = o, i = o, o = l;
      } else
        break;
    return i != null && (i.right = o.left, o.left = s), e != null && (e.left = o.right, o.right = n), this.root !== o && (this.root = o, this.splayCount++), u;
  }
  splayMin(t) {
    let r = t, e = r.left;
    for (; e != null; ) {
      const n = e;
      r.left = n.right, n.right = r, r = n, e = r.left;
    }
    return r;
  }
  splayMax(t) {
    let r = t, e = r.right;
    for (; e != null; ) {
      const n = e;
      r.right = n.left, n.left = r, r = n, e = r.right;
    }
    return r;
  }
  _delete(t) {
    if (this.root == null || this.splay(t) != 0) return null;
    let e = this.root;
    const n = e, i = e.left;
    if (this.size--, i == null)
      this.root = e.right;
    else {
      const s = e.right;
      e = this.splayMax(i), e.right = s, this.root = e;
    }
    return this.modificationCount++, n;
  }
  addNewRoot(t, r) {
    this.size++, this.modificationCount++;
    const e = this.root;
    if (e == null) {
      this.root = t;
      return;
    }
    r < 0 ? (t.left = e, t.right = e.right, e.right = null) : (t.right = e, t.left = e.left, e.left = null), this.root = t;
  }
  _first() {
    const t = this.root;
    return t == null ? null : (this.root = this.splayMin(t), this.root);
  }
  _last() {
    const t = this.root;
    return t == null ? null : (this.root = this.splayMax(t), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(t) {
    return this.validKey(t) && this.splay(t) == 0;
  }
  defaultCompare() {
    return (t, r) => t < r ? -1 : t > r ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (t) => {
        this.root = t;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (t) => {
        this.splayCount = t;
      },
      splay: (t) => this.splay(t),
      has: (t) => this.has(t)
    };
  }
}, Yl, Wl, Mi = class rn extends G2 {
  constructor(e, n) {
    super();
    w(this, "root", null);
    w(this, "compare");
    w(this, "validKey");
    w(this, Yl, "[object Set]");
    this.compare = e ?? this.defaultCompare(), this.validKey = n ?? ((i) => i != null && i != null);
  }
  delete(e) {
    return this.validKey(e) ? this._delete(e) != null : !1;
  }
  deleteAll(e) {
    for (const n of e)
      this.delete(n);
  }
  forEach(e) {
    const n = this[Symbol.iterator]();
    let i;
    for (; i = n.next(), !i.done; )
      e(i.value, i.value, this);
  }
  add(e) {
    const n = this.splay(e);
    return n != 0 && this.addNewRoot(new jr(e), n), this;
  }
  addAndReturn(e) {
    const n = this.splay(e);
    return n != 0 && this.addNewRoot(new jr(e), n), this.root.key;
  }
  addAll(e) {
    for (const n of e)
      this.add(n);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) < 0) return this.root.key;
    let i = this.root.left;
    if (i == null) return null;
    let s = i.right;
    for (; s != null; )
      i = s, s = i.right;
    return i.key;
  }
  firstAfter(e) {
    if (e == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(e) > 0) return this.root.key;
    let i = this.root.right;
    if (i == null) return null;
    let s = i.left;
    for (; s != null; )
      i = s, s = i.left;
    return i.key;
  }
  retainAll(e) {
    const n = new rn(this.compare, this.validKey), i = this.modificationCount;
    for (const s of e) {
      if (i != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(s) && this.splay(s) == 0 && n.add(this.root.key);
    }
    n.size != this.size && (this.root = n.root, this.size = n.size, this.modificationCount++);
  }
  lookup(e) {
    return !this.validKey(e) || this.splay(e) != 0 ? null : this.root.key;
  }
  intersection(e) {
    const n = new rn(this.compare, this.validKey);
    for (const i of this)
      e.has(i) && n.add(i);
    return n;
  }
  difference(e) {
    const n = new rn(this.compare, this.validKey);
    for (const i of this)
      e.has(i) || n.add(i);
    return n;
  }
  union(e) {
    const n = this.clone();
    return n.addAll(e), n;
  }
  clone() {
    const e = new rn(this.compare, this.validKey);
    return e.size = this.size, e.root = this.copyNode(this.root), e;
  }
  copyNode(e) {
    if (e == null) return null;
    function n(s, o) {
      let a, u;
      do {
        if (a = s.left, u = s.right, a != null) {
          const l = new jr(a.key);
          o.left = l, n(a, l);
        }
        if (u != null) {
          const l = new jr(u.key);
          o.right = l, s = u, o = l;
        }
      } while (u != null);
    }
    const i = new jr(e.key);
    return n(e, i), i;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new B2(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [(Wl = Symbol.iterator, Yl = Symbol.toStringTag, Wl)]() {
    return new R2(this.wrap());
  }
}, Kc = class {
  constructor(t) {
    w(this, "tree");
    w(this, "path", new Array());
    w(this, "modificationCount", null);
    w(this, "splayCount");
    this.tree = t, this.splayCount = t.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const t = this.path[this.path.length - 1];
    return this.getValue(t);
  }
  rebuildPath(t) {
    this.path.splice(0, this.path.length), this.tree.splay(t), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(t) {
    for (; t != null; )
      this.path.push(t), t = t.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let e = this.tree.getRoot();
        for (; e != null; )
          this.path.push(e), e = e.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return !1;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let t = this.path[this.path.length - 1], r = t.right;
    if (r != null) {
      for (; r != null; )
        this.path.push(r), r = r.left;
      return !0;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === t; )
      t = this.path.pop();
    return this.path.length > 0;
  }
}, R2 = class extends Kc {
  getValue(t) {
    return t.key;
  }
}, B2 = class extends Kc {
  getValue(t) {
    return [t.key, t.key];
  }
}, Qc = (t) => () => t, Zs = (t) => {
  const r = t ? (e, n) => n.minus(e).abs().isLessThanOrEqualTo(t) : Qc(!1);
  return (e, n) => r(e, n) ? 0 : e.comparedTo(n);
};
function N2(t) {
  const r = t ? (e, n, i, s, o) => e.exponentiatedBy(2).isLessThanOrEqualTo(
    s.minus(n).exponentiatedBy(2).plus(o.minus(i).exponentiatedBy(2)).times(t)
  ) : Qc(!1);
  return (e, n, i) => {
    const s = e.x, o = e.y, a = i.x, u = i.y, l = o.minus(u).times(n.x.minus(a)).minus(s.minus(a).times(n.y.minus(u)));
    return r(l, s, o, a, u) ? 0 : l.comparedTo(0);
  };
}
var U2 = (t) => t, H2 = (t) => {
  if (t) {
    const r = new Mi(Zs(t)), e = new Mi(Zs(t)), n = (s, o) => o.addAndReturn(s), i = (s) => ({
      x: n(s.x, r),
      y: n(s.y, e)
    });
    return i({ x: new ft(0), y: new ft(0) }), i;
  }
  return U2;
}, Xs = (t) => ({
  set: (r) => {
    Ct = Xs(r);
  },
  reset: () => Xs(t),
  compare: Zs(t),
  snap: H2(t),
  orient: N2(t)
}), Ct = Xs(), Zr = (t, r) => t.ll.x.isLessThanOrEqualTo(r.x) && r.x.isLessThanOrEqualTo(t.ur.x) && t.ll.y.isLessThanOrEqualTo(r.y) && r.y.isLessThanOrEqualTo(t.ur.y), Ks = (t, r) => {
  if (r.ur.x.isLessThan(t.ll.x) || t.ur.x.isLessThan(r.ll.x) || r.ur.y.isLessThan(t.ll.y) || t.ur.y.isLessThan(r.ll.y))
    return null;
  const e = t.ll.x.isLessThan(r.ll.x) ? r.ll.x : t.ll.x, n = t.ur.x.isLessThan(r.ur.x) ? t.ur.x : r.ur.x, i = t.ll.y.isLessThan(r.ll.y) ? r.ll.y : t.ll.y, s = t.ur.y.isLessThan(r.ur.y) ? t.ur.y : r.ur.y;
  return { ll: { x: e, y: i }, ur: { x: n, y: s } };
}, ni = (t, r) => t.x.times(r.y).minus(t.y.times(r.x)), ef = (t, r) => t.x.times(r.x).plus(t.y.times(r.y)), bi = (t) => ef(t, t).sqrt(), z2 = (t, r, e) => {
  const n = { x: r.x.minus(t.x), y: r.y.minus(t.y) }, i = { x: e.x.minus(t.x), y: e.y.minus(t.y) };
  return ni(i, n).div(bi(i)).div(bi(n));
}, J2 = (t, r, e) => {
  const n = { x: r.x.minus(t.x), y: r.y.minus(t.y) }, i = { x: e.x.minus(t.x), y: e.y.minus(t.y) };
  return ef(i, n).div(bi(i)).div(bi(n));
}, Fl = (t, r, e) => r.y.isZero() ? null : { x: t.x.plus(r.x.div(r.y).times(e.minus(t.y))), y: e }, Dl = (t, r, e) => r.x.isZero() ? null : { x: e, y: t.y.plus(r.y.div(r.x).times(e.minus(t.x))) }, q2 = (t, r, e, n) => {
  if (r.x.isZero()) return Dl(e, n, t.x);
  if (n.x.isZero()) return Dl(t, r, e.x);
  if (r.y.isZero()) return Fl(e, n, t.y);
  if (n.y.isZero()) return Fl(t, r, e.y);
  const i = ni(r, n);
  if (i.isZero()) return null;
  const s = { x: e.x.minus(t.x), y: e.y.minus(t.y) }, o = ni(s, r).div(i), a = ni(s, n).div(i), u = t.x.plus(a.times(r.x)), l = e.x.plus(o.times(n.x)), c = t.y.plus(a.times(r.y)), h = e.y.plus(o.times(n.y)), d = u.plus(l).div(2), v = c.plus(h).div(2);
  return { x: d, y: v };
}, at = class tf {
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(r, e) {
    w(this, "point");
    w(this, "isLeft");
    w(this, "segment");
    w(this, "otherSE");
    w(this, "consumedBy");
    r.events === void 0 ? r.events = [this] : r.events.push(this), this.point = r, this.isLeft = e;
  }
  // for ordering sweep events in the sweep event queue
  static compare(r, e) {
    const n = tf.comparePoints(r.point, e.point);
    return n !== 0 ? n : (r.point !== e.point && r.link(e), r.isLeft !== e.isLeft ? r.isLeft ? 1 : -1 : xi.compare(r.segment, e.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(r, e) {
    return r.x.isLessThan(e.x) ? -1 : r.x.isGreaterThan(e.x) ? 1 : r.y.isLessThan(e.y) ? -1 : r.y.isGreaterThan(e.y) ? 1 : 0;
  }
  link(r) {
    if (r.point === this.point)
      throw new Error("Tried to link already linked events");
    const e = r.point.events;
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      this.point.events.push(s), s.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const r = this.point.events.length;
    for (let e = 0; e < r; e++) {
      const n = this.point.events[e];
      if (n.segment.consumedBy === void 0)
        for (let i = e + 1; i < r; i++) {
          const s = this.point.events[i];
          s.consumedBy === void 0 && n.otherSE.point.events === s.otherSE.point.events && n.segment.consume(s.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const r = [];
    for (let e = 0, n = this.point.events.length; e < n; e++) {
      const i = this.point.events[e];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && r.push(i);
    }
    return r;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(r) {
    const e = /* @__PURE__ */ new Map(), n = (i) => {
      const s = i.otherSE;
      e.set(i, {
        sine: z2(this.point, r.point, s.point),
        cosine: J2(this.point, r.point, s.point)
      });
    };
    return (i, s) => {
      e.has(i) || n(i), e.has(s) || n(s);
      const { sine: o, cosine: a } = e.get(i), { sine: u, cosine: l } = e.get(s);
      return o.isGreaterThanOrEqualTo(0) && u.isGreaterThanOrEqualTo(0) ? a.isLessThan(l) ? 1 : a.isGreaterThan(l) ? -1 : 0 : o.isLessThan(0) && u.isLessThan(0) ? a.isLessThan(l) ? -1 : a.isGreaterThan(l) ? 1 : 0 : u.isLessThan(o) ? -1 : u.isGreaterThan(o) ? 1 : 0;
    };
  }
}, V2 = class Qs {
  constructor(r) {
    w(this, "events");
    w(this, "poly");
    w(this, "_isExteriorRing");
    w(this, "_enclosingRing");
    this.events = r;
    for (let e = 0, n = r.length; e < n; e++)
      r[e].segment.ringOut = this;
    this.poly = null;
  }
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(r) {
    const e = [];
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      if (!s.isInResult() || s.ringOut) continue;
      let o = null, a = s.leftSE, u = s.rightSE;
      const l = [a], c = a.point, h = [];
      for (; o = a, a = u, l.push(a), a.point !== c; )
        for (; ; ) {
          const d = a.getAvailableLinkedEvents();
          if (d.length === 0) {
            const A = l[0].point, P = l[l.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${A.x}, ${A.y}]. Last matching segment found ends at [${P.x}, ${P.y}].`
            );
          }
          if (d.length === 1) {
            u = d[0].otherSE;
            break;
          }
          let v = null;
          for (let A = 0, P = h.length; A < P; A++)
            if (h[A].point === a.point) {
              v = A;
              break;
            }
          if (v !== null) {
            const A = h.splice(v)[0], P = l.splice(A.index);
            P.unshift(P[0].otherSE), e.push(new Qs(P.reverse()));
            continue;
          }
          h.push({
            index: l.length,
            point: a.point
          });
          const M = a.getLeftmostComparator(o);
          u = d.sort(M)[0].otherSE;
          break;
        }
      e.push(new Qs(l));
    }
    return e;
  }
  getGeom() {
    let r = this.events[0].point;
    const e = [r];
    for (let l = 1, c = this.events.length - 1; l < c; l++) {
      const h = this.events[l].point, d = this.events[l + 1].point;
      Ct.orient(h, r, d) !== 0 && (e.push(h), r = h);
    }
    if (e.length === 1) return null;
    const n = e[0], i = e[1];
    Ct.orient(n, r, i) === 0 && e.shift(), e.push(e[0]);
    const s = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : e.length - 1, a = this.isExteriorRing() ? e.length : -1, u = [];
    for (let l = o; l != a; l += s)
      u.push([e[l].x.toNumber(), e[l].y.toNumber()]);
    return u;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const r = this.enclosingRing();
      this._isExteriorRing = r ? !r.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    var i, s;
    let r = this.events[0];
    for (let o = 1, a = this.events.length; o < a; o++) {
      const u = this.events[o];
      at.compare(r, u) > 0 && (r = u);
    }
    let e = r.segment.prevInResult(), n = e ? e.prevInResult() : null;
    for (; ; ) {
      if (!e) return null;
      if (!n) return e.ringOut;
      if (n.ringOut !== e.ringOut)
        return ((i = n.ringOut) == null ? void 0 : i.enclosingRing()) !== e.ringOut ? e.ringOut : (s = e.ringOut) == null ? void 0 : s.enclosingRing();
      e = n.prevInResult(), n = e ? e.prevInResult() : null;
    }
  }
}, Ol = class {
  constructor(t) {
    w(this, "exteriorRing");
    w(this, "interiorRings");
    this.exteriorRing = t, t.poly = this, this.interiorRings = [];
  }
  addInterior(t) {
    this.interiorRings.push(t), t.poly = this;
  }
  getGeom() {
    const t = this.exteriorRing.getGeom();
    if (t === null) return null;
    const r = [t];
    for (let e = 0, n = this.interiorRings.length; e < n; e++) {
      const i = this.interiorRings[e].getGeom();
      i !== null && r.push(i);
    }
    return r;
  }
}, Y2 = class {
  constructor(t) {
    w(this, "rings");
    w(this, "polys");
    this.rings = t, this.polys = this._composePolys(t);
  }
  getGeom() {
    const t = [];
    for (let r = 0, e = this.polys.length; r < e; r++) {
      const n = this.polys[r].getGeom();
      n !== null && t.push(n);
    }
    return t;
  }
  _composePolys(t) {
    var e;
    const r = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      if (!s.poly)
        if (s.isExteriorRing()) r.push(new Ol(s));
        else {
          const o = s.enclosingRing();
          o != null && o.poly || r.push(new Ol(o)), (e = o == null ? void 0 : o.poly) == null || e.addInterior(s);
        }
    }
    return r;
  }
}, W2 = class {
  constructor(t, r = xi.compare) {
    w(this, "queue");
    w(this, "tree");
    w(this, "segments");
    this.queue = t, this.tree = new Mi(r), this.segments = [];
  }
  process(t) {
    const r = t.segment, e = [];
    if (t.consumedBy)
      return t.isLeft ? this.queue.delete(t.otherSE) : this.tree.delete(r), e;
    t.isLeft && this.tree.add(r);
    let n = r, i = r;
    do
      n = this.tree.lastBefore(n);
    while (n != null && n.consumedBy != null);
    do
      i = this.tree.firstAfter(i);
    while (i != null && i.consumedBy != null);
    if (t.isLeft) {
      let s = null;
      if (n) {
        const a = n.getIntersection(r);
        if (a !== null && (r.isAnEndpoint(a) || (s = a), !n.isAnEndpoint(a))) {
          const u = this._splitSafely(n, a);
          for (let l = 0, c = u.length; l < c; l++)
            e.push(u[l]);
        }
      }
      let o = null;
      if (i) {
        const a = i.getIntersection(r);
        if (a !== null && (r.isAnEndpoint(a) || (o = a), !i.isAnEndpoint(a))) {
          const u = this._splitSafely(i, a);
          for (let l = 0, c = u.length; l < c; l++)
            e.push(u[l]);
        }
      }
      if (s !== null || o !== null) {
        let a = null;
        s === null ? a = o : o === null ? a = s : a = at.comparePoints(
          s,
          o
        ) <= 0 ? s : o, this.queue.delete(r.rightSE), e.push(r.rightSE);
        const u = r.split(a);
        for (let l = 0, c = u.length; l < c; l++)
          e.push(u[l]);
      }
      e.length > 0 ? (this.tree.delete(r), e.push(t)) : (this.segments.push(r), r.prev = n);
    } else {
      if (n && i) {
        const s = n.getIntersection(i);
        if (s !== null) {
          if (!n.isAnEndpoint(s)) {
            const o = this._splitSafely(n, s);
            for (let a = 0, u = o.length; a < u; a++)
              e.push(o[a]);
          }
          if (!i.isAnEndpoint(s)) {
            const o = this._splitSafely(i, s);
            for (let a = 0, u = o.length; a < u; a++)
              e.push(o[a]);
          }
        }
      }
      this.tree.delete(r);
    }
    return e;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(t, r) {
    this.tree.delete(t);
    const e = t.rightSE;
    this.queue.delete(e);
    const n = t.split(r);
    return n.push(e), t.consumedBy === void 0 && this.tree.add(t), n;
  }
}, $2 = class {
  constructor() {
    w(this, "type");
    w(this, "numMultiPolys");
  }
  run(t, r, e) {
    nn.type = t;
    const n = [new Rl(r, !0)];
    for (let l = 0, c = e.length; l < c; l++)
      n.push(new Rl(e[l], !1));
    if (nn.numMultiPolys = n.length, nn.type === "difference") {
      const l = n[0];
      let c = 1;
      for (; c < n.length; )
        Ks(n[c].bbox, l.bbox) !== null ? c++ : n.splice(c, 1);
    }
    if (nn.type === "intersection")
      for (let l = 0, c = n.length; l < c; l++) {
        const h = n[l];
        for (let d = l + 1, v = n.length; d < v; d++)
          if (Ks(h.bbox, n[d].bbox) === null) return [];
      }
    const i = new Mi(at.compare);
    for (let l = 0, c = n.length; l < c; l++) {
      const h = n[l].getSweepEvents();
      for (let d = 0, v = h.length; d < v; d++)
        i.add(h[d]);
    }
    const s = new W2(i);
    let o = null;
    for (i.size != 0 && (o = i.first(), i.delete(o)); o; ) {
      const l = s.process(o);
      for (let c = 0, h = l.length; c < h; c++) {
        const d = l[c];
        d.consumedBy === void 0 && i.add(d);
      }
      i.size != 0 ? (o = i.first(), i.delete(o)) : o = null;
    }
    Ct.reset();
    const a = V2.factory(s.segments);
    return new Y2(a).getGeom();
  }
}, nn = new $2(), eo = nn, j2 = 0, xi = class ii {
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(r, e, n, i) {
    w(this, "id");
    w(this, "leftSE");
    w(this, "rightSE");
    w(this, "rings");
    w(this, "windings");
    w(this, "ringOut");
    w(this, "consumedBy");
    w(this, "prev");
    w(this, "_prevInResult");
    w(this, "_beforeState");
    w(this, "_afterState");
    w(this, "_isInResult");
    this.id = ++j2, this.leftSE = r, r.segment = this, r.otherSE = e, this.rightSE = e, e.segment = this, e.otherSE = r, this.rings = n, this.windings = i;
  }
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(r, e) {
    const n = r.leftSE.point.x, i = e.leftSE.point.x, s = r.rightSE.point.x, o = e.rightSE.point.x;
    if (o.isLessThan(n)) return 1;
    if (s.isLessThan(i)) return -1;
    const a = r.leftSE.point.y, u = e.leftSE.point.y, l = r.rightSE.point.y, c = e.rightSE.point.y;
    if (n.isLessThan(i)) {
      if (u.isLessThan(a) && u.isLessThan(l)) return 1;
      if (u.isGreaterThan(a) && u.isGreaterThan(l)) return -1;
      const h = r.comparePoint(e.leftSE.point);
      if (h < 0) return 1;
      if (h > 0) return -1;
      const d = e.comparePoint(r.rightSE.point);
      return d !== 0 ? d : -1;
    }
    if (n.isGreaterThan(i)) {
      if (a.isLessThan(u) && a.isLessThan(c)) return -1;
      if (a.isGreaterThan(u) && a.isGreaterThan(c)) return 1;
      const h = e.comparePoint(r.leftSE.point);
      if (h !== 0) return h;
      const d = r.comparePoint(e.rightSE.point);
      return d < 0 ? 1 : d > 0 ? -1 : 1;
    }
    if (a.isLessThan(u)) return -1;
    if (a.isGreaterThan(u)) return 1;
    if (s.isLessThan(o)) {
      const h = e.comparePoint(r.rightSE.point);
      if (h !== 0) return h;
    }
    if (s.isGreaterThan(o)) {
      const h = r.comparePoint(e.rightSE.point);
      if (h < 0) return 1;
      if (h > 0) return -1;
    }
    if (!s.eq(o)) {
      const h = l.minus(a), d = s.minus(n), v = c.minus(u), M = o.minus(i);
      if (h.isGreaterThan(d) && v.isLessThan(M)) return 1;
      if (h.isLessThan(d) && v.isGreaterThan(M)) return -1;
    }
    return s.isGreaterThan(o) ? 1 : s.isLessThan(o) || l.isLessThan(c) ? -1 : l.isGreaterThan(c) ? 1 : r.id < e.id ? -1 : r.id > e.id ? 1 : 0;
  }
  static fromRing(r, e, n) {
    let i, s, o;
    const a = at.comparePoints(r, e);
    if (a < 0)
      i = r, s = e, o = 1;
    else if (a > 0)
      i = e, s = r, o = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${r.x}, ${r.y}]`
      );
    const u = new at(i, !0), l = new at(s, !1);
    return new ii(u, l, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(r) {
    this.rightSE = r, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const r = this.leftSE.point.y, e = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: r.isLessThan(e) ? r : e },
      ur: { x: this.rightSE.point.x, y: r.isGreaterThan(e) ? r : e }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(r) {
    return r.x.eq(this.leftSE.point.x) && r.y.eq(this.leftSE.point.y) || r.x.eq(this.rightSE.point.x) && r.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(r) {
    return Ct.orient(this.leftSE.point, r, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(r) {
    const e = this.bbox(), n = r.bbox(), i = Ks(e, n);
    if (i === null) return null;
    const s = this.leftSE.point, o = this.rightSE.point, a = r.leftSE.point, u = r.rightSE.point, l = Zr(e, a) && this.comparePoint(a) === 0, c = Zr(n, s) && r.comparePoint(s) === 0, h = Zr(e, u) && this.comparePoint(u) === 0, d = Zr(n, o) && r.comparePoint(o) === 0;
    if (c && l)
      return d && !h ? o : !d && h ? u : null;
    if (c)
      return h && s.x.eq(u.x) && s.y.eq(u.y) ? null : s;
    if (l)
      return d && o.x.eq(a.x) && o.y.eq(a.y) ? null : a;
    if (d && h) return null;
    if (d) return o;
    if (h) return u;
    const v = q2(s, this.vector(), a, r.vector());
    return v === null || !Zr(i, v) ? null : Ct.snap(v);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(r) {
    const e = [], n = r.events !== void 0, i = new at(r, !0), s = new at(r, !1), o = this.rightSE;
    this.replaceRightSE(s), e.push(s), e.push(i);
    const a = new ii(
      i,
      o,
      this.rings.slice(),
      this.windings.slice()
    );
    return at.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), at.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), s.checkForConsuming()), e;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const r = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = r, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let e = 0, n = this.windings.length; e < n; e++)
      this.windings[e] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(r) {
    let e = this, n = r;
    for (; e.consumedBy; ) e = e.consumedBy;
    for (; n.consumedBy; ) n = n.consumedBy;
    const i = ii.compare(e, n);
    if (i !== 0) {
      if (i > 0) {
        const s = e;
        e = n, n = s;
      }
      if (e.prev === n) {
        const s = e;
        e = n, n = s;
      }
      for (let s = 0, o = n.rings.length; s < o; s++) {
        const a = n.rings[s], u = n.windings[s], l = e.rings.indexOf(a);
        l === -1 ? (e.rings.push(a), e.windings.push(u)) : e.windings[l] += u;
      }
      n.rings = null, n.windings = null, n.consumedBy = e, n.leftSE.consumedBy = e.leftSE, n.rightSE.consumedBy = e.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const r = this.prev.consumedBy || this.prev;
      this._beforeState = r.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const r = this.beforeState();
    this._afterState = {
      rings: r.rings.slice(0),
      windings: r.windings.slice(0),
      multiPolys: []
    };
    const e = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let a = 0, u = this.rings.length; a < u; a++) {
      const l = this.rings[a], c = this.windings[a], h = e.indexOf(l);
      h === -1 ? (e.push(l), n.push(c)) : n[h] += c;
    }
    const s = [], o = [];
    for (let a = 0, u = e.length; a < u; a++) {
      if (n[a] === 0) continue;
      const l = e[a], c = l.poly;
      if (o.indexOf(c) === -1)
        if (l.isExterior) s.push(c);
        else {
          o.indexOf(c) === -1 && o.push(c);
          const h = s.indexOf(l.poly);
          h !== -1 && s.splice(h, 1);
        }
    }
    for (let a = 0, u = s.length; a < u; a++) {
      const l = s[a].multiPoly;
      i.indexOf(l) === -1 && i.push(l);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const r = this.beforeState().multiPolys, e = this.afterState().multiPolys;
    switch (eo.type) {
      case "union": {
        const n = r.length === 0, i = e.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        r.length < e.length ? (n = r.length, i = e.length) : (n = e.length, i = r.length), this._isInResult = i === eo.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(r.length - e.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(r) !== n(e);
        break;
      }
    }
    return this._isInResult;
  }
}, Gl = class {
  constructor(t, r, e) {
    w(this, "poly");
    w(this, "isExterior");
    w(this, "segments");
    w(this, "bbox");
    if (!Array.isArray(t) || t.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = r, this.isExterior = e, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const n = Ct.snap({ x: new ft(t[0][0]), y: new ft(t[0][1]) });
    this.bbox = {
      ll: { x: n.x, y: n.y },
      ur: { x: n.x, y: n.y }
    };
    let i = n;
    for (let s = 1, o = t.length; s < o; s++) {
      if (typeof t[s][0] != "number" || typeof t[s][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const a = Ct.snap({ x: new ft(t[s][0]), y: new ft(t[s][1]) });
      a.x.eq(i.x) && a.y.eq(i.y) || (this.segments.push(xi.fromRing(i, a, this)), a.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = a.x), a.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = a.y), a.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = a.x), a.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = a.y), i = a);
    }
    (!n.x.eq(i.x) || !n.y.eq(i.y)) && this.segments.push(xi.fromRing(i, n, this));
  }
  getSweepEvents() {
    const t = [];
    for (let r = 0, e = this.segments.length; r < e; r++) {
      const n = this.segments[r];
      t.push(n.leftSE), t.push(n.rightSE);
    }
    return t;
  }
}, Z2 = class {
  constructor(t, r) {
    w(this, "multiPoly");
    w(this, "exteriorRing");
    w(this, "interiorRings");
    w(this, "bbox");
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Gl(t[0], this, !0), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let e = 1, n = t.length; e < n; e++) {
      const i = new Gl(t[e], this, !1);
      i.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = i.bbox.ll.x), i.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = i.bbox.ll.y), i.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = i.bbox.ur.x), i.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = i.bbox.ur.y), this.interiorRings.push(i);
    }
    this.multiPoly = r;
  }
  getSweepEvents() {
    const t = this.exteriorRing.getSweepEvents();
    for (let r = 0, e = this.interiorRings.length; r < e; r++) {
      const n = this.interiorRings[r].getSweepEvents();
      for (let i = 0, s = n.length; i < s; i++)
        t.push(n[i]);
    }
    return t;
  }
}, Rl = class {
  constructor(t, r) {
    w(this, "isSubject");
    w(this, "polys");
    w(this, "bbox");
    if (!Array.isArray(t))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof t[0][0][0] == "number" && (t = [t]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new ft(Number.POSITIVE_INFINITY), y: new ft(Number.POSITIVE_INFINITY) },
      ur: { x: new ft(Number.NEGATIVE_INFINITY), y: new ft(Number.NEGATIVE_INFINITY) }
    };
    for (let e = 0, n = t.length; e < n; e++) {
      const i = new Z2(t[e], this);
      i.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = i.bbox.ll.x), i.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = i.bbox.ll.y), i.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = i.bbox.ur.x), i.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = i.bbox.ur.y), this.polys.push(i);
    }
    this.isSubject = r;
  }
  getSweepEvents() {
    const t = [];
    for (let r = 0, e = this.polys.length; r < e; r++) {
      const n = this.polys[r].getSweepEvents();
      for (let i = 0, s = n.length; i < s; i++)
        t.push(n[i]);
    }
    return t;
  }
}, X2 = (t, ...r) => eo.run("difference", t, r);
Ct.set;
function K2(t) {
  const r = [];
  if (yn(t, (i) => {
    r.push(i.coordinates);
  }), r.length < 2)
    throw new Error("Must have at least two features");
  const e = t.features[0].properties || {}, n = X2(r[0], ...r.slice(1));
  return n.length === 0 ? null : n.length === 1 ? er(n[0], e) : Ql(n, e);
}
var Q2 = K2;
function rf(t) {
  var r = new Ye(t);
  return r.insert = function(e) {
    if (e.type !== "Feature") throw new Error("invalid feature");
    return e.bbox = e.bbox ? e.bbox : bt(e), Ye.prototype.insert.call(this, e);
  }, r.load = function(e) {
    var n = [];
    return Array.isArray(e) ? e.forEach(function(i) {
      if (i.type !== "Feature") throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : bt(i), n.push(i);
    }) : Ut(e, function(i) {
      if (i.type !== "Feature") throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : bt(i), n.push(i);
    }), Ye.prototype.load.call(this, n);
  }, r.remove = function(e, n) {
    if (e.type !== "Feature") throw new Error("invalid feature");
    return e.bbox = e.bbox ? e.bbox : bt(e), Ye.prototype.remove.call(this, e, n);
  }, r.clear = function() {
    return Ye.prototype.clear.call(this);
  }, r.search = function(e) {
    var n = Ye.prototype.search.call(this, this.toBBox(e));
    return Me(n);
  }, r.collides = function(e) {
    return Ye.prototype.collides.call(this, this.toBBox(e));
  }, r.all = function() {
    var e = Ye.prototype.all.call(this);
    return Me(e);
  }, r.toJSON = function() {
    return Ye.prototype.toJSON.call(this);
  }, r.fromJSON = function(e) {
    return Ye.prototype.fromJSON.call(this, e);
  }, r.toBBox = function(e) {
    var n;
    if (e.bbox) n = e.bbox;
    else if (Array.isArray(e) && e.length === 4) n = e;
    else if (Array.isArray(e) && e.length === 6)
      n = [e[0], e[1], e[3], e[4]];
    else if (e.type === "Feature") n = bt(e);
    else if (e.type === "FeatureCollection") n = bt(e);
    else throw new Error("invalid geojson");
    return {
      minX: n[0],
      minY: n[1],
      maxX: n[2],
      maxY: n[3]
    };
  }, r;
}
function ew(t) {
  var r = t[0], e = t[1], n = t[2], i = t[3], s = lt(t.slice(0, 2), [n, e]), o = lt(t.slice(0, 2), [r, i]);
  if (s >= o) {
    var a = (e + i) / 2;
    return [
      r,
      a - (n - r) / 2,
      n,
      a + (n - r) / 2
    ];
  } else {
    var u = (r + n) / 2;
    return [
      u - (i - e) / 2,
      e,
      u + (i - e) / 2,
      i
    ];
  }
}
function tw(t, r) {
  if (r = r ?? {}, !oo(r)) throw new Error("options is invalid");
  var e = r.precision, n = r.coordinates, i = r.mutate;
  if (e = e == null || isNaN(e) ? 6 : e, n = n == null || isNaN(n) ? 3 : n, !t) throw new Error("<geojson> is required");
  if (typeof e != "number")
    throw new Error("<precision> must be a number");
  if (typeof n != "number")
    throw new Error("<coordinates> must be a number");
  (i === !1 || i === void 0) && (t = JSON.parse(JSON.stringify(t)));
  var s = Math.pow(10, e);
  return Yt(t, function(o) {
    rw(o, s, n);
  }), t;
}
function rw(t, r, e) {
  t.length > e && t.splice(e, t.length);
  for (var n = 0; n < t.length; n++)
    t[n] = Math.round(t[n] * r) / r;
  return t;
}
function nw(t) {
  if (!t)
    throw new Error("geojson is required");
  const r = [];
  return Ht(t, (e) => {
    iw(e, r);
  }), Me(r);
}
function iw(t, r) {
  let e = [];
  const n = t.geometry;
  if (n !== null) {
    switch (n.type) {
      case "Polygon":
        e = He(n);
        break;
      case "LineString":
        e = [He(n)];
    }
    e.forEach((i) => {
      sw(i, t.properties).forEach((o) => {
        o.id = r.length, r.push(o);
      });
    });
  }
}
function sw(t, r) {
  const e = [];
  return t.reduce((n, i) => {
    const s = un([n, i], r);
    return s.bbox = ow(n, i), e.push(s), i;
  }), e;
}
function ow(t, r) {
  const e = t[0], n = t[1], i = r[0], s = r[1], o = e < i ? e : i, a = n < s ? n : s, u = e > i ? e : i, l = n > s ? n : s;
  return [o, a, u, l];
}
var aw = Object.defineProperty, lw = Object.defineProperties, uw = Object.getOwnPropertyDescriptors, Bl = Object.getOwnPropertySymbols, cw = Object.prototype.hasOwnProperty, fw = Object.prototype.propertyIsEnumerable, Nl = (t, r, e) => r in t ? aw(t, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[r] = e, Ul = (t, r) => {
  for (var e in r || (r = {}))
    cw.call(r, e) && Nl(t, e, r[e]);
  if (Bl)
    for (var e of Bl(r))
      fw.call(r, e) && Nl(t, e, r[e]);
  return t;
}, Hl = (t, r) => lw(t, uw(r));
function hw(t, r, e = {}) {
  if (!t || !r)
    throw new Error("lines and pt are required arguments");
  const n = he(r);
  let i = Rt([1 / 0, 1 / 0], {
    dist: 1 / 0,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  }), s = 0;
  return Ht(
    t,
    function(o, a, u) {
      const l = He(o);
      for (let c = 0; c < l.length - 1; c++) {
        const h = Rt(l[c]);
        h.properties.dist = lt(r, h, e);
        const d = he(h), v = Rt(l[c + 1]);
        v.properties.dist = lt(r, v, e);
        const M = he(v), A = lt(h, v, e);
        let P, C;
        d[0] === n[0] && d[1] === n[1] ? [P, , C] = [d, void 0, !1] : M[0] === n[0] && M[1] === n[1] ? [P, , C] = [M, void 0, !0] : [P, , C] = gw(
          h.geometry.coordinates,
          v.geometry.coordinates,
          he(r)
        );
        let g;
        P && (g = Rt(P, {
          dist: lt(r, P, e),
          multiFeatureIndex: u,
          location: s + lt(h, P, e)
        })), g && g.properties.dist < i.properties.dist && (i = Hl(Ul({}, g), {
          properties: Hl(Ul({}, g.properties), {
            // Legacy behaviour where index progresses to next segment # if we
            // went with the end point this iteration.
            index: C ? c + 1 : c
          })
        })), s += A;
      }
    }
  ), i;
}
function dw(t, r) {
  const [e, n, i] = t, [s, o, a] = r;
  return e * s + n * o + i * a;
}
function pw(t, r) {
  const [e, n, i] = t, [s, o, a] = r;
  return [n * a - i * o, i * s - e * a, e * o - n * s];
}
function zl(t) {
  return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2));
}
function $t(t, r) {
  const e = dw(t, r) / (zl(t) * zl(r));
  return Math.acos(Math.min(Math.max(e, -1), 1));
}
function Ms(t) {
  const r = me(t[1]), e = me(t[0]);
  return [
    Math.cos(r) * Math.cos(e),
    Math.cos(r) * Math.sin(e),
    Math.sin(r)
  ];
}
function jt(t) {
  const [r, e, n] = t, i = Ar(Math.asin(n));
  return [Ar(Math.atan2(e, r)), i];
}
function gw(t, r, e) {
  const n = Ms(t), i = Ms(r), s = Ms(e), [o, a, u] = s, [l, c, h] = pw(n, i), d = c * u - h * a, v = h * o - l * u, M = l * a - c * o, A = M * c - v * h, P = d * h - M * l, C = v * l - d * c, g = 1 / Math.sqrt(Math.pow(A, 2) + Math.pow(P, 2) + Math.pow(C, 2)), D = [A * g, P * g, C * g], F = [-1 * A * g, -1 * P * g, -1 * C * g], G = $t(n, i), B = $t(n, D), H = $t(i, D), f = $t(n, F), p = $t(i, F);
  let m;
  return B < f && B < p || H < f && H < p ? m = D : m = F, $t(n, m) > G || $t(i, m) > G ? lt(jt(m), jt(n)) <= lt(jt(m), jt(i)) ? [jt(n), !0, !1] : [jt(i), !1, !0] : [jt(m), !1, !1];
}
function mw(t, r) {
  if (!t) throw new Error("line is required");
  if (!r) throw new Error("splitter is required");
  var e = ha(t), n = ha(r);
  if (e !== "LineString") throw new Error("line must be LineString");
  if (n === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (n === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var i = tw(r, { precision: 7 });
  switch (n) {
    case "Point":
      return to(t, i);
    case "MultiPoint":
      return Jl(t, i);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return Jl(
        t,
        _n(t, i, {
          ignoreSelfIntersections: !0
        })
      );
  }
}
function Jl(t, r) {
  var e = [], n = rf();
  return Ht(r, function(i) {
    if (e.forEach(function(a, u) {
      a.id = u;
    }), !e.length)
      e = to(t, i).features, e.forEach(function(a) {
        a.bbox || (a.bbox = ew(bt(a)));
      }), n.load(Me(e));
    else {
      var s = n.search(i);
      if (s.features.length) {
        var o = nf(i, s);
        e = e.filter(function(a) {
          return a.id !== o.id;
        }), n.remove(o), Ut(to(o, i), function(a) {
          e.push(a), n.insert(a);
        });
      }
    }
  }), Me(e);
}
function to(t, r) {
  var e = [], n = He(t)[0], i = He(t)[t.geometry.coordinates.length - 1];
  if (bs(n, he(r)) || bs(i, he(r)))
    return Me([t]);
  var s = rf(), o = nw(t);
  s.load(o);
  var a = s.search(r);
  if (!a.features.length) return Me([t]);
  var u = nf(r, a), l = [n], c = Zf(
    o,
    function(h, d, v) {
      var M = He(d)[1], A = he(r);
      return v === u.id ? (h.push(A), e.push(un(h)), bs(A, M) ? [A] : [A, M]) : (h.push(M), h);
    },
    l
  );
  return c.length > 1 && e.push(un(c)), Me(e);
}
function nf(t, r) {
  if (!r.features.length) throw new Error("lines must contain features");
  if (r.features.length === 1) return r.features[0];
  var e, n = 1 / 0;
  return Ut(r, function(i) {
    var s = hw(i, t), o = s.properties.dist;
    o < n && (e = i, n = o);
  }), e;
}
function bs(t, r) {
  return t[0] === r[0] && t[1] === r[1];
}
var vw = mw;
class yw extends kn {
  constructor() {
    super(...arguments);
    w(this, "mode", "cut");
    w(this, "lineDrawer", new qo(
      this.gm,
      { snappingMarkers: "first", targetShape: "polygon" }
    ));
    w(this, "cutShapesAllowed", ["circle", "line", "rectangle", "polygon"]);
    w(this, "mapEventHandlers", {
      [`${Y}:draw`]: this.forwardLineDrawerEvent.bind(this),
      mousemove: this.onMouseMove.bind(this)
    });
  }
  onStartAction() {
    this.lineDrawer.startAction(), this.lineDrawer.on(
      "firstMarkerClick",
      this.cutPolygonFinished.bind(this)
    );
  }
  onEndAction() {
    this.lineDrawer.endAction();
  }
  onMouseMove(e) {
    return ve(e) ? (this.lineDrawer.featureData || this.fireMarkerPointerUpdateEvent(), { next: !0 }) : { next: !0 };
  }
  cutPolygonFinished(e) {
    this.lineDrawer.endShape();
    const n = Jo(e.geoJson), i = this.getBBoxFeaturesByPolygon(n);
    this.cutFeaturesByPolygon(i, n);
  }
  getBBoxFeaturesByPolygon(e) {
    const n = Mo(e), i = this.gm.mapAdapter.coordBoundsToScreenBounds(n);
    return this.gm.mapAdapter.queryFeaturesByScreenCoordinates({
      queryCoordinates: i,
      sourceNames: [O.main]
    });
  }
  cutFeaturesByPolygon(e, n) {
    e.forEach((i) => {
      if (Ka(i.getGeoJson(), n)) {
        this.gm.features.delete(i), this.fireFeatureRemovedEvent(i);
        return;
      }
      if (F2(i.getGeoJson(), n) && this.cutShapesAllowed.includes(i.shape)) {
        if (i.shape === "line") {
          this.cutLineFeatureByPolygon(i, n);
          return;
        }
        this.cutPolygonFeatureByPolygon(i.id, n);
      }
    });
  }
  cutLineFeatureByPolygon(e, n) {
    const i = e.getGeoJson(), s = vw(i, n);
    if (s.features.length === 0)
      return;
    const o = [];
    if (s.features.filter((a) => !Ka(a, n)).forEach((a) => {
      const u = this.createLineFeature(tc(a));
      u && o.push(u);
    }), this.gm.features.delete(e), !P2(o)) {
      N.error("cutLineFeatureByPolygon: resultFeatures not found", s);
      return;
    }
    this.fireFeatureUpdatedEvent({
      sourceFeatures: [e],
      targetFeatures: o
    });
  }
  createLineFeature(e) {
    const n = {
      ...e,
      properties: {
        shape: "line"
      }
    };
    return this.gm.features.createFeature({
      shapeGeoJson: n,
      sourceName: O.main
    });
  }
  cutPolygonFeatureByPolygon(e, n) {
    const i = this.gm.features.get(O.main, e);
    if (!i) {
      N.warn("cutPolygonFeatureByPolygon: featureData not found", e);
      return;
    }
    i.convertToPolygon();
    const s = i.getGeoJson(), o = this.getGeoJsonDifference(s, n);
    o && (i.updateGeoJsonGeometry(o.geometry), this.fireFeatureUpdatedEvent({
      sourceFeatures: [i],
      targetFeatures: [i]
    }));
  }
  getGeoJsonDifference(e, n) {
    const i = Me([e, n]), s = Q2(i);
    return s ? s.type === "Feature" ? s : (s.type === "FeatureCollection" && N.error("getGeoJsonDifference: FeatureCollection detected (not supported)", s), null) : null;
  }
}
class ww extends kn {
  constructor() {
    super(...arguments);
    w(this, "mode", "delete");
    w(this, "mapEventHandlers", {
      click: this.onMouseClick.bind(this)
    });
  }
  onStartAction() {
    this.gm.markerPointer.enable({ invisibleMarker: !0 }), this.gm.markerPointer.pauseSnapping();
  }
  onEndAction() {
    this.gm.markerPointer.resumeSnapping(), this.gm.markerPointer.disable();
  }
  onMouseClick(e) {
    if (!ve(e, { warning: !0 }))
      return { next: !1 };
    const n = this.gm.features.getFeatureByMouseEvent({ event: e, sourceNames: [O.main] });
    return n && (this.gm.features.delete(n), this.fireFeatureRemovedEvent(n)), { next: !1 };
  }
}
class Ew extends Vo {
  constructor() {
    super(...arguments);
    w(this, "mode", "drag");
  }
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(e) {
    return Br(e) ? e.action === "marker_move" && e.lngLatStart && e.lngLatEnd ? (this.previousLngLat || (this.previousLngLat = e.lngLatStart), this.moveFeature(e.featureData, e.lngLatEnd), { next: !1 }) : (e.action === "marker_captured" ? (this.isDragging = !0, e.featureData.changeSource({ sourceName: O.temporary, atomic: !0 }), this.fireFeatureEditStartEvent({ feature: e.featureData })) : e.action === "marker_released" && (this.previousLngLat = null, this.isDragging = !1, e.featureData.changeSource({ sourceName: O.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: e.featureData })), { next: !0 }) : (N.error("EditDrag.handleGmEdit: not an edit event", e), { next: !0 });
  }
}
function sf(t, r, e = {}) {
  if (e.final === !0)
    return Mw(t, r);
  const n = he(t), i = he(r), s = me(n[0]), o = me(i[0]), a = me(n[1]), u = me(i[1]), l = Math.sin(o - s) * Math.cos(u), c = Math.cos(a) * Math.sin(u) - Math.sin(a) * Math.cos(u) * Math.cos(o - s);
  return Ar(Math.atan2(l, c));
}
function Mw(t, r) {
  let e = sf(r, t);
  return e = (e + 180) % 360, e;
}
var ql = sf;
function bw(t, r, e) {
  if (e = e || {}, !oo(e)) throw new Error("options is invalid");
  const n = e.pivot, i = e.mutate;
  if (!t) throw new Error("geojson is required");
  if (r == null || isNaN(r))
    throw new Error("angle is required");
  if (r === 0) return t;
  const s = n ?? Vu(t);
  return (i === !1 || i === void 0) && (t = Oi(t)), Yt(t, function(o) {
    const u = qy(s, o) + r, l = Vy(s, o), c = He(
      Wy(s, l, u)
    );
    o[0] = c[0], o[1] = c[1];
  }), t;
}
var xw = bw;
class _w extends Vo {
  constructor() {
    super(...arguments);
    w(this, "mode", "rotate");
    w(this, "convertFeaturesTypes", ["rectangle"]);
  }
  onStartAction() {
  }
  onEndAction() {
  }
  handleGmEdit(e) {
    var n;
    return Br(e) ? e.action === "marker_move" && e.lngLatStart && e.lngLatEnd ? (((n = e.markerData) == null ? void 0 : n.type) === "vertex" ? this.moveVertex(e) : this.moveSource(e.featureData, e.lngLatStart, e.lngLatEnd), { next: !1 }) : (e.action === "marker_captured" ? (e.featureData.changeSource({ sourceName: O.temporary, atomic: !0 }), this.fireFeatureEditStartEvent({ feature: e.featureData })) : e.action === "marker_released" && (e.featureData.changeSource({ sourceName: O.main, atomic: !0 }), this.fireFeatureEditEndEvent({ feature: e.featureData })), { next: !0 }) : (N.error("EditChange.handleGmEdit: not an edit event", e), { next: !1 });
  }
  moveVertex(e) {
    this.rotateFeature(e.featureData, e);
  }
  rotateFeature(e, n) {
    const i = je(e.getGeoJson()), s = Hu(Yu(i)), o = this.calculateRotationAngle(
      s,
      n.lngLatStart,
      n.lngLatEnd
    );
    i.geometry = xw(i, o, { pivot: s }).geometry, this.fireBeforeFeatureUpdate({
      features: [e],
      geoJsonFeatures: [i]
    }), this.updateFeatureGeoJson({ featureData: e, featureGeoJson: i }) && e.convertToPolygon();
  }
  calculateRotationAngle(e, n, i) {
    const s = ql(e, n);
    return (ql(e, i) - s + 360) % 360;
  }
}
const ro = {
  drag: Ew,
  change: T2,
  rotate: _w,
  scale: null,
  copy: null,
  cut: yw,
  split: null,
  union: null,
  difference: null,
  line_simplification: null,
  lasso: null,
  delete: ww
}, Sw = (t, r) => ro[r] ? new ro[r](t) : (N.error(`Edit "${r}" is not available`), null);
class Aw extends Fi {
  constructor(e, n) {
    super(e);
    w(this, "mapEventHandlers", {
      [`${Y}:edit`]: this.handleEditEvent.bind(this)
    });
    n.attachEvents(this.mapEventHandlers);
  }
  handleEditEvent(e) {
    if (!Br(e))
      return { next: !0 };
    const n = `${e.type}__${e.mode}`;
    return e.action === "mode_start" ? (this.trackExclusiveModes(e), this.start(n, e), this.trackRelatedModes(e)) : e.action === "mode_end" && (this.trackRelatedModes(e), this.end(n)), { next: !0 };
  }
  start(e, n) {
    if (n.action !== "mode_start")
      return;
    const i = Sw(this.gm, n.mode);
    i && (e in this.gm.actionInstances && N.error(`Action instance "${e}" already exists`), this.gm.actionInstances[e] = i, i.startAction());
  }
  end(e) {
    const n = this.gm.actionInstances[e];
    n instanceof kn ? (n.endAction(), delete this.gm.actionInstances[e]) : console.error(
      `Wrong action instance for edit event "${e}": `,
      n
    );
  }
}
const Lw = (t, r) => {
  let e = null;
  try {
    t.forEach((n) => {
      if (r(n))
        throw e = n, new Error("found");
    });
  } catch {
  }
  return e;
};
var $l;
class Cw extends ar {
  constructor() {
    super(...arguments);
    w(this, "mode", "shape_markers");
    w(this, "pinEnabled", (($l = this.gm.options.controls.helper.pin) == null ? void 0 : $l.active) || !1);
    w(this, "previousPosition", null);
    w(this, "activeMarker", null);
    w(this, "activeFeatureData", null);
    w(this, "sharedMarkers", []);
    w(this, "allowedShapes", ["circle", "line", "rectangle", "polygon"]);
    w(this, "edgeMarkersAllowed", !1);
    w(this, "edgeMarkerAllowedShapes", ["line", "rectangle", "polygon"]);
    w(this, "shapeMarkerAllowedModes", ["drag", "change", "cut", "split"]);
    w(this, "mapEventHandlers", {
      [`${Y}:draw`]: this.handleGmDraw.bind(this),
      [`${Y}:edit`]: this.handleGmEdit.bind(this),
      mousedown: this.onMouseDown.bind(this),
      touchstart: this.onMouseDown.bind(this),
      mouseup: this.onMouseUp.bind(this),
      touchend: this.onMouseUp.bind(this),
      mousemove: this.onMouseMove.bind(this),
      touchmove: this.onMouseMove.bind(this),
      contextmenu: this.onMouseRightButtonClick.bind(this)
    });
    w(this, "throttledMethods", Rr({
      sendMarkerMoveEvent: this.sendMarkerMoveEvent,
      sendMarkerRightClickEvent: this.sendMarkerRightClickEvent
    }, this, this.gm.options.settings.throttlingDelay));
    w(this, "debouncedMethods", Gy({
      refreshMarkers: this.refreshMarkers
    }, this, this.gm.options.settings.throttlingDelay * 10));
  }
  onStartAction() {
    this.isShapeMarkerAllowed() && this.gm.markerPointer.enable({ invisibleMarker: !0 }), this.edgeMarkersAllowed = this.gm.getActiveEditModes().includes("change"), this.addMarkers();
  }
  onEndAction() {
    this.gm.markerPointer.disable(), this.removeMarkers();
  }
  setPin(e) {
    this.pinEnabled = e;
  }
  onMouseDown(e) {
    var s;
    const n = ["mousedown", "touchstart"];
    if (!ve(e, { warning: !0 }) || !n.includes(e.type))
      return { next: !0 };
    if (e.type === "mousedown" && e.originalEvent.button !== 0)
      return { next: !0 };
    const i = this.getFeatureMarkerByMouseEvent(e);
    return this.activeMarker = i || null, this.activeFeatureData = (i == null ? void 0 : i.instance.parent) || null, this.activeMarker && this.activeFeatureData ? (this.previousPosition = Lo(this.activeMarker.instance), this.gm.mapAdapter.setDragPan(!1), this.activeMarker.type === "edge" && this.sendMarkerEvent("edge_marker_click", this.activeFeatureData, this.activeMarker), this.pinEnabled ? (this.sharedMarkers = this.getSharedMarkers(this.activeMarker.position.coordinate), this.sharedMarkers.forEach(
      (o) => {
        var a;
        return (a = this.snappingHelper) == null ? void 0 : a.addExcludedFeature(o.featureData);
      }
    )) : (s = this.snappingHelper) == null || s.addExcludedFeature(this.activeFeatureData), this.sendMarkerEvent("marker_captured", this.activeFeatureData, this.activeMarker), { next: !1 }) : { next: !0 };
  }
  onMouseUp() {
    var n;
    if (!this.activeMarker)
      return { next: !0 };
    const e = {
      featureData: this.activeFeatureData,
      markerData: this.activeMarker
    };
    return this.activeMarker = null, this.activeFeatureData = null, this.sharedMarkers = [], (n = this.snappingHelper) == null || n.clearExcludedFeatures(), this.previousPosition = null, this.gm.mapAdapter.setDragPan(!0), e.featureData && e.markerData ? (this.sendMarkerEvent("marker_released", e.featureData, e.markerData), { next: !1 }) : (N.debug("ShapeMarkersHelper.onMouseUp: no active marker or featureData", e), { next: !0 });
  }
  onMouseMove(e) {
    return !this.activeMarker || !ve(e, { warning: !0 }) ? { next: !0 } : (this.throttledMethods.sendMarkerMoveEvent(e), { next: !1 });
  }
  onMouseRightButtonClick(e) {
    const n = this.getFeatureMarkerByMouseEvent(e);
    return n && n.instance.parent ? (this.throttledMethods.sendMarkerRightClickEvent(
      n.instance.parent,
      n
    ), { next: !1 }) : { next: !0 };
  }
  isShapeMarkerAllowed() {
    return gm(
      this.shapeMarkerAllowedModes,
      this.gm.getActiveEditModes()
    ).length > 0;
  }
  convertToVertexMarker(e) {
    if (e.type === "edge" && e.instance.parent) {
      const n = e.position, i = e.instance.parent;
      this.removeMarker(e);
      const s = this.createMarker({
        type: "vertex",
        positionData: n,
        parentFeature: i
      }), o = i.getGeoJson(), a = Nu(o, n.coordinate);
      if (a) {
        const u = a.path.join("."), l = i.markers.get(u);
        return l && this.removeMarker(l), i.markers.set(u, s), s;
      }
    }
    return N.error("ShapeMarkersHelper.convertToVertexMarker: invalid marker type", e), e;
  }
  getSharedMarkers(e) {
    const n = [];
    return this.gm.features.forEach((i) => {
      i.markers.forEach((s) => {
        s.type === "vertex" && on(s.position.coordinate, e) && n.push({ featureData: i, markerData: s });
      });
    }), n;
  }
  getFeatureMarkerByMouseEvent(e) {
    var i;
    const n = this.gm.features.getFeatureByMouseEvent({
      event: e,
      sourceNames: [O.main]
    });
    if ((i = n == null ? void 0 : n.parent) != null && i.markers) {
      const s = Lw(
        n.parent.markers,
        (o) => o.instance === n
      );
      if ((s == null ? void 0 : s.type) !== "dom")
        return s;
    }
    return null;
  }
  addMarkers() {
    this.gm.features.forEach((e) => {
      if (!e || !this.allowedShapes.includes(e.shape))
        return;
      this.addCenterMarker(e);
      const n = this.getAllShapeSegments(e);
      n.forEach((i, s) => {
        if (this.isMarkerIndexAllowed(
          e.shape,
          s,
          n.length
        )) {
          const a = this.createOrUpdateVertexMarker(i.segment.start, e);
          if (e.markers.set(a.markerKey, a.markerData), e.shape === "line" && s === n.length - 1) {
            const u = this.createOrUpdateVertexMarker(
              i.segment.end,
              e
            );
            e.markers.set(u.markerKey, u.markerData);
          }
        }
        if (this.isEdgeMarkerAllowed(e)) {
          const a = this.createOrUpdateEdgeMarker(i, e);
          e.markers.set(a.markerKey, a.markerData);
        }
      });
    });
  }
  addCenterMarker(e) {
    if (e.shapeProperties.center) {
      const n = this.createMarker({
        type: "center",
        positionData: {
          path: [],
          coordinate: e.shapeProperties.center
        },
        parentFeature: e
      });
      e.markers.set("center", n);
    }
  }
  getAllShapeSegments(e) {
    const n = e.getGeoJson(), i = [];
    return Uu(n, (s, o) => {
      i.push({
        segment: s,
        middle: this.getSegmentMiddlePosition(s),
        edgeMarkerKey: this.getEdgeMarkerKey(o)
      });
    }), i;
  }
  isEdgeMarkerAllowed(e) {
    return this.edgeMarkersAllowed && this.edgeMarkerAllowedShapes.includes(e.shape);
  }
  isMarkerIndexAllowed(e, n, i) {
    const s = Math.floor(i / 4);
    return e === "circle" ? (n + s / 2) % s === 0 : !0;
  }
  getEdgeMarkerKey(e) {
    return `edge.${e}`;
  }
  getSegmentMiddlePosition(e) {
    const n = this.gm.mapAdapter.project(e.start.coordinate), i = this.gm.mapAdapter.project(e.end.coordinate), s = [
      (n[0] + i[0]) / 2,
      (n[1] + i[1]) / 2
    ], o = e.start.path.slice(0, e.start.path.length - 1).concat([-1]);
    return {
      coordinate: this.gm.mapAdapter.unproject(s),
      path: o
    };
  }
  removeMarkers() {
    this.gm.features.forEach((e, n) => {
      const i = this.gm.features.get(O.main, n);
      i && (i.markers.forEach((s) => {
        s.type !== "dom" ? this.gm.features.delete(s.instance) : N.error("Non a FeatureData marker", s);
      }), i.markers = /* @__PURE__ */ new Map());
    });
  }
  removeMarker(e) {
    if (e.type === "dom") {
      N.error("Wrong marker type", e);
      return;
    }
    const n = e.instance.parent;
    if (!n) {
      N.error("Missing parent feature data", e);
      return;
    }
    try {
      n.markers.forEach((i, s) => {
        if (i === e)
          throw this.gm.features.delete(i.instance), n.markers.delete(s), new Error("break");
      });
    } catch {
    }
  }
  createMarker({ type: e, segment: n, positionData: i, parentFeature: s }) {
    const o = i.coordinate, a = this.gm.features.createMarkerFeature({
      sourceName: s.sourceName,
      parentFeature: s,
      type: e,
      coordinate: o
    });
    if (!a)
      throw new Error(`Missine feature data for the "${e}" marker`);
    if (e === "edge" && n)
      return {
        type: e,
        instance: a,
        position: je(i),
        segment: n
      };
    if (e === "vertex" || e === "center")
      return {
        type: e,
        instance: a,
        position: je(i)
      };
    throw new Error(`Invalid marker type "${e}" with segment: ${n}`);
  }
  handleGmDraw(e) {
    return So(e) ? (e.action === "feature_created" && this.debouncedMethods.refreshMarkers(), { next: !0 }) : (N.error("ShapeMarkersHelper.handleGmDraw: not a draw event", e), { next: !0 });
  }
  refreshMarkers() {
    this.removeMarkers(), this.addMarkers();
  }
  handleGmEdit(e) {
    return Br(e) ? (e.action === "feature_updated" && this.gm.features.withAtomicSourcesUpdate(() => {
      this.handleShapeUpdate(e);
    }), { next: !0 }) : (N.error("ShapeMarkersHelper.handleGmEdit: not an edit event", e), { next: !0 });
  }
  handleShapeUpdate(e) {
    var o;
    const n = e.targetFeatures[0];
    if (!n) {
      N.error("ShapeMarkersHelper.handleShapeUpdate: no featureData", e);
      return;
    }
    ((o = this.activeMarker) == null ? void 0 : o.type) === "edge" && (this.activeMarker = this.convertToVertexMarker(this.activeMarker));
    const i = this.getAllShapeSegments(n), s = new Set(n.markers.keys());
    i.forEach((a, u) => {
      if (this.isMarkerIndexAllowed(
        n.shape,
        u,
        i.length
      )) {
        const c = this.createOrUpdateVertexMarker(a.segment.start, n);
        if (s.delete(c.markerKey), n.shape === "line" && u === i.length - 1) {
          const h = this.createOrUpdateVertexMarker(
            a.segment.end,
            n
          );
          s.delete(h.markerKey);
        }
      }
      if (this.isEdgeMarkerAllowed(n)) {
        const c = this.createOrUpdateEdgeMarker(a, n);
        s.delete(c.markerKey);
      }
    }), this.updateCenterMarkerPosition(n), s.delete("center"), s.forEach((a) => {
      const u = n.markers.get(a);
      u && u.type !== "dom" ? this.gm.features.delete(u.instance) : N.error("Non a FeatureData marker"), n.markers.delete(a);
    });
  }
  createOrUpdateVertexMarker(e, n) {
    const i = e.path.join(".");
    let s = n.markers.get(i) || null;
    if (s && (s == null ? void 0 : s.type) !== "vertex")
      throw new Error(`Invalid marker type "${s == null ? void 0 : s.type}" for edge marker`);
    return s ? (on(s.position.coordinate, e.coordinate) || this.gm.features.updateMarkerFeaturePosition(s.instance, e.coordinate), s.position = e) : (s = this.createMarker({
      type: "vertex",
      positionData: e,
      parentFeature: n
    }), n.markers.set(i, s)), { markerKey: i, markerData: s };
  }
  createOrUpdateEdgeMarker(e, n) {
    let i = n.markers.get(e.edgeMarkerKey) || null;
    if (i && (i == null ? void 0 : i.type) !== "edge")
      throw new Error(`Invalid marker type "${i == null ? void 0 : i.type}" for edge marker`);
    return i ? (on(i.position.coordinate, e.middle.coordinate) || i.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: e.middle.coordinate
    }), i.position = e.middle, i.segment = e.segment) : (i = this.createMarker({
      type: "edge",
      positionData: e.middle,
      segment: e.segment,
      parentFeature: n
    }), n.markers.set(e.edgeMarkerKey, i)), { markerKey: e.edgeMarkerKey, markerData: i };
  }
  updateCenterMarkerPosition(e) {
    const n = e.markers.get("center") || null;
    n && n.type !== "dom" && e.shapeProperties.center && (n.instance.updateGeoJsonGeometry({
      type: "Point",
      coordinates: e.shapeProperties.center
    }), n.position.coordinate = e.shapeProperties.center);
  }
  sendMarkerEvent(e, n, i) {
    const s = {
      level: "system",
      type: "edit",
      mode: "change",
      action: e,
      featureData: n,
      markerData: i
    };
    this.gm.events.fire(`${Y}:edit`, s);
  }
  sendMarkerRightClickEvent(e, n) {
    const i = {
      level: "system",
      type: "edit",
      mode: "change",
      action: "marker_right_click",
      featureData: e,
      markerData: n
    };
    this.gm.events.fire(`${Y}:edit`, i);
  }
  sendMarkerMoveEvent(e) {
    var i;
    const n = ((i = this.gm.markerPointer.marker) == null ? void 0 : i.getLngLat()) || e.lngLat.toArray();
    this.activeMarker && this.activeFeatureData && (this.pinEnabled ? this.sharedMarkers : [{
      markerData: this.activeMarker,
      featureData: this.activeFeatureData
    }]).forEach((o) => {
      if (this.previousPosition) {
        const a = {
          level: "system",
          type: "edit",
          mode: "drag",
          action: "marker_move",
          featureData: o.featureData,
          markerData: o.markerData,
          lngLatStart: this.previousPosition,
          lngLatEnd: n
        };
        this.gm.events.fire(`${Y}:edit`, a);
      }
    }), this.previousPosition = n;
  }
}
class kw extends ar {
  constructor() {
    super(...arguments);
    w(this, "mode", "snapping");
    w(this, "tolerance", 18);
    w(this, "excludedFeature", /* @__PURE__ */ new Set());
    w(this, "customSnappingLngLats", /* @__PURE__ */ new Map());
    w(this, "customSnappingFeatures", /* @__PURE__ */ new Set());
    w(this, "lineSnappingShapes", [
      "circle",
      "line",
      "rectangle",
      "polygon",
      "snap_guide"
    ]);
    w(this, "mapEventHandlers", {});
    w(this, "shapeSnappingHandlers", {
      marker: this.getPointsSnapping.bind(this),
      circle: this.getLineSnapping.bind(this),
      circle_marker: this.getPointsSnapping.bind(this),
      text_marker: this.getPointsSnapping.bind(this),
      line: this.getLineSnapping.bind(this),
      rectangle: this.getLineSnapping.bind(this),
      polygon: this.getLineSnapping.bind(this),
      snap_guide: this.getLineSnapping.bind(this)
    });
  }
  onStartAction() {
    this.gm.markerPointer.setSnapping(!0);
  }
  onEndAction() {
    this.gm.markerPointer.setSnapping(!1);
  }
  addExcludedFeature(e) {
    this.excludedFeature.add(e);
  }
  clearExcludedFeatures() {
    this.excludedFeature.clear();
  }
  addCustomSnappingFeature(e) {
    this.customSnappingFeatures.add(e);
  }
  removeCustomSnappingFeature(e) {
    this.customSnappingFeatures.delete(e);
  }
  clearCustomSnappingFeature() {
    this.customSnappingFeatures.clear();
  }
  setCustomSnappingCoordinates(e, n) {
    this.customSnappingLngLats.set(e, n);
  }
  clearCustomSnappingCoordinates(e) {
    this.customSnappingLngLats.delete(e);
  }
  getSnappedLngLat(e, n) {
    let i = this.getCustomLngLatsSnapping(n);
    if (i)
      return i;
    const s = this.getFeaturesInPointBounds(n).filter(
      (o) => !this.excludedFeature.has(o)
    );
    return i = this.getFeaturePointsSnapping(s, e, n), i || (i = this.getFeatureLinesSnapping(s, e, n), i) ? i : e;
  }
  getCustomLngLatsSnapping(e) {
    const n = {
      distance: 1 / 0,
      lngLat: null
    };
    return this.customSnappingLngLats.forEach((i) => {
      i.forEach((s) => {
        const o = this.gm.mapAdapter.project(s), a = Zn(e, o);
        a < this.tolerance && a < n.distance && (n.distance = a, n.lngLat = s);
      });
    }), n.lngLat;
  }
  getFeaturePointsSnapping(e, n, i) {
    let s = e.map((o) => ({
      shape: o.shape,
      ...this.getPointsSnapping(o, n, i)
    })).filter((o) => o.distance < this.tolerance);
    return s.length ? (s = Ja(s, ["distance"]), s[0].lngLat) : null;
  }
  getFeatureLinesSnapping(e, n, i) {
    let s = e.filter(
      (o) => this.lineSnappingShapes.includes(o.shape)
    ).map((o) => {
      const a = this.shapeSnappingHandlers[o.shape];
      return a ? {
        shape: o.shape,
        ...a(o, n, i)
      } : null;
    }).filter(
      (o) => o !== null && o.distance < this.tolerance
    );
    return s.length ? (s = Ja(s, ["distance"]), s[0].lngLat) : null;
  }
  getFeaturesInPointBounds(e) {
    const n = [
      [e[0] - this.tolerance, e[1] - this.tolerance],
      [e[0] + this.tolerance, e[1] + this.tolerance]
    ];
    return this.gm.features.getFeaturesByScreenBounds(
      { bounds: n, sourceNames: [O.main, O.temporary] }
    ).filter((i) => i.temporary ? this.customSnappingFeatures.has(i) : !0) || [];
  }
  getPointsSnapping(e, n, i) {
    const s = e.getGeoJson(), o = {
      distance: 1 / 0,
      coord: null
      // lngLat coords
    };
    return bn(s, (a) => {
      const u = this.gm.mapAdapter.project(a.coordinate), l = Zn(i, u);
      l < this.tolerance && l < o.distance && (o.distance = l, o.coord = a.coordinate);
    }, !0), {
      lngLat: o.coord ? o.coord : n,
      distance: o.distance
    };
  }
  getLineSnapping(e, n, i) {
    const s = e.getGeoJson();
    return this.getNearestLinePointData(s, n, i);
  }
  getNearestLinePointData(e, n, i) {
    const s = {
      lngLat: n,
      distance: 1 / 0
    }, o = this.gm.mapAdapter.getEuclideanNearestLngLat(
      e,
      n
    ), a = this.gm.mapAdapter.project(o);
    return s.distance = Zn(a, i), s.distance < this.tolerance && (s.lngLat = o), s;
  }
}
class Tw extends ar {
  constructor() {
    super(...arguments);
    w(this, "mode", "zoom_to_features");
    w(this, "mapEventHandlers", {});
  }
  onStartAction() {
    this.fitMapToFeatures(), setTimeout(() => {
      this.gm.options.disableMode("helper", "zoom_to_features");
    });
  }
  onEndAction() {
  }
  fitMapToFeatures() {
    const e = this.gm.features.asGeoJsonFeatureCollection({
      sourceNames: [O.main, O.standby]
    }), n = nu(e), i = [
      [n[0], n[1]],
      [n[2], n[3]]
    ];
    try {
      this.gm.mapAdapter.fitBounds(i, { padding: 20 });
    } catch {
      N.warn("Wrong bounds for zooming to features", i, e);
    }
  }
}
const no = {
  shape_markers: Cw,
  pin: null,
  snapping: kw,
  snap_guides: null,
  measurements: null,
  auto_trace: null,
  geofencing: null,
  zoom_to_features: Tw,
  click_to_edit: null
}, Pw = (t, r) => no[r] ? new no[r](t) : (N.error(`Helper "${r}" is not available`), null);
class Iw extends Fi {
  constructor(e, n) {
    super(e);
    w(this, "mapEventHandlers", {
      [`${Y}:helper`]: this.handleHelperEvent.bind(this)
    });
    n.attachEvents(this.mapEventHandlers);
  }
  handleHelperEvent(e) {
    if (!Di(e))
      return { next: !0 };
    const n = `${e.type}__${e.mode}`;
    return e.action === "mode_start" ? (this.trackExclusiveModes(e), this.start(n, e), this.trackRelatedModes(e)) : e.action === "mode_end" && (this.trackRelatedModes(e), this.end(n)), { next: !0 };
  }
  start(e, n) {
    const i = Pw(this.gm, n.mode);
    i && (e in this.gm.actionInstances && N.error(`Action instance "${e}" already exists`), this.gm.actionInstances[e] = i, i.startAction());
  }
  end(e) {
    const n = this.gm.actionInstances[e];
    n instanceof ar ? (n.endAction(), delete this.gm.actionInstances[e]) : console.error(
      `Wrong action instance for edit event "${e}":`,
      n
    );
  }
}
class Fw {
  constructor(r) {
    w(this, "gm");
    w(this, "bus");
    w(this, "listeners", {});
    this.gm = r, this.bus = new Iy(this.gm), this.listeners = {
      draw: new k2(this.gm, this.bus),
      edit: new Aw(this.gm, this.bus),
      helper: new Iw(this.gm, this.bus),
      control: new Fy(this.gm, this.bus)
    };
  }
  fire(r, e) {
    this.listeners[e.type] || N.error(`Can't find event listener for "${e.type}" event type`), this.bus.fireEvent(r, e);
  }
}
class Dw {
  getEuclideanNearestLngLat(r, e) {
    const n = this.project(e);
    let i = [0, 0], s = 1 / 0;
    return Uu(r, (o) => {
      const a = this.project(o.start.coordinate), u = this.project(o.end.coordinate), l = Tm(
        a,
        u,
        n
      ), c = Zn(n, l);
      c < s && (s = c, i = [l[0], l[1]]);
    }), this.unproject(i);
  }
  getDistance(r, e) {
    return th(r, e, { units: "meters" });
  }
}
class Ow {
  isInstanceAvailable() {
    return this.layerInstance ? !0 : (N.error("layerInstance is not available"), !1);
  }
}
class xs extends Ow {
  constructor({ gm: e, layerId: n, options: i }) {
    super();
    w(this, "gm");
    w(this, "layerInstance", null);
    w(this, "mapInstance");
    this.gm = e, this.mapInstance = this.gm.mapAdapter.mapInstance, i ? this.layerInstance = this.createLayer(i) : this.layerInstance = this.mapInstance.getLayer(n) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.id;
  }
  get source() {
    if (!this.isInstanceAvailable())
      throw new Error("Layer instance is not available");
    return this.layerInstance.source;
  }
  createLayer(e) {
    return this.mapInstance.addLayer(e), this.mapInstance.getLayer(e.id) || null;
  }
  remove() {
    this.isInstanceAvailable() && this.mapInstance.removeLayer(this.id), this.layerInstance = null;
  }
}
class Gw extends so {
  constructor({ mapInstance: e, options: n, lngLat: i }) {
    super();
    w(this, "markerInstance");
    this.markerInstance = new io.Marker(n).setLngLat(i).addTo(e);
  }
  getElement() {
    var e;
    return this.isMarkerInstanceAvailable() && ((e = this.markerInstance) == null ? void 0 : e.getElement()) || null;
  }
  setLngLat(e) {
    var n;
    this.isMarkerInstanceAvailable() && ((n = this.markerInstance) == null || n.setLngLat(e));
  }
  getLngLat() {
    var e;
    return this.isMarkerInstanceAvailable() ? ((e = this.markerInstance) == null ? void 0 : e.getLngLat().toArray()) || [0, 0] : [0, 0];
  }
  remove() {
    var e;
    (e = this.markerInstance) == null || e.remove();
  }
}
class Rw {
  isInstanceAvailable() {
    return this.popupInstance ? !0 : (N.error("Popup instance is not available"), !1);
  }
}
class Bw extends Rw {
  constructor({ mapInstance: e, options: n, lngLat: i }) {
    super();
    w(this, "popupInstance");
    this.popupInstance = new io.Popup(n).addTo(e), i && this.setLngLat(i);
  }
  getLngLat() {
    return this.isInstanceAvailable() ? this.popupInstance.getLngLat().toArray() || [0, 0] : [0, 0];
  }
  setLngLat(e) {
    this.isInstanceAvailable() && this.popupInstance.setLngLat(e);
  }
  setHtml(e) {
    this.isInstanceAvailable() && this.popupInstance.setHTML(e);
  }
  remove() {
    this.isInstanceAvailable() && this.popupInstance.remove();
  }
}
class Vl extends Bm {
  constructor({ gm: e, geoJson: n, sourceId: i }) {
    super();
    w(this, "gm");
    w(this, "mapInstance");
    w(this, "sourceInstance");
    this.gm = e, this.mapInstance = this.gm.mapAdapter.mapInstance, n ? this.sourceInstance = this.createSource({ geoJson: n, sourceId: i }) : this.sourceInstance = this.mapInstance.getSource(i) || null;
  }
  get id() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.id;
  }
  createSource({ geoJson: e, sourceId: n }) {
    return this.mapInstance.addSource(n, {
      type: "geojson",
      data: e
    }), this.mapInstance.getSource(n) || null;
  }
  getGeoJson() {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.serialize().data;
  }
  setGeoJson(e) {
    if (!this.isInstanceAvailable())
      throw new Error("Source instance is not available");
    return this.sourceInstance.setData(e);
  }
  updateData(e) {
    if (!this.isInstanceAvailable())
      return;
    const n = this.convertGeoJsonDiffToMlDiff(e);
    this.sourceInstance.updateData(n);
  }
  convertGeoJsonDiffToMlDiff(e) {
    return {
      add: e.add,
      update: e.update.map(this.convertFeatureToMlUpdateDiff.bind(this)),
      remove: e.remove
    };
  }
  convertFeatureToMlUpdateDiff(e) {
    const n = Object.entries(e.properties || {}).map((i) => ({ key: i[0], value: i[1] }));
    return {
      id: e.id,
      newGeometry: e.geometry,
      addOrUpdateProperties: n
    };
  }
  remove({ removeLayers: e }) {
    this.isInstanceAvailable() && (e && this.gm.mapAdapter.eachLayer((n) => {
      n.source === this.sourceInstance.id && this.gm.mapAdapter.removeLayer(n.id);
    }), this.mapInstance.removeSource(this.sourceInstance.id));
  }
}
class Nw extends Dw {
  constructor(e, n) {
    super();
    w(this, "gm");
    w(this, "mapType", "maplibre");
    w(this, "mapInstance");
    this.gm = n, this.mapInstance = e;
  }
  getMapInstance() {
    return this.mapInstance;
  }
  isLoaded() {
    return this.mapInstance.loaded();
  }
  getContainer() {
    return this.mapInstance.getContainer();
  }
  getCanvas() {
    return this.mapInstance.getCanvas();
  }
  addControl(e) {
    this.mapInstance.addControl(e);
  }
  removeControl(e) {
    this.mapInstance.removeControl(e);
  }
  async loadImage({ id: e, image: n }) {
    const i = await this.mapInstance.loadImage(n);
    this.mapInstance.addImage(e, i.data);
  }
  getBounds() {
    return this.mapInstance.getBounds().toArray();
  }
  fitBounds(e, n) {
    this.mapInstance.fitBounds(e, n);
  }
  setCursor(e) {
    this.mapInstance.getCanvas().style.cursor = e;
  }
  disableMapInteractions(e) {
    e.forEach((n) => {
      this.mapInstance[n].disable();
    });
  }
  enableMapInteractions(e) {
    e.forEach((n) => {
      this.mapInstance[n].enable();
    });
  }
  setDragPan(e) {
    e ? this.mapInstance.dragPan.enable() : this.mapInstance.dragPan.disable();
  }
  queryFeaturesByScreenCoordinates({ queryCoordinates: e = void 0, sourceNames: n }) {
    return Is(this.mapInstance.queryRenderedFeatures(e).map((s) => ({
      featureId: s.properties[xr],
      featureSourceName: s.source
    })), Mn).map(({ featureId: s, featureSourceName: o }) => s === void 0 || !n.includes(o) ? null : this.gm.features.get(o, s) || null).filter((s) => !!s);
  }
  queryGeoJsonFeatures({ queryCoordinates: e = void 0, sourceNames: n }) {
    const i = (o, a) => (o == null ? void 0 : o.id) === (a == null ? void 0 : a.id);
    return Is(this.mapInstance.queryRenderedFeatures(e).map((o) => {
      const a = this.convertToGeoJsonImportFeature(o);
      return a ? {
        id: o.properties[xr],
        sourceName: o.source,
        geoJson: a
      } : null;
    }), i).filter(
      (o) => !!o && o.id !== void 0 && o.geoJson && n.includes(o.sourceName)
    );
  }
  convertToGeoJsonImportFeature(e) {
    const n = e.properties[xr];
    return n === void 0 || e.geometry.type === "GeometryCollection" ? null : {
      id: n,
      type: "Feature",
      properties: e.properties,
      geometry: e.geometry
    };
  }
  addSource(e, n) {
    return new Vl({ gm: this.gm, sourceId: e, geoJson: n });
  }
  getSource(e) {
    return new Vl({ gm: this.gm, sourceId: e });
  }
  addLayer(e) {
    const n = e.id;
    return new xs({ gm: this.gm, layerId: n, options: e });
  }
  getLayer(e) {
    return new xs({ gm: this.gm, layerId: e });
  }
  removeLayer(e) {
    const n = this.getLayer(e);
    n && n.remove();
  }
  eachLayer(e) {
    this.mapInstance.getStyle().layers.forEach((n) => {
      e(new xs({ gm: this.gm, layerId: n.id }));
    });
  }
  createDomMarker(e, n) {
    return new Gw({
      mapInstance: this.mapInstance,
      options: e,
      lngLat: n
    });
  }
  createPopup(e, n) {
    return new Bw({
      mapInstance: this.mapInstance,
      options: e,
      lngLat: n
    });
  }
  project(e) {
    const n = this.mapInstance.project(e);
    return [n.x, n.y];
  }
  unproject(e) {
    const n = this.mapInstance.unproject(e);
    return [n.lng, n.lat];
  }
  coordBoundsToScreenBounds(e) {
    const n = new io.LngLatBounds(e), i = this.project(n.getSouthWest().toArray()), s = this.project(n.getNorthEast().toArray());
    return [i, s];
  }
  fire(e, n) {
    this.mapInstance.fire(e, n);
  }
  on(e, n, i) {
    if (typeof n == "string" && i && is(e))
      this.mapInstance.on(e, n, i);
    else if (typeof n == "function")
      this.mapInstance.on(e, n);
    else
      throw new Error("Invalid arguments passed to 'on' method");
  }
  once(e, n, i) {
    if (typeof n == "string" && i && is(e))
      this.mapInstance.once(e, n, i);
    else if (typeof n == "function")
      this.mapInstance.once(e, n);
    else
      throw new Error("Invalid arguments passed to 'once' method.");
  }
  off(e, n, i) {
    if (typeof n == "string" && i && is(e))
      this.mapInstance.off(e, n, i);
    else if (typeof n == "function")
      this.mapInstance.off(e, n);
    else
      throw new Error("Invalid arguments passed to 'off' method");
  }
}
const Uw = async (t, r) => new Nw(r, t), Hw = (t, r) => {
  if (Array.isArray(t) && Array.isArray(r)) {
    const e = mm(t, "type");
    return r.forEach((n) => {
      e[n.type] ? vm(e[n.type], n) : e[n.type] = je(n);
    }), fm(e);
  }
};
class zw {
  constructor(r, e = {}) {
    w(this, "gm");
    w(this, "settings");
    w(this, "controls");
    w(this, "layerStyles");
    this.gm = r;
    const n = am(
      sc(),
      e,
      Hw
    );
    this.settings = n.settings, this.controls = n.controls, this.layerStyles = n.layerStyles;
  }
  enableMode(r, e) {
    const n = this.isModeEnabled(r, e), i = this.isModeAvailable(r, e);
    if (i || N.warn(`Unable to enable mode, "${r}:${e}" is not available`), n || !i)
      return;
    const o = this.controls[r][e];
    o ? (o.active = !0, this.fireModeEvent(r, e, "mode_start"), this.fireControlEvent(r, e, "on"), this.fireModeEvent(r, e, "mode_started")) : N.error("Can't find control section for", r, e);
  }
  disableMode(r, e) {
    const n = this.isModeEnabled(r, e), i = this.isModeAvailable(r, e);
    if (!n || !i)
      return;
    const o = this.controls[r][e];
    o ? (o.active = !1, this.fireModeEvent(r, e, "mode_end"), this.fireControlEvent(r, e, "off"), this.fireModeEvent(r, e, "mode_ended")) : N.error("Can't find control section for", r, e);
  }
  syncModeState(r, e) {
    const i = this.controls[r][e], s = this.isModeAvailable(r, e);
    i && (s ? i.active ? this.enableMode(r, e) : this.disableMode(r, e) : (i.active = !1, i.uiEnabled = !1));
  }
  toggleMode(r, e) {
    this.isModeEnabled(r, e) ? this.disableMode(r, e) : this.enableMode(r, e);
  }
  isModeEnabled(r, e) {
    return !!Object.entries(this.gm.actionInstances).find(([n, i]) => n === `${r}__${e}` && i);
  }
  isModeAvailable(r, e) {
    return r === "draw" && Kt(e, ju) ? !!js[e] : r === "edit" && Kt(e, Yc) ? !!ro[e] : r === "helper" && Kt(e, Wc) ? !!no[e] : !1;
  }
  getControlOptions({ actionType: r, modeName: e }) {
    return r && e && this.controls[r][e] || null;
  }
  fireModeEvent(r, e, n) {
    const i = {
      level: "system",
      type: r,
      mode: e,
      action: n
    };
    xo(i) && (So(i) ? this.gm.events.fire(`${Y}:${r}`, i) : Br(i) ? this.gm.events.fire(`${Y}:${r}`, i) : Di(i) && this.gm.events.fire(`${Y}:${r}`, i));
  }
  fireControlEvent(r, e, n) {
    const i = {
      level: "system",
      type: "control",
      section: r,
      target: e,
      action: n
    };
    this.gm.events.fire(`${Y}:control`, i);
  }
}
class Jw {
  constructor(r) {
    w(this, "gm");
    w(this, "marker", null);
    w(this, "tmpMarker", null);
    w(this, "snapping", !1);
    w(this, "oldSnapping");
    this.gm = r, this.initEventHandlers();
  }
  initEventHandlers() {
    this.throttledMethods = Rr({
      onMouseMove: this.onMouseMove
    }, this, this.gm.options.settings.throttlingDelay), this.mapEventHandlers = {
      mousemove: this.throttledMethods.onMouseMove.bind(this)
    };
  }
  get snappingHelper() {
    return this.gm.actionInstances.helper__snapping || null;
  }
  setSnapping(r) {
    if (r && !this.snappingHelper) {
      N.error("MarkerPointer: snapping is not available");
      return;
    }
    this.snapping = r;
  }
  pauseSnapping() {
    this.oldSnapping !== void 0 && N.error("MarkerPointer: snapping is already paused"), this.oldSnapping = this.snapping, this.setSnapping(!1);
  }
  resumeSnapping() {
    this.oldSnapping === void 0 ? (N.error("MarkerPointer: resumeSnapping is called before pauseSnapping"), this.setSnapping(!0)) : (this.setSnapping(this.oldSnapping), this.oldSnapping = void 0);
  }
  enable({ lngLat: r, customMarker: e, invisibleMarker: n } = {
    lngLat: [0, 0],
    customMarker: void 0,
    invisibleMarker: !1
  }) {
    if (!Oy()) {
      if (e && n)
        throw new Error("MarkerPointer: customMarker and invisibleMarker can't be used together");
      if (this.marker)
        throw new Error("MarkerPointer: marker is already enabled");
      this.gm.events.bus.attachEvents(this.mapEventHandlers), n ? this.marker = this.createInvisibleMarker(r || [0, 0]) : this.marker = e || this.createMarker(r || [0, 0]), this.gm.getActiveDrawModes().length && this.gm.mapAdapter.setCursor("crosshair");
    }
  }
  disable() {
    this.marker && (this.gm.events.bus.detachEvents(this.mapEventHandlers), this.marker.remove(), this.marker = null), this.gm.mapAdapter.setCursor("");
  }
  createMarker(r = [0, 0]) {
    return this.gm.mapAdapter.createDomMarker({
      anchor: "center",
      element: jc("dom", { pointerEvents: "none" })
    }, r);
  }
  createInvisibleMarker(r = [0, 0]) {
    const e = document.createElement("div");
    return e.style.width = "0px", e.style.height = "0px", this.gm.mapAdapter.createDomMarker({
      anchor: "center",
      element: e
    }, r);
  }
  onMouseMove(r) {
    if (ve(r, { warning: !0 }) && this.marker)
      if (this.snapping && this.snappingHelper) {
        const e = [r.point.x, r.point.y], n = this.snappingHelper.getSnappedLngLat(r.lngLat.toArray(), e);
        this.marker.setLngLat(n);
      } else
        this.marker.setLngLat(r.lngLat.toArray());
    return { next: !0 };
  }
  syncTmpMarker(r) {
    this.tmpMarker || (this.tmpMarker = this.createMarker(r)), this.tmpMarker.setLngLat(r);
  }
}
class qw {
  constructor(r, e = {}) {
    w(this, "mapAdapterInstance", null);
    w(this, "globalLngLatBounds", this.getGlobalLngLatBounds());
    w(this, "features");
    w(this, "loaded", !1);
    w(this, "options");
    w(this, "events");
    w(this, "control");
    w(this, "actionInstances", {});
    w(this, "markerPointer");
    const n = Object.assign(r, { gm: this });
    this.options = new zw(this, e), this.events = new Fw(this), this.features = new y1(this), this.control = new ky(this), this.markerPointer = new Jw(this), v1(r) && r.once("load", async () => {
      this.mapAdapterInstance = await Uw(this, n), this.features.init(), await this.addControls();
    });
  }
  get mapAdapter() {
    if (this.mapAdapterInstance)
      return this.mapAdapterInstance;
    throw N.trace("Map adapter is not initialized"), new Error("Map adapter is not initialized");
  }
  addControls(r = void 0) {
    return new Promise((e) => {
      (async () => {
        N.debug("handleCreateControls"), r ? this.control.createControls(r) : this.mapAdapter.addControl(this.control), await this.onMapLoad(), e();
      })().then();
    });
  }
  removeControl() {
    return new Promise((r) => {
      this.disableAllModes(), this.mapAdapter.removeControl(this.control), r();
    });
  }
  async onMapLoad() {
    this.loaded || (await this.mapAdapter.loadImage({
      id: "default-marker",
      image: jl
    }), this.events.fire(`${Y}:control`, {
      level: "system",
      type: "control",
      action: "loaded"
    }), this.loaded = !0);
  }
  disableAllModes() {
    Re(this.actionInstances).forEach((r) => {
      const [e, n] = r.split("__");
      jy(e) && Qy(n) && this.options.disableMode(e, n);
    });
  }
  getActiveDrawModes() {
    return Re(this.actionInstances).map((r) => {
      const e = this.actionInstances[r];
      return e instanceof Pt ? e.mode : null;
    }).filter((r) => r !== null);
  }
  getActiveEditModes() {
    return Re(this.actionInstances).map((r) => {
      const e = this.actionInstances[r];
      return e instanceof kn ? e.mode : null;
    }).filter((r) => r !== null);
  }
  getActiveHelperModes() {
    return Re(this.actionInstances).map((r) => {
      const e = this.actionInstances[r];
      return e instanceof ar ? e.mode : null;
    }).filter((r) => r !== null);
  }
  getGlobalLngLatBounds() {
    return [
      [-179.99999, -85.051129],
      [179.99999, 85.051129]
    ];
  }
  setGlobalEventsListener(r = null) {
    this.events.bus.forwarder.globalEventsListener = r;
  }
  enableMode(r, e) {
    this.options.enableMode(r, e);
  }
  disableMode(r, e) {
    this.options.disableMode(r, e);
  }
  toggleMode(r, e) {
    this.options.toggleMode(r, e);
  }
  isModeEnabled(r, e) {
    return this.options.isModeEnabled(r, e);
  }
  // helper methods for compatibility with the old API
  // draw (draw:*)
  enableDraw(r) {
    this.options.enableMode("draw", r);
  }
  disableDraw() {
    this.getActiveDrawModes().forEach(
      (r) => this.options.disableMode("draw", r)
    );
  }
  toggleDraw(r) {
    this.options.toggleMode("draw", r);
  }
  drawEnabled(r) {
    return this.options.isModeEnabled("draw", r);
  }
  // drag(edit:drag)
  enableGlobalDragMode() {
    this.options.enableMode("edit", "drag");
  }
  disableGlobalDragMode() {
    this.options.disableMode("edit", "drag");
  }
  toggleGlobalDragMode() {
    this.options.toggleMode("edit", "drag");
  }
  globalDragModeEnabled() {
    return this.options.isModeEnabled("edit", "drag");
  }
  // edit (edit:change)
  enableGlobalEditMode() {
    this.options.enableMode("edit", "change");
  }
  disableGlobalEditMode() {
    this.options.disableMode("edit", "change");
  }
  toggleGlobalEditMode() {
    this.options.toggleMode("edit", "change");
  }
  globalEditModeEnabled() {
    return this.options.isModeEnabled("edit", "change");
  }
  // rotate (edit:rotate)
  enableGlobalRotateMode() {
    this.options.enableMode("edit", "rotate");
  }
  disableGlobalRotateMode() {
    this.options.disableMode("edit", "rotate");
  }
  toggleGlobalRotateMode() {
    this.options.toggleMode("edit", "rotate");
  }
  globalRotateModeEnabled() {
    return this.options.isModeEnabled("edit", "rotate");
  }
  // scale (edit:scale)
  enableGlobalScaleMode() {
    this.options.enableMode("edit", "scale");
  }
  disableGlobalScaleMode() {
    this.options.disableMode("edit", "scale");
  }
  toggleGlobalScaleMode() {
    this.options.toggleMode("edit", "scale");
  }
  globalScaleModeEnabled() {
    return this.options.isModeEnabled("edit", "scale");
  }
  // copy (edit:copy)
  enableGlobalCopyMode() {
    this.options.enableMode("edit", "copy");
  }
  disableGlobalCopyMode() {
    this.options.disableMode("edit", "copy");
  }
  toggleGlobalCopyMode() {
    this.options.toggleMode("edit", "copy");
  }
  globalCopyModeEnabled() {
    return this.options.isModeEnabled("edit", "copy");
  }
  // cut (edit:cut)
  enableGlobalCutMode() {
    this.options.enableMode("edit", "cut");
  }
  disableGlobalCutMode() {
    this.options.disableMode("edit", "cut");
  }
  toggleGlobalCutMode() {
    this.options.toggleMode("edit", "cut");
  }
  globalCutModeEnabled() {
    return this.options.isModeEnabled("edit", "cut");
  }
  // split (edit:split)
  enableGlobalSplitMode() {
    this.options.enableMode("edit", "split");
  }
  disableGlobalSplitMode() {
    this.options.disableMode("edit", "split");
  }
  toggleGlobalSplitMode() {
    this.options.toggleMode("edit", "split");
  }
  globalSplitModeEnabled() {
    return this.options.isModeEnabled("edit", "split");
  }
  // union (edit:union)
  enableGlobalUnionMode() {
    this.options.enableMode("edit", "union");
  }
  disableGlobalUnionMode() {
    this.options.disableMode("edit", "union");
  }
  toggleGlobalUnionMode() {
    this.options.toggleMode("edit", "union");
  }
  globalUnionModeEnabled() {
    return this.options.isModeEnabled("edit", "union");
  }
  // difference (edit:difference)
  enableGlobalDifferenceMode() {
    this.options.enableMode("edit", "difference");
  }
  disableGlobalDifferenceMode() {
    this.options.disableMode("edit", "difference");
  }
  toggleGlobalDifferenceMode() {
    this.options.toggleMode("edit", "difference");
  }
  globalDifferenceModeEnabled() {
    return this.options.isModeEnabled("edit", "difference");
  }
  // line_simplification (edit:line_simplification)
  enableGlobalLineSimplificationMode() {
    this.options.enableMode("edit", "line_simplification");
  }
  disableGlobalLineSimplificationMode() {
    this.options.disableMode("edit", "line_simplification");
  }
  toggleGlobalLineSimplificationMode() {
    this.options.toggleMode("edit", "line_simplification");
  }
  globalLineSimplificationModeEnabled() {
    return this.options.isModeEnabled("edit", "line_simplification");
  }
  // lasso (edit:lasso)
  enableGlobalLassoMode() {
    this.options.enableMode("edit", "lasso");
  }
  disableGlobalLassoMode() {
    this.options.disableMode("edit", "lasso");
  }
  toggleGlobalLassoMode() {
    this.options.toggleMode("edit", "lasso");
  }
  globalLassoModeEnabled() {
    return this.options.isModeEnabled("edit", "lasso");
  }
  // remove (edit:delete)
  enableGlobalRemovalMode() {
    this.options.enableMode("edit", "delete");
  }
  disableGlobalRemovalMode() {
    this.options.disableMode("edit", "delete");
  }
  toggleGlobalRemovalMode() {
    this.options.toggleMode("edit", "delete");
  }
  globalRemovalModeEnabled() {
    return this.options.isModeEnabled("edit", "delete");
  }
}
const jw = async (t, r) => {
  const n = new qw(t, r);
  return await Promise.race([
    new Promise((i) => {
      n.mapAdapter.once(`${Y}:loaded`, i);
    }),
    new Promise((i, s) => {
      setTimeout(() => s(new Error(`Timeout ${6e4 / 1e3} seconds: can't init geoman`)), 6e4);
    })
  ]), n;
};
export {
  so as BaseDomMarker,
  Ow as BaseLayer,
  Dw as BaseMapAdapter,
  Rw as BasePopup,
  Bm as BaseSource,
  xr as FEATURE_ID_PROPERTY,
  ui as FeatureData,
  qw as Geoman,
  jw as createGeomanInstance,
  ju as drawModes,
  Yc as editModes,
  zm as extraDrawModes,
  v1 as hasMapOnceMethod,
  Wc as helperModes,
  jy as isActionType,
  $w as isBaseMapEventName,
  Zy as isDrawModeName,
  Xy as isEditModeName,
  zt as isGmEvent,
  xo as isGmModeEvent,
  Ky as isHelperModeName,
  ve as isMapPointerEvent,
  Qy as isModeName,
  P2 as isNonEmptyArray,
  is as isPointerEventName,
  ci as shapeNames
};
